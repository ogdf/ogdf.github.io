<!-- HTML header for doxygen 1.8.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>ogdf: abacus::LP Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="govisual.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogdf-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
  <td align="center">
   <table border="0" cellspacing="0" cellpadding="0">
    <tr>
     <td width="264"><a href="http://www.ogdf.net" title="Go to www.ogdf.net" target="blank"><img  style="border-width: 0px" src="http://www.ogdf.net/lib/images/logoA.png"/></a></td>
     <td align="left"><h1 class="ogdftitle">Open<br>Graph Drawing<br>Framework</h1></td>
        <td align="left" valign="bottom" >
      <span style="font-size:110%; color:rgb(56,95,118)">&nbsp;v. snapshot-2016-12-05</span><br>&nbsp;
        </td>
    </tr>
   </table>
  </td>
 </tr>
 <tr>
  <td valign="bottom">
   <div class="menubox">
    <table border="0" cellpadding="0" cellspacing="0" class="menutable">
     <tr>
      <td><a class="menu" href="index.html" title="Start page with overview">Overview</a></td>
      <td><a class="menu" href="hierarchy.html" title="Inheritance hierarchies">Class&nbsp;Hierarchy</a></td>
      <td><a class="menu" href="classes.html" title="Alphabetical list of classes">Class&nbsp;Index</a></td>
      <td><a class="menu" href="annotated.html" title="Classes with brief descriptions">Class&nbsp;List</a></td>
      <td><a class="menu" href="functions.html" title="Complete list of member functions, enumerations, and variables">Members</a></td>
      <td><a class="menu" href="namespaces.html" title="Namespaces with brief descriptions">Namespaces</a></td>
      <td><a class="menu" href="files.html" title="Complete list of files with brief descriptions">Source&nbsp;Files</a></td>
          <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
     </tr>
    </table>
   </div><br>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classabacus_1_1_l_p.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classabacus_1_1_l_p-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">abacus::LP Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Linear programs.  
 <a href="classabacus_1_1_l_p.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lp_8h_source.html">ogdf/lib/abacus/lp.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for abacus::LP:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classabacus_1_1_l_p__inherit__graph.png" border="0" usemap="#abacus_1_1_l_p_inherit__map" alt="Inheritance graph"/></div>
<map name="abacus_1_1_l_p_inherit__map" id="abacus_1_1_l_p_inherit__map">
<area shape="rect" id="node3" href="classabacus_1_1_lp_sub.html" title="The linear program of a subproblem. " alt="" coords="5,155,115,181"/>
<area shape="rect" id="node5" href="classabacus_1_1_osi_i_f.html" title="abacus::OsiIF" alt="" coords="139,155,243,181"/>
<area shape="rect" id="node2" href="classabacus_1_1_abacus_root.html" title="Base class of all other classes of ABACUS. " alt="" coords="53,5,197,32"/>
<area shape="rect" id="node4" href="classabacus_1_1_lp_sub_osi.html" title="abacus::LpSubOsi" alt="" coords="61,229,190,256"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a80d390b461dca15f5aba8068995b0063"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a80d390b461dca15f5aba8068995b0063">METHOD</a> { <a class="el" href="classabacus_1_1_l_p.html#a80d390b461dca15f5aba8068995b0063aa779fe3c73e5abb3006ea218b88fc649">Primal</a>, 
<a class="el" href="classabacus_1_1_l_p.html#a80d390b461dca15f5aba8068995b0063a140644b022296cc7d1819e98abe0897e">Dual</a>, 
<a class="el" href="classabacus_1_1_l_p.html#a80d390b461dca15f5aba8068995b0063a712cbbde8ba9412aeaee7d118efff5b6">BarrierAndCrossover</a>, 
<a class="el" href="classabacus_1_1_l_p.html#a80d390b461dca15f5aba8068995b0063a91891705b80b35ba7c112403735b2b0e">BarrierNoCrossover</a>, 
<a class="el" href="classabacus_1_1_l_p.html#a80d390b461dca15f5aba8068995b0063af072e7bd770b14bda45848638e26d575">Approximate</a>
 }<tr class="memdesc:a80d390b461dca15f5aba8068995b0063"><td class="mdescLeft">&#160;</td><td class="mdescRight">The solution method for the linear program.  <a href="classabacus_1_1_l_p.html#a80d390b461dca15f5aba8068995b0063">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a80d390b461dca15f5aba8068995b0063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395bcfe1e844ad315ef7751c2ecc7dce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dce">OPTSTAT</a> { <a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dcea938ec3a6a577b393131776cf38fb58f8">Optimal</a>, 
<a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dcea2fbbc93edd9cad3ccbccbd3ca3c76a10">Unoptimized</a>, 
<a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dceac84a5243eaab09120e0c3507ac6055f2">Error</a>, 
<a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dcea05391eac30b1538c8e6068353cd71624">Feasible</a>, 
<a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dcea9d816f40986df5ce23605be3cf48dd4d">Infeasible</a>, 
<a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dceaaede2940973aaedafefe5dc4ce66d2b6">Unbounded</a>, 
<a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dcea0d254d6f1d870756a1a21a786a699639">LimitReached</a>
 }<tr class="memdesc:a395bcfe1e844ad315ef7751c2ecc7dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The optimization status of the linear program.  <a href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dce">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a395bcfe1e844ad315ef7751c2ecc7dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3412c25dc5258be2d6a6336c364693b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a> { <a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693bae1d8d4a84a6f95cdbd26127b0cb2d091">Available</a>, 
<a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693baae5256fcee8d4e973b9fdb062051261d">Missing</a>
 }<tr class="memdesc:ad3412c25dc5258be2d6a6336c364693b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes if parts of the solution like x-values, reduced costs, etc. are available.  <a href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad3412c25dc5258be2d6a6336c364693b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a88c9fecae5520857eeafc75f355e96fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a88c9fecae5520857eeafc75f355e96fc">LP</a> (<a class="el" href="classabacus_1_1_master.html">Master</a> *master)</td></tr>
<tr class="memdesc:a88c9fecae5520857eeafc75f355e96fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a linear program.  <a href="#a88c9fecae5520857eeafc75f355e96fc">More...</a><br /></td></tr>
<tr class="separator:a88c9fecae5520857eeafc75f355e96fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad96ee883633635f03b6998846fe6a67"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#aad96ee883633635f03b6998846fe6a67">~LP</a> ()</td></tr>
<tr class="memdesc:aad96ee883633635f03b6998846fe6a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor.  <a href="#aad96ee883633635f03b6998846fe6a67">More...</a><br /></td></tr>
<tr class="separator:aad96ee883633635f03b6998846fe6a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a2d40f40c7546d3bdd88a7439356ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a75a2d40f40c7546d3bdd88a7439356ff">addCols</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_column.html">Column</a> *&gt; &amp;newCols)</td></tr>
<tr class="memdesc:a75a2d40f40c7546d3bdd88a7439356ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds columns to the linear program.  <a href="#a75a2d40f40c7546d3bdd88a7439356ff">More...</a><br /></td></tr>
<tr class="separator:a75a2d40f40c7546d3bdd88a7439356ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fefb06fef51e65e05c060f03d9a7d5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a3fefb06fef51e65e05c060f03d9a7d5d">addRows</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_row.html">Row</a> *&gt; &amp;newRows)</td></tr>
<tr class="memdesc:a3fefb06fef51e65e05c060f03d9a7d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds rows to the linear program.  <a href="#a3fefb06fef51e65e05c060f03d9a7d5d">More...</a><br /></td></tr>
<tr class="separator:a3fefb06fef51e65e05c060f03d9a7d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08f11773a94f5088aeebee18c908db0"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ad08f11773a94f5088aeebee18c908db0">barXVal</a> (int i) const</td></tr>
<tr class="separator:ad08f11773a94f5088aeebee18c908db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb7cc563da968a8a5377baa6914d03d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#abbb7cc563da968a8a5377baa6914d03d">barXValStatus</a> () const</td></tr>
<tr class="separator:abbb7cc563da968a8a5377baa6914d03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3e7f38f2d55f85dea608eb2f92f5d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a7a3e7f38f2d55f85dea608eb2f92f5d5">basisStatus</a> () const</td></tr>
<tr class="separator:a7a3e7f38f2d55f85dea608eb2f92f5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9526432e360be1d3a1f6aa485389b8c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a9526432e360be1d3a1f6aa485389b8c2">changeLBound</a> (int i, double newLb)</td></tr>
<tr class="memdesc:a9526432e360be1d3a1f6aa485389b8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the lower bound of a single column.  <a href="#a9526432e360be1d3a1f6aa485389b8c2">More...</a><br /></td></tr>
<tr class="separator:a9526432e360be1d3a1f6aa485389b8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7c23292e45467e893ce94ca08e90bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a8e7c23292e45467e893ce94ca08e90bc">changeRhs</a> (<a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;newRhs)</td></tr>
<tr class="memdesc:a8e7c23292e45467e893ce94ca08e90bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the complete right hand side of the linear program.  <a href="#a8e7c23292e45467e893ce94ca08e90bc">More...</a><br /></td></tr>
<tr class="separator:a8e7c23292e45467e893ce94ca08e90bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5255cefa00d9d2aa98512ed71ec5ee41"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a5255cefa00d9d2aa98512ed71ec5ee41">changeUBound</a> (int i, double newUb)</td></tr>
<tr class="memdesc:a5255cefa00d9d2aa98512ed71ec5ee41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the upper bound of a single column.  <a href="#a5255cefa00d9d2aa98512ed71ec5ee41">More...</a><br /></td></tr>
<tr class="separator:a5255cefa00d9d2aa98512ed71ec5ee41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d6af6866177f8ca1211d1c2920a573"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a80d6af6866177f8ca1211d1c2920a573">colRealloc</a> (int newSize)</td></tr>
<tr class="memdesc:a80d6af6866177f8ca1211d1c2920a573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reallocation of the column space of the linear program.  <a href="#a80d6af6866177f8ca1211d1c2920a573">More...</a><br /></td></tr>
<tr class="separator:a80d6af6866177f8ca1211d1c2920a573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f4998ab35470adde7a4248e92183db"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a87f4998ab35470adde7a4248e92183db">getInfeas</a> (int &amp;infeasRow, int &amp;infeasCol, double *bInvRow) const</td></tr>
<tr class="memdesc:a87f4998ab35470adde7a4248e92183db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be called if the last linear program has been solved with the dual simplex method and is infeasible and all inactive variables price out correctly.  <a href="#a87f4998ab35470adde7a4248e92183db">More...</a><br /></td></tr>
<tr class="separator:a87f4998ab35470adde7a4248e92183db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b76d347de6c4c4a1e9eadad21de62c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ac2b76d347de6c4c4a1e9eadad21de62c">getSimplexIterationLimit</a> (int &amp;limit) const</td></tr>
<tr class="separator:ac2b76d347de6c4c4a1e9eadad21de62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043f9be10050bfd1d373a52f68d941e2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a043f9be10050bfd1d373a52f68d941e2">infeasible</a> () const</td></tr>
<tr class="separator:a043f9be10050bfd1d373a52f68d941e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2b2599c34a8a3b5c2566c0b99fb1fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a4f2b2599c34a8a3b5c2566c0b99fb1fc">initialize</a> (<a class="el" href="classabacus_1_1_opt_sense.html">OptSense</a> <a class="el" href="classabacus_1_1_l_p.html#a7184374cd10742c38f26164757eacc2d">sense</a>, int <a class="el" href="classabacus_1_1_l_p.html#ab7da9ce19af761f5f802291b5074c5db">nRow</a>, int <a class="el" href="classabacus_1_1_l_p.html#a24baf164e9e3d2c88afc73ef3dfebdc2">maxRow</a>, int <a class="el" href="classabacus_1_1_l_p.html#a5fba2c3f47ba007afc672634c17e2293">nCol</a>, int <a class="el" href="classabacus_1_1_l_p.html#ae40937f14564d39f0765048361095523">maxCol</a>, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;<a class="el" href="classabacus_1_1_l_p.html#ab625238c8ec36fe47f6c1ff9330fce4d">obj</a>, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;<a class="el" href="classabacus_1_1_l_p.html#a6602176eee0665ce5f79e73c6dfe0df1">lBound</a>, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;<a class="el" href="classabacus_1_1_l_p.html#aaa2333a128e0a3eb5429e180e1f1be52">uBound</a>, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_row.html">Row</a> *&gt; &amp;rows)</td></tr>
<tr class="memdesc:a4f2b2599c34a8a3b5c2566c0b99fb1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the linear program defined by its arguments.  <a href="#a4f2b2599c34a8a3b5c2566c0b99fb1fc">More...</a><br /></td></tr>
<tr class="separator:a4f2b2599c34a8a3b5c2566c0b99fb1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d4c994fa96f2d137f17a28f6ff37f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a25d4c994fa96f2d137f17a28f6ff37f1">initialize</a> (<a class="el" href="classabacus_1_1_opt_sense.html">OptSense</a> <a class="el" href="classabacus_1_1_l_p.html#a7184374cd10742c38f26164757eacc2d">sense</a>, int <a class="el" href="classabacus_1_1_l_p.html#ab7da9ce19af761f5f802291b5074c5db">nRow</a>, int <a class="el" href="classabacus_1_1_l_p.html#a24baf164e9e3d2c88afc73ef3dfebdc2">maxRow</a>, int <a class="el" href="classabacus_1_1_l_p.html#a5fba2c3f47ba007afc672634c17e2293">nCol</a>, int <a class="el" href="classabacus_1_1_l_p.html#ae40937f14564d39f0765048361095523">maxCol</a>, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;<a class="el" href="classabacus_1_1_l_p.html#ab625238c8ec36fe47f6c1ff9330fce4d">obj</a>, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;<a class="el" href="classabacus_1_1_l_p.html#a6602176eee0665ce5f79e73c6dfe0df1">lBound</a>, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;<a class="el" href="classabacus_1_1_l_p.html#aaa2333a128e0a3eb5429e180e1f1be52">uBound</a>, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_row.html">Row</a> *&gt; &amp;rows, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_l_p_v_a_r_s_t_a_t.html#a26136feb2521120a7c71e02e830af809">LPVARSTAT::STATUS</a> &gt; &amp;<a class="el" href="classabacus_1_1_l_p.html#a1b44feb09201b79fc0b6ba8c8807fb9b">lpVarStat</a>, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_slack_stat.html#a7aaac2c567af8d69a233ee04b7dc0bcb">SlackStat::STATUS</a> &gt; &amp;<a class="el" href="classabacus_1_1_l_p.html#a80cc53d882e8ec9a068b448e323f8601">slackStat</a>)</td></tr>
<tr class="memdesc:a25d4c994fa96f2d137f17a28f6ff37f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of the function <em><a class="el" href="classabacus_1_1_l_p.html#a4f2b2599c34a8a3b5c2566c0b99fb1fc" title="Loads the linear program defined by its arguments. ">initialize()</a></em> performs like its previous version, but also initializes the basis with the arguments:  <a href="#a25d4c994fa96f2d137f17a28f6ff37f1">More...</a><br /></td></tr>
<tr class="separator:a25d4c994fa96f2d137f17a28f6ff37f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6602176eee0665ce5f79e73c6dfe0df1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a6602176eee0665ce5f79e73c6dfe0df1">lBound</a> (int i) const</td></tr>
<tr class="separator:a6602176eee0665ce5f79e73c6dfe0df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a4c8000cd415695543e51af9677b14"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ae0a4c8000cd415695543e51af9677b14">loadBasis</a> (<a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_l_p_v_a_r_s_t_a_t.html#a26136feb2521120a7c71e02e830af809">LPVARSTAT::STATUS</a> &gt; &amp;<a class="el" href="classabacus_1_1_l_p.html#a1b44feb09201b79fc0b6ba8c8807fb9b">lpVarStat</a>, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_slack_stat.html#a7aaac2c567af8d69a233ee04b7dc0bcb">SlackStat::STATUS</a> &gt; &amp;<a class="el" href="classabacus_1_1_l_p.html#a80cc53d882e8ec9a068b448e323f8601">slackStat</a>)</td></tr>
<tr class="memdesc:ae0a4c8000cd415695543e51af9677b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a new basis for the linear program.  <a href="#ae0a4c8000cd415695543e51af9677b14">More...</a><br /></td></tr>
<tr class="separator:ae0a4c8000cd415695543e51af9677b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da50003a771fcb023899ea4e79112ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_stopwatch_c_p_u.html">ogdf::StopwatchCPU</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a9da50003a771fcb023899ea4e79112ac">lpSolverTime</a> ()</td></tr>
<tr class="separator:a9da50003a771fcb023899ea4e79112ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b44feb09201b79fc0b6ba8c8807fb9b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classabacus_1_1_l_p_v_a_r_s_t_a_t.html#a26136feb2521120a7c71e02e830af809">LPVARSTAT::STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a1b44feb09201b79fc0b6ba8c8807fb9b">lpVarStat</a> (int i) const</td></tr>
<tr class="separator:a1b44feb09201b79fc0b6ba8c8807fb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40937f14564d39f0765048361095523"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ae40937f14564d39f0765048361095523">maxCol</a> () const</td></tr>
<tr class="separator:ae40937f14564d39f0765048361095523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24baf164e9e3d2c88afc73ef3dfebdc2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a24baf164e9e3d2c88afc73ef3dfebdc2">maxRow</a> () const</td></tr>
<tr class="separator:a24baf164e9e3d2c88afc73ef3dfebdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fba2c3f47ba007afc672634c17e2293"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a5fba2c3f47ba007afc672634c17e2293">nCol</a> () const</td></tr>
<tr class="separator:a5fba2c3f47ba007afc672634c17e2293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bdc5cf22e0c52452c793bf32dd9b9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a17bdc5cf22e0c52452c793bf32dd9b9d">nnz</a> () const</td></tr>
<tr class="separator:a17bdc5cf22e0c52452c793bf32dd9b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac461cec05b89fbbd424ecc5d021f807b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ac461cec05b89fbbd424ecc5d021f807b">nOpt</a> () const</td></tr>
<tr class="separator:ac461cec05b89fbbd424ecc5d021f807b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7da9ce19af761f5f802291b5074c5db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ab7da9ce19af761f5f802291b5074c5db">nRow</a> () const</td></tr>
<tr class="separator:ab7da9ce19af761f5f802291b5074c5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab625238c8ec36fe47f6c1ff9330fce4d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ab625238c8ec36fe47f6c1ff9330fce4d">obj</a> (int i) const</td></tr>
<tr class="separator:ab625238c8ec36fe47f6c1ff9330fce4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9459572d6d04b194c493122977f22cd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dce">OPTSTAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#aa9459572d6d04b194c493122977f22cd">optimize</a> (<a class="el" href="classabacus_1_1_l_p.html#a80d390b461dca15f5aba8068995b0063">METHOD</a> method)</td></tr>
<tr class="memdesc:aa9459572d6d04b194c493122977f22cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the optimization of the linear program.  <a href="#aa9459572d6d04b194c493122977f22cd">More...</a><br /></td></tr>
<tr class="separator:aa9459572d6d04b194c493122977f22cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7d31b7e6ec21b482c58ebbd7490fa1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a0f7d31b7e6ec21b482c58ebbd7490fa1">pivotSlackVariableIn</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;rows)</td></tr>
<tr class="memdesc:a0f7d31b7e6ec21b482c58ebbd7490fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pivots the slack variables stored in the buffer <em>rows</em> into the basis.  <a href="#a0f7d31b7e6ec21b482c58ebbd7490fa1">More...</a><br /></td></tr>
<tr class="separator:a0f7d31b7e6ec21b482c58ebbd7490fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5554da2bde032986bd1d7956a5ff3194"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a5554da2bde032986bd1d7956a5ff3194">reco</a> (int i) const</td></tr>
<tr class="separator:a5554da2bde032986bd1d7956a5ff3194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac756edff57de5d8a073d27f5ada4505b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ac756edff57de5d8a073d27f5ada4505b">recoStatus</a> () const</td></tr>
<tr class="separator:ac756edff57de5d8a073d27f5ada4505b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11de783a1f17846f7652cdf71a4b382e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a11de783a1f17846f7652cdf71a4b382e">remCols</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;cols)</td></tr>
<tr class="memdesc:a11de783a1f17846f7652cdf71a4b382e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes columns from the linear program.  <a href="#a11de783a1f17846f7652cdf71a4b382e">More...</a><br /></td></tr>
<tr class="separator:a11de783a1f17846f7652cdf71a4b382e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8684247a0616681d8af24882e1b19b5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a8684247a0616681d8af24882e1b19b5d">remRows</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;ind)</td></tr>
<tr class="memdesc:a8684247a0616681d8af24882e1b19b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes rows of the linear program.  <a href="#a8684247a0616681d8af24882e1b19b5d">More...</a><br /></td></tr>
<tr class="separator:a8684247a0616681d8af24882e1b19b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17faeb4b7f9e400cdf8367b718d3de0e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a17faeb4b7f9e400cdf8367b718d3de0e">rhs</a> (int i) const</td></tr>
<tr class="separator:a17faeb4b7f9e400cdf8367b718d3de0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0261fde619e348415b63928c944b3a52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a0261fde619e348415b63928c944b3a52">row</a> (int i, <a class="el" href="classabacus_1_1_row.html">Row</a> &amp;r) const</td></tr>
<tr class="separator:a0261fde619e348415b63928c944b3a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624c75dec155251d5d5f468f94a249a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a624c75dec155251d5d5f468f94a249a1">rowRealloc</a> (int newSize)</td></tr>
<tr class="memdesc:a624c75dec155251d5d5f468f94a249a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reallocation of the row space of the linear program.  <a href="#a624c75dec155251d5d5f468f94a249a1">More...</a><br /></td></tr>
<tr class="separator:a624c75dec155251d5d5f468f94a249a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7184374cd10742c38f26164757eacc2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_opt_sense.html">OptSense</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a7184374cd10742c38f26164757eacc2d">sense</a> () const</td></tr>
<tr class="separator:a7184374cd10742c38f26164757eacc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29d96d3a191c8af85fb8a9fb9e92130"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ad29d96d3a191c8af85fb8a9fb9e92130">sense</a> (const <a class="el" href="classabacus_1_1_opt_sense.html">OptSense</a> &amp;newSense)</td></tr>
<tr class="separator:ad29d96d3a191c8af85fb8a9fb9e92130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1eba72e8f92680cad57e8fc6999f2dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ad1eba72e8f92680cad57e8fc6999f2dc">setSimplexIterationLimit</a> (int limit)</td></tr>
<tr class="memdesc:ad1eba72e8f92680cad57e8fc6999f2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the iteration limit of the Simplex algorithm.  <a href="#ad1eba72e8f92680cad57e8fc6999f2dc">More...</a><br /></td></tr>
<tr class="separator:ad1eba72e8f92680cad57e8fc6999f2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7181ea4803725e79e4c7c585f61fe666"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a7181ea4803725e79e4c7c585f61fe666">slack</a> (int c) const</td></tr>
<tr class="separator:a7181ea4803725e79e4c7c585f61fe666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cc53d882e8ec9a068b448e323f8601"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classabacus_1_1_slack_stat.html#a7aaac2c567af8d69a233ee04b7dc0bcb">SlackStat::STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a80cc53d882e8ec9a068b448e323f8601">slackStat</a> (int i) const</td></tr>
<tr class="separator:a80cc53d882e8ec9a068b448e323f8601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7ab054d5a8c97dc49c1316bccac236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a0c7ab054d5a8c97dc49c1316bccac236">slackStatus</a> () const</td></tr>
<tr class="separator:a0c7ab054d5a8c97dc49c1316bccac236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2333a128e0a3eb5429e180e1f1be52"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#aaa2333a128e0a3eb5429e180e1f1be52">uBound</a> (int i) const</td></tr>
<tr class="separator:aaa2333a128e0a3eb5429e180e1f1be52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8ebc42f83d415025efdd14af1ef06b"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a7c8ebc42f83d415025efdd14af1ef06b">value</a> () const</td></tr>
<tr class="separator:a7c8ebc42f83d415025efdd14af1ef06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcca1cf514226f3d7aa16837044f6b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a9bcca1cf514226f3d7aa16837044f6b5">writeBasisMatrix</a> (const char *fileName)</td></tr>
<tr class="memdesc:a9bcca1cf514226f3d7aa16837044f6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the complete basis of an optimal linear program to a file.  <a href="#a9bcca1cf514226f3d7aa16837044f6b5">More...</a><br /></td></tr>
<tr class="separator:a9bcca1cf514226f3d7aa16837044f6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4850f2f08186f8bd36ac2cfdc6149eb9"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a4850f2f08186f8bd36ac2cfdc6149eb9">xVal</a> (int i) const</td></tr>
<tr class="separator:a4850f2f08186f8bd36ac2cfdc6149eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e8566a848120256715b6529badc527"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ad2e8566a848120256715b6529badc527">xValStatus</a> () const</td></tr>
<tr class="separator:ad2e8566a848120256715b6529badc527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a561cec2e45a9eee87627e0891bda18"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a6a561cec2e45a9eee87627e0891bda18">yVal</a> (int c) const</td></tr>
<tr class="separator:a6a561cec2e45a9eee87627e0891bda18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ac5e3995dc60c27ee798566d5e19e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a33ac5e3995dc60c27ee798566d5e19e8">yValStatus</a> () const</td></tr>
<tr class="separator:a33ac5e3995dc60c27ee798566d5e19e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classabacus_1_1_abacus_root"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classabacus_1_1_abacus_root')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classabacus_1_1_abacus_root.html">abacus::AbacusRoot</a></td></tr>
<tr class="memitem:a91426fee38507bff91199b0302a1b77f inherit pub_methods_classabacus_1_1_abacus_root"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_abacus_root.html#a91426fee38507bff91199b0302a1b77f">~AbacusRoot</a> ()</td></tr>
<tr class="memdesc:a91426fee38507bff91199b0302a1b77f inherit pub_methods_classabacus_1_1_abacus_root"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor.  <a href="classabacus_1_1_abacus_root.html#a91426fee38507bff91199b0302a1b77f">More...</a><br /></td></tr>
<tr class="separator:a91426fee38507bff91199b0302a1b77f inherit pub_methods_classabacus_1_1_abacus_root"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5a790a5d32c5f3683ed6a0aae9fc8aad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a5a790a5d32c5f3683ed6a0aae9fc8aad">_addCols</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_column.html">Column</a> *&gt; &amp;newCols)=0</td></tr>
<tr class="memdesc:a5a790a5d32c5f3683ed6a0aae9fc8aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a5a790a5d32c5f3683ed6a0aae9fc8aad" title="The pure virtual function _addCols() must be defined by the used LP-solver and should add the columns...">_addCols()</a></em> must be defined by the used LP-solver and should add the columns <em>newCols</em> to the <a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a>.  <a href="#a5a790a5d32c5f3683ed6a0aae9fc8aad">More...</a><br /></td></tr>
<tr class="separator:a5a790a5d32c5f3683ed6a0aae9fc8aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811a81248bfa09a441ea28de823f2b66"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a811a81248bfa09a441ea28de823f2b66">_addRows</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_row.html">Row</a> *&gt; &amp;newRows)=0</td></tr>
<tr class="memdesc:a811a81248bfa09a441ea28de823f2b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a811a81248bfa09a441ea28de823f2b66" title="The pure virtual function _addRows() must be defined by the used LP-solver and should add the rows gi...">_addRows()</a></em> must be defined by the used LP-solver and should add the rows given in the buffer <em>newRows</em> to the <a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a>.  <a href="#a811a81248bfa09a441ea28de823f2b66">More...</a><br /></td></tr>
<tr class="separator:a811a81248bfa09a441ea28de823f2b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcbbff20e1347b34dde590c8679a4df"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dce">OPTSTAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a4dcbbff20e1347b34dde590c8679a4df">_approx</a> ()=0</td></tr>
<tr class="memdesc:a4dcbbff20e1347b34dde590c8679a4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a4dcbbff20e1347b34dde590c8679a4df" title="The pure virtual function _approx() must be defined by the used LP-solver and should call the approxi...">_approx()</a></em> must be defined by the used LP-solver and should call the approximative method of the used LP-solver.  <a href="#a4dcbbff20e1347b34dde590c8679a4df">More...</a><br /></td></tr>
<tr class="separator:a4dcbbff20e1347b34dde590c8679a4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91af637e3bc9f0f739864a3a96237b5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dce">OPTSTAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#aa91af637e3bc9f0f739864a3a96237b5">_barrier</a> (bool doCrossover)=0</td></tr>
<tr class="memdesc:aa91af637e3bc9f0f739864a3a96237b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#aa91af637e3bc9f0f739864a3a96237b5" title="The pure virtual function _barrier() must be defined by the used LP-solver and should call the barrie...">_barrier()</a></em> must be defined by the used LP-solver and should call the barrier method of the used LP-solver.  <a href="#aa91af637e3bc9f0f739864a3a96237b5">More...</a><br /></td></tr>
<tr class="separator:aa91af637e3bc9f0f739864a3a96237b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75347fe85fbdf137512372b31b01f99e"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a75347fe85fbdf137512372b31b01f99e">_barXVal</a> (int i) const =0</td></tr>
<tr class="separator:a75347fe85fbdf137512372b31b01f99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17a576eb3307b9961ddd185eb905cfc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ae17a576eb3307b9961ddd185eb905cfc">_changeLBound</a> (int i, double newLb)=0</td></tr>
<tr class="memdesc:ae17a576eb3307b9961ddd185eb905cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#ae17a576eb3307b9961ddd185eb905cfc" title="The pure virtual function _changeLBound() must be defined by the used LP-solver and should set the lo...">_changeLBound()</a></em> must be defined by the used LP-solver and should set the lower bound of variable <em>i</em> to <em>newLb</em>.  <a href="#ae17a576eb3307b9961ddd185eb905cfc">More...</a><br /></td></tr>
<tr class="separator:ae17a576eb3307b9961ddd185eb905cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293de2aed9a9dabd0a93bd12a292023d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a293de2aed9a9dabd0a93bd12a292023d">_changeRhs</a> (<a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;newRhs)=0</td></tr>
<tr class="memdesc:a293de2aed9a9dabd0a93bd12a292023d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a293de2aed9a9dabd0a93bd12a292023d" title="The pure virtual function _changeRhs() must be defined by the used LP-solver and should set the right...">_changeRhs()</a></em> must be defined by the used LP-solver and should set the right hand side of the constraint matrix of the <a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a> to <em>newRhs</em>.  <a href="#a293de2aed9a9dabd0a93bd12a292023d">More...</a><br /></td></tr>
<tr class="separator:a293de2aed9a9dabd0a93bd12a292023d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6926cb13e4ccc343bc60343e8f11739"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ab6926cb13e4ccc343bc60343e8f11739">_changeUBound</a> (int i, double newUb)=0</td></tr>
<tr class="memdesc:ab6926cb13e4ccc343bc60343e8f11739"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#ae17a576eb3307b9961ddd185eb905cfc" title="The pure virtual function _changeLBound() must be defined by the used LP-solver and should set the lo...">_changeLBound()</a></em> must be defined by the used LP-solver and should set the upper bound of variable <em>i</em> to <em>newUb</em>.  <a href="#ab6926cb13e4ccc343bc60343e8f11739">More...</a><br /></td></tr>
<tr class="separator:ab6926cb13e4ccc343bc60343e8f11739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cbbacd5adb60c4fbb40dfc9d207a1d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a70cbbacd5adb60c4fbb40dfc9d207a1d">_colRealloc</a> (int newSize)=0</td></tr>
<tr class="memdesc:a70cbbacd5adb60c4fbb40dfc9d207a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a70cbbacd5adb60c4fbb40dfc9d207a1d" title="The pure virtual function _colRealloc() must be defined by the used LP-solver and should reallocate i...">_colRealloc()</a></em> must be defined by the used LP-solver and should reallocate its memory such that up to <em>newSize</em> columns can be handled.  <a href="#a70cbbacd5adb60c4fbb40dfc9d207a1d">More...</a><br /></td></tr>
<tr class="separator:a70cbbacd5adb60c4fbb40dfc9d207a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77268ead1c5376d13ac6646b5ea48f95"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dce">OPTSTAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a77268ead1c5376d13ac6646b5ea48f95">_dualSimplex</a> ()=0</td></tr>
<tr class="memdesc:a77268ead1c5376d13ac6646b5ea48f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a77268ead1c5376d13ac6646b5ea48f95" title="The pure virtual function _dualSimplex() must be defined by the used LP-solver and should call the du...">_dualSimplex()</a></em> must be defined by the used LP-solver and should call the dual simplex method of the used LP-solver.  <a href="#a77268ead1c5376d13ac6646b5ea48f95">More...</a><br /></td></tr>
<tr class="separator:a77268ead1c5376d13ac6646b5ea48f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00621477dcd3565de7765ed4e1b0699e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a00621477dcd3565de7765ed4e1b0699e">_getInfeas</a> (int &amp;infeasRow, int &amp;infeasCol, double *bInvRow) const =0</td></tr>
<tr class="memdesc:a00621477dcd3565de7765ed4e1b0699e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a00621477dcd3565de7765ed4e1b0699e" title="The pure virtual function _getInfeas() must be defined by the used LP-solver and can be called if the...">_getInfeas()</a></em> must be defined by the used LP-solver and can be called if the last linear program has been solved with the dual simplex method and is infeasible.  <a href="#a00621477dcd3565de7765ed4e1b0699e">More...</a><br /></td></tr>
<tr class="separator:a00621477dcd3565de7765ed4e1b0699e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3643db55c879004aacbbf661b303b993"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a3643db55c879004aacbbf661b303b993">_getSimplexIterationLimit</a> (int &amp;limit) const =0</td></tr>
<tr class="memdesc:a3643db55c879004aacbbf661b303b993"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function <em><a class="el" href="classabacus_1_1_l_p.html#ac2b76d347de6c4c4a1e9eadad21de62c">getSimplexIterationLimit()</a></em> retrieves the value of the iteration limit of the simplex algorithm.  <a href="#a3643db55c879004aacbbf661b303b993">More...</a><br /></td></tr>
<tr class="separator:a3643db55c879004aacbbf661b303b993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacc389579d42c4cd14297ca91aa0c48"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#abacc389579d42c4cd14297ca91aa0c48">_initialize</a> (<a class="el" href="classabacus_1_1_opt_sense.html">OptSense</a> <a class="el" href="classabacus_1_1_l_p.html#a7184374cd10742c38f26164757eacc2d">sense</a>, int <a class="el" href="classabacus_1_1_l_p.html#ab7da9ce19af761f5f802291b5074c5db">nRow</a>, int <a class="el" href="classabacus_1_1_l_p.html#a24baf164e9e3d2c88afc73ef3dfebdc2">maxRow</a>, int <a class="el" href="classabacus_1_1_l_p.html#a5fba2c3f47ba007afc672634c17e2293">nCol</a>, int <a class="el" href="classabacus_1_1_l_p.html#ae40937f14564d39f0765048361095523">maxCol</a>, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;<a class="el" href="classabacus_1_1_l_p.html#ab625238c8ec36fe47f6c1ff9330fce4d">obj</a>, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;<a class="el" href="classabacus_1_1_l_p.html#a6602176eee0665ce5f79e73c6dfe0df1">lBound</a>, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;<a class="el" href="classabacus_1_1_l_p.html#aaa2333a128e0a3eb5429e180e1f1be52">uBound</a>, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_row.html">Row</a> *&gt; &amp;rows)=0</td></tr>
<tr class="memdesc:abacc389579d42c4cd14297ca91aa0c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#abacc389579d42c4cd14297ca91aa0c48" title="The pure virtual function _initialize() must be defined by the used LP-solver and should initialize t...">_initialize()</a></em> must be defined by the used LP-solver and should initialize the LP-solver with.  <a href="#abacc389579d42c4cd14297ca91aa0c48">More...</a><br /></td></tr>
<tr class="separator:abacc389579d42c4cd14297ca91aa0c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91c80d913b085c3be5af835c96520a0"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ab91c80d913b085c3be5af835c96520a0">_lBound</a> (int i) const =0</td></tr>
<tr class="memdesc:ab91c80d913b085c3be5af835c96520a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#ab91c80d913b085c3be5af835c96520a0" title="The pure virtual function _lBound() must be defined by the used LP-solver and return the lower bound ...">_lBound()</a></em> must be defined by the used LP-solver and return the lower bound of variable <em>i</em>.  <a href="#ab91c80d913b085c3be5af835c96520a0">More...</a><br /></td></tr>
<tr class="separator:ab91c80d913b085c3be5af835c96520a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a31f0a99f9e492ca60eb5a3ce55ef4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a02a31f0a99f9e492ca60eb5a3ce55ef4">_loadBasis</a> (<a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_l_p_v_a_r_s_t_a_t.html#a26136feb2521120a7c71e02e830af809">LPVARSTAT::STATUS</a> &gt; &amp;<a class="el" href="classabacus_1_1_l_p.html#a1b44feb09201b79fc0b6ba8c8807fb9b">lpVarStat</a>, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_slack_stat.html#a7aaac2c567af8d69a233ee04b7dc0bcb">SlackStat::STATUS</a> &gt; &amp;<a class="el" href="classabacus_1_1_l_p.html#a80cc53d882e8ec9a068b448e323f8601">slackStat</a>)=0</td></tr>
<tr class="memdesc:a02a31f0a99f9e492ca60eb5a3ce55ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pure virtual function should load a basis into the LP-solver.  <a href="#a02a31f0a99f9e492ca60eb5a3ce55ef4">More...</a><br /></td></tr>
<tr class="separator:a02a31f0a99f9e492ca60eb5a3ce55ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70652f1ddccc3c9fa9c75e9bbc58ea94"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classabacus_1_1_l_p_v_a_r_s_t_a_t.html#a26136feb2521120a7c71e02e830af809">LPVARSTAT::STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a70652f1ddccc3c9fa9c75e9bbc58ea94">_lpVarStat</a> (int i) const =0</td></tr>
<tr class="memdesc:a70652f1ddccc3c9fa9c75e9bbc58ea94"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a70652f1ddccc3c9fa9c75e9bbc58ea94" title="The pure virtual function _lpVarStat() must be defined by the used LP-solver and should return the st...">_lpVarStat()</a></em> must be defined by the used LP-solver and should return the status of the variable <em>i</em> in the LP-solution.  <a href="#a70652f1ddccc3c9fa9c75e9bbc58ea94">More...</a><br /></td></tr>
<tr class="separator:a70652f1ddccc3c9fa9c75e9bbc58ea94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d49b2b20bd820cbde5d17e969f6e7b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ab1d49b2b20bd820cbde5d17e969f6e7b">_maxCol</a> () const =0</td></tr>
<tr class="memdesc:ab1d49b2b20bd820cbde5d17e969f6e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#ab1d49b2b20bd820cbde5d17e969f6e7b" title="The pure virtual function _maxCol() must be defined by the the used LP-solver and return the maximal ...">_maxCol()</a></em> must be defined by the the used LP-solver and return the maximal number of columns.  <a href="#ab1d49b2b20bd820cbde5d17e969f6e7b">More...</a><br /></td></tr>
<tr class="separator:ab1d49b2b20bd820cbde5d17e969f6e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607e065f36b9ef50b0fdae61d5c91e25"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a607e065f36b9ef50b0fdae61d5c91e25">_maxRow</a> () const =0</td></tr>
<tr class="memdesc:a607e065f36b9ef50b0fdae61d5c91e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a607e065f36b9ef50b0fdae61d5c91e25" title="The pure virtual function _maxRow() must be defined by the used LP-solver and return the maximal numb...">_maxRow()</a></em> must be defined by the used LP-solver and return the maximal number of rows.  <a href="#a607e065f36b9ef50b0fdae61d5c91e25">More...</a><br /></td></tr>
<tr class="separator:a607e065f36b9ef50b0fdae61d5c91e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f64460fc0744a935b97e446908e32f8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a2f64460fc0744a935b97e446908e32f8">_nCol</a> () const =0</td></tr>
<tr class="memdesc:a2f64460fc0744a935b97e446908e32f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a2f64460fc0744a935b97e446908e32f8" title="The pure virtual function _nCol() must be defined by the used LP-solver and return the number of colu...">_nCol()</a></em> must be defined by the used LP-solver and return the number of columns.  <a href="#a2f64460fc0744a935b97e446908e32f8">More...</a><br /></td></tr>
<tr class="separator:a2f64460fc0744a935b97e446908e32f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c38437e0e2ee6fdc0dedf309b1114b3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a6c38437e0e2ee6fdc0dedf309b1114b3">_nnz</a> () const =0</td></tr>
<tr class="memdesc:a6c38437e0e2ee6fdc0dedf309b1114b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a6c38437e0e2ee6fdc0dedf309b1114b3" title="The pure virtual function _nnz() must be defined by the used LP-solver and return the number of nonze...">_nnz()</a></em> must be defined by the used LP-solver and return the number of nonzero elements of the constraint matrix not including the right hand side and the bounds of the variables.  <a href="#a6c38437e0e2ee6fdc0dedf309b1114b3">More...</a><br /></td></tr>
<tr class="separator:a6c38437e0e2ee6fdc0dedf309b1114b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad874de501e118f3e00b7ebf4393d8836"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ad874de501e118f3e00b7ebf4393d8836">_nRow</a> () const =0</td></tr>
<tr class="memdesc:ad874de501e118f3e00b7ebf4393d8836"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#ad874de501e118f3e00b7ebf4393d8836" title="The pure virtual function _nRow() must be defined by the used LP-solver and return the number of rows...">_nRow()</a></em> must be defined by the used LP-solver and return the number of rows of the problem.  <a href="#ad874de501e118f3e00b7ebf4393d8836">More...</a><br /></td></tr>
<tr class="separator:ad874de501e118f3e00b7ebf4393d8836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754dffa1c2f1dd53ac2819edf6ed0f67"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a754dffa1c2f1dd53ac2819edf6ed0f67">_obj</a> (int i) const =0</td></tr>
<tr class="memdesc:a754dffa1c2f1dd53ac2819edf6ed0f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a754dffa1c2f1dd53ac2819edf6ed0f67" title="The pure virtual function _obj() must be defined by the used LP-solver and return the objective funct...">_obj()</a></em> must be defined by the used LP-solver and return the objective function coefficient of variable <em>i</em>.  <a href="#a754dffa1c2f1dd53ac2819edf6ed0f67">More...</a><br /></td></tr>
<tr class="separator:a754dffa1c2f1dd53ac2819edf6ed0f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dadb9e79b93029db3181eab931d2b0d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a8dadb9e79b93029db3181eab931d2b0d">_pivotSlackVariableIn</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;rows)=0</td></tr>
<tr class="memdesc:a8dadb9e79b93029db3181eab931d2b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function <em><a class="el" href="classabacus_1_1_l_p.html#a0f7d31b7e6ec21b482c58ebbd7490fa1" title="Pivots the slack variables stored in the buffer rows into the basis. ">pivotSlackVariableIn()</a></em> pivots the slack variables stored in the buffer <em>rows</em> into the basis.  <a href="#a8dadb9e79b93029db3181eab931d2b0d">More...</a><br /></td></tr>
<tr class="separator:a8dadb9e79b93029db3181eab931d2b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e7b008ff9addd031b9147762e4142f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dce">OPTSTAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a04e7b008ff9addd031b9147762e4142f">_primalSimplex</a> ()=0</td></tr>
<tr class="memdesc:a04e7b008ff9addd031b9147762e4142f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a04e7b008ff9addd031b9147762e4142f" title="The pure virtual function _primalSimplex() must be defined by the used LP-solver and should call the ...">_primalSimplex()</a></em> must be defined by the used LP-solver and should call the primal simplex method of the used LP-solver.  <a href="#a04e7b008ff9addd031b9147762e4142f">More...</a><br /></td></tr>
<tr class="separator:a04e7b008ff9addd031b9147762e4142f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3e2058b7af5031059975c488ff5903"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a3f3e2058b7af5031059975c488ff5903">_reco</a> (int i) const =0</td></tr>
<tr class="memdesc:a3f3e2058b7af5031059975c488ff5903"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a3f3e2058b7af5031059975c488ff5903" title="The pure virtual function _reco() must be defined by the used LP-solver and should return the reduced...">_reco()</a></em> must be defined by the used LP-solver and should return the reduced cost of variable <em>i</em>.  <a href="#a3f3e2058b7af5031059975c488ff5903">More...</a><br /></td></tr>
<tr class="separator:a3f3e2058b7af5031059975c488ff5903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c36aaca7768fb55624ef77275044a31"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a4c36aaca7768fb55624ef77275044a31">_remCols</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;vars)=0</td></tr>
<tr class="memdesc:a4c36aaca7768fb55624ef77275044a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a4c36aaca7768fb55624ef77275044a31" title="The pure virtual function _remCols() must be defined by the used LP-solver and should remove the colu...">_remCols()</a></em> must be defined by the used LP-solver and should remove the columns with numbers given in <em>vars</em> from the <a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a>.  <a href="#a4c36aaca7768fb55624ef77275044a31">More...</a><br /></td></tr>
<tr class="separator:a4c36aaca7768fb55624ef77275044a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8467dbb4deb2d00d04466fec3644ccd0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a8467dbb4deb2d00d04466fec3644ccd0">_remRows</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;ind)=0</td></tr>
<tr class="memdesc:a8467dbb4deb2d00d04466fec3644ccd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a8467dbb4deb2d00d04466fec3644ccd0" title="The pure virtual function _remRows() must be defined by the used LP-solver and should remove the rows...">_remRows()</a></em> must be defined by the used LP-solver and should remove the rows with numbers given in the buffer <em>ind</em> from the LP-solver.  <a href="#a8467dbb4deb2d00d04466fec3644ccd0">More...</a><br /></td></tr>
<tr class="separator:a8467dbb4deb2d00d04466fec3644ccd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d21fa7fe7b0d290b20dd04a7ee7ee9c"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a4d21fa7fe7b0d290b20dd04a7ee7ee9c">_rhs</a> (int i) const =0</td></tr>
<tr class="memdesc:a4d21fa7fe7b0d290b20dd04a7ee7ee9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a4d21fa7fe7b0d290b20dd04a7ee7ee9c" title="The pure virtual function _rhs() must be defined by the used LP-solver and return the right hand side...">_rhs()</a></em> must be defined by the used LP-solver and return the right hand side of constraint <em>i</em>.  <a href="#a4d21fa7fe7b0d290b20dd04a7ee7ee9c">More...</a><br /></td></tr>
<tr class="separator:a4d21fa7fe7b0d290b20dd04a7ee7ee9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c713bdee5a93f8c6b4f6b689fdf71fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a8c713bdee5a93f8c6b4f6b689fdf71fc">_row</a> (int i, <a class="el" href="classabacus_1_1_row.html">Row</a> &amp;r) const =0</td></tr>
<tr class="memdesc:a8c713bdee5a93f8c6b4f6b689fdf71fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a8c713bdee5a93f8c6b4f6b689fdf71fc" title="The pure virtual function _row() must be defined by the used LP-solver and store the i-th row of the ...">_row()</a></em> must be defined by the used LP-solver and store the <em>i-th</em> row of the problem in the row <em>r</em>.  <a href="#a8c713bdee5a93f8c6b4f6b689fdf71fc">More...</a><br /></td></tr>
<tr class="separator:a8c713bdee5a93f8c6b4f6b689fdf71fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4c6243ee546bfdcbf6f04bfddf1cfe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#adc4c6243ee546bfdcbf6f04bfddf1cfe">_rowRealloc</a> (int newSize)=0</td></tr>
<tr class="memdesc:adc4c6243ee546bfdcbf6f04bfddf1cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#adc4c6243ee546bfdcbf6f04bfddf1cfe" title="The pure virtual function _rowRealloc() must be defined in the used LP-solver and should reallocate i...">_rowRealloc()</a></em> must be defined in the used LP-solver and should reallocate its memory such that up to <em>newSize</em> rows can be handled.  <a href="#adc4c6243ee546bfdcbf6f04bfddf1cfe">More...</a><br /></td></tr>
<tr class="separator:adc4c6243ee546bfdcbf6f04bfddf1cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcc99aae7fe8ae61a880d46f31b1b81"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classabacus_1_1_opt_sense.html">OptSense</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#aabcc99aae7fe8ae61a880d46f31b1b81">_sense</a> () const =0</td></tr>
<tr class="memdesc:aabcc99aae7fe8ae61a880d46f31b1b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#aabcc99aae7fe8ae61a880d46f31b1b81" title="The pure virtual function _sense() must be defined by the used LP-solver and return the sense of the ...">_sense()</a></em> must be defined by the used LP-solver and return the sense of the optimization.  <a href="#aabcc99aae7fe8ae61a880d46f31b1b81">More...</a><br /></td></tr>
<tr class="separator:aabcc99aae7fe8ae61a880d46f31b1b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1eb6463c435da25e0399191bf718827"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ac1eb6463c435da25e0399191bf718827">_sense</a> (const <a class="el" href="classabacus_1_1_opt_sense.html">OptSense</a> &amp;newSense)=0</td></tr>
<tr class="separator:ac1eb6463c435da25e0399191bf718827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d455b0d4d3795a0ca1acfeaf3b4d64"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a07d455b0d4d3795a0ca1acfeaf3b4d64">_setSimplexIterationLimit</a> (int limit)=0</td></tr>
<tr class="memdesc:a07d455b0d4d3795a0ca1acfeaf3b4d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function <em><a class="el" href="classabacus_1_1_l_p.html#ad1eba72e8f92680cad57e8fc6999f2dc" title="Changes the iteration limit of the Simplex algorithm. ">setSimplexIterationLimit()</a></em> changes the iteration limit of the Simplex algorithm.  <a href="#a07d455b0d4d3795a0ca1acfeaf3b4d64">More...</a><br /></td></tr>
<tr class="separator:a07d455b0d4d3795a0ca1acfeaf3b4d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78366d982204f8cedbb324042ecd3341"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a78366d982204f8cedbb324042ecd3341">_slack</a> (int i) const =0</td></tr>
<tr class="memdesc:a78366d982204f8cedbb324042ecd3341"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a78366d982204f8cedbb324042ecd3341" title="The pure virtual function _slack() must be defined by the used LP-solver and should return the value ...">_slack()</a></em> must be defined by the used LP-solver and should return the value of the slack variable <em>i</em>.  <a href="#a78366d982204f8cedbb324042ecd3341">More...</a><br /></td></tr>
<tr class="separator:a78366d982204f8cedbb324042ecd3341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b998e9d1e98bfdc507767547f46a63"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classabacus_1_1_slack_stat.html#a7aaac2c567af8d69a233ee04b7dc0bcb">SlackStat::STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#af5b998e9d1e98bfdc507767547f46a63">_slackStat</a> (int i) const =0</td></tr>
<tr class="memdesc:af5b998e9d1e98bfdc507767547f46a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#af5b998e9d1e98bfdc507767547f46a63" title="The pure virtual function _slackStat() must be defined by the used LP-solver and should return the st...">_slackStat()</a></em> must be defined by the used LP-solver and should return the status of the slack variable <em>i</em> in the LP-solution.  <a href="#af5b998e9d1e98bfdc507767547f46a63">More...</a><br /></td></tr>
<tr class="separator:af5b998e9d1e98bfdc507767547f46a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34df605cd972d993a830b79c18e007a"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ad34df605cd972d993a830b79c18e007a">_uBound</a> (int i) const =0</td></tr>
<tr class="memdesc:ad34df605cd972d993a830b79c18e007a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#ad34df605cd972d993a830b79c18e007a" title="The pure virtual function _uBound() must be defined by the used LP-solver and return the upper bound ...">_uBound()</a></em> must be defined by the used LP-solver and return the upper bound of variable <em>i</em>.  <a href="#ad34df605cd972d993a830b79c18e007a">More...</a><br /></td></tr>
<tr class="separator:ad34df605cd972d993a830b79c18e007a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146c75a6b63bc0e41e0f5cea136124f6"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a146c75a6b63bc0e41e0f5cea136124f6">_value</a> () const =0</td></tr>
<tr class="memdesc:a146c75a6b63bc0e41e0f5cea136124f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a146c75a6b63bc0e41e0f5cea136124f6" title="The pure virtual function _value() must be defined by the used LP-solver and should return the optimu...">_value()</a></em> must be defined by the used LP-solver and should return the optimum value of the linear program after it has been solved.  <a href="#a146c75a6b63bc0e41e0f5cea136124f6">More...</a><br /></td></tr>
<tr class="separator:a146c75a6b63bc0e41e0f5cea136124f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3066f3da3599f74ed22c41a692b6b969"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a3066f3da3599f74ed22c41a692b6b969">_xVal</a> (int i) const =0</td></tr>
<tr class="memdesc:a3066f3da3599f74ed22c41a692b6b969"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a3066f3da3599f74ed22c41a692b6b969" title="The pure virtual function _xVal() must be defined by the used LP-solver and should return the value o...">_xVal()</a></em> must be defined by the used LP-solver and should return the value of variable <em>i</em> in the LP-solution.  <a href="#a3066f3da3599f74ed22c41a692b6b969">More...</a><br /></td></tr>
<tr class="separator:a3066f3da3599f74ed22c41a692b6b969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cd15eeb0a377bee7884f8776237fb4"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a62cd15eeb0a377bee7884f8776237fb4">_yVal</a> (int i) const =0</td></tr>
<tr class="memdesc:a62cd15eeb0a377bee7884f8776237fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a62cd15eeb0a377bee7884f8776237fb4" title="The pure virtual function _yVal() must be defined by the used LP-solver and should return the value o...">_yVal()</a></em> must be defined by the used LP-solver and should return the value of the dual variable of the constraint <em>i</em>.  <a href="#a62cd15eeb0a377bee7884f8776237fb4">More...</a><br /></td></tr>
<tr class="separator:a62cd15eeb0a377bee7884f8776237fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7888959f2e3ec7c9680985d9eccbe9ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a7888959f2e3ec7c9680985d9eccbe9ec">colRangeCheck</a> (int i) const</td></tr>
<tr class="memdesc:a7888959f2e3ec7c9680985d9eccbe9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates the program if there is no column with index <em>i</em>.  <a href="#a7888959f2e3ec7c9680985d9eccbe9ec">More...</a><br /></td></tr>
<tr class="separator:a7888959f2e3ec7c9680985d9eccbe9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ea843da891327307073ac26e18a0a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a58ea843da891327307073ac26e18a0a0">colsNnz</a> (int <a class="el" href="classabacus_1_1_l_p.html#ab7da9ce19af761f5f802291b5074c5db">nRow</a>, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_row.html">Row</a> *&gt; &amp;rows, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; int &gt; &amp;<a class="el" href="classabacus_1_1_l_p.html#a17bdc5cf22e0c52452c793bf32dd9b9d">nnz</a>)</td></tr>
<tr class="memdesc:a58ea843da891327307073ac26e18a0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of nonzero elements in each column of a given set of rows.  <a href="#a58ea843da891327307073ac26e18a0a0">More...</a><br /></td></tr>
<tr class="separator:a58ea843da891327307073ac26e18a0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ca0aa1f3f77f98da42b772562b258a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#ad4ca0aa1f3f77f98da42b772562b258a">rowRangeCheck</a> (int r) const</td></tr>
<tr class="memdesc:ad4ca0aa1f3f77f98da42b772562b258a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates the program if there is no row with index <em>r</em>.  <a href="#ad4ca0aa1f3f77f98da42b772562b258a">More...</a><br /></td></tr>
<tr class="separator:ad4ca0aa1f3f77f98da42b772562b258a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887c43776e1f97b1967df33e8e7bb266"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a887c43776e1f97b1967df33e8e7bb266">rows2cols</a> (int <a class="el" href="classabacus_1_1_l_p.html#ab7da9ce19af761f5f802291b5074c5db">nRow</a>, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_row.html">Row</a> *&gt; &amp;rows, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_spar_vec.html">SparVec</a> *&gt; &amp;cols)</td></tr>
<tr class="memdesc:a887c43776e1f97b1967df33e8e7bb266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the columnwise representation of the row matrix.  <a href="#a887c43776e1f97b1967df33e8e7bb266">More...</a><br /></td></tr>
<tr class="separator:a887c43776e1f97b1967df33e8e7bb266"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a5d86eadb5cddccea373404a6170e7400"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a5d86eadb5cddccea373404a6170e7400">barXValStatus_</a></td></tr>
<tr class="separator:a5d86eadb5cddccea373404a6170e7400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ab24d983cd17a0850e37727e782960"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a65ab24d983cd17a0850e37727e782960">basisStatus_</a></td></tr>
<tr class="memdesc:a65ab24d983cd17a0850e37727e782960"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member becomes <em>Available</em> if the status of the variables and the slack variables of the optimal solution can be accessed with the functions <em><a class="el" href="classabacus_1_1_l_p.html#a1b44feb09201b79fc0b6ba8c8807fb9b">lpVarStat()</a></em> and <em><a class="el" href="classabacus_1_1_l_p.html#a80cc53d882e8ec9a068b448e323f8601">slackStat()</a></em>, otherwise it has the value <em>Missing</em>.  <a href="#a65ab24d983cd17a0850e37727e782960">More...</a><br /></td></tr>
<tr class="separator:a65ab24d983cd17a0850e37727e782960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb2493b8dab9def91778033dd36c14b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_stopwatch_c_p_u.html">ogdf::StopwatchCPU</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#aacb2493b8dab9def91778033dd36c14b">lpSolverTime_</a></td></tr>
<tr class="separator:aacb2493b8dab9def91778033dd36c14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18da23ceeb50d5f17f1d04a9441cb551"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_master.html">Master</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a18da23ceeb50d5f17f1d04a9441cb551">master_</a></td></tr>
<tr class="memdesc:a18da23ceeb50d5f17f1d04a9441cb551"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the corresponding master of the optimization.  <a href="#a18da23ceeb50d5f17f1d04a9441cb551">More...</a><br /></td></tr>
<tr class="separator:a18da23ceeb50d5f17f1d04a9441cb551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0cf4cfc09702c69a79d945cc36902a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a9e0cf4cfc09702c69a79d945cc36902a">nOpt_</a></td></tr>
<tr class="memdesc:a9e0cf4cfc09702c69a79d945cc36902a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of optimizations of the linear program.  <a href="#a9e0cf4cfc09702c69a79d945cc36902a">More...</a><br /></td></tr>
<tr class="separator:a9e0cf4cfc09702c69a79d945cc36902a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551c42baea74b8261b0cca552cf1df3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dce">OPTSTAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a551c42baea74b8261b0cca552cf1df3e">optStat_</a></td></tr>
<tr class="memdesc:a551c42baea74b8261b0cca552cf1df3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The status of the linear program.  <a href="#a551c42baea74b8261b0cca552cf1df3e">More...</a><br /></td></tr>
<tr class="separator:a551c42baea74b8261b0cca552cf1df3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f36c2e95234964193450a852ef0b534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a6f36c2e95234964193450a852ef0b534">recoStatus_</a></td></tr>
<tr class="memdesc:a6f36c2e95234964193450a852ef0b534"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member becomes <em>Available</em> if the reduced costs of the optimal solution can be accessed with the function <em><a class="el" href="classabacus_1_1_l_p.html#a5554da2bde032986bd1d7956a5ff3194">reco()</a></em>, otherwise it has the value <em>Missing</em>.  <a href="#a6f36c2e95234964193450a852ef0b534">More...</a><br /></td></tr>
<tr class="separator:a6f36c2e95234964193450a852ef0b534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10f78dc7360d8d4fc2eb1f93e805d0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#aa10f78dc7360d8d4fc2eb1f93e805d0e">slackStatus_</a></td></tr>
<tr class="memdesc:aa10f78dc7360d8d4fc2eb1f93e805d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member becomes <em>Available</em> if the values of the slack variables of the optimal solution can be accessed with the function <em><a class="el" href="classabacus_1_1_l_p.html#a7181ea4803725e79e4c7c585f61fe666">slack()</a></em>, otherwise it has the value <em>Missing</em>.  <a href="#aa10f78dc7360d8d4fc2eb1f93e805d0e">More...</a><br /></td></tr>
<tr class="separator:aa10f78dc7360d8d4fc2eb1f93e805d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5950d2b910e737a241ef57c7bd07ce45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a5950d2b910e737a241ef57c7bd07ce45">xValStatus_</a></td></tr>
<tr class="memdesc:a5950d2b910e737a241ef57c7bd07ce45"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member becomes <em>Available</em> if the \(x\)-values of the optimal solution can be accessed with the function <em><a class="el" href="classabacus_1_1_l_p.html#a4850f2f08186f8bd36ac2cfdc6149eb9">xVal()</a></em>, otherwise it has the value <em>Missing</em>.  <a href="#a5950d2b910e737a241ef57c7bd07ce45">More...</a><br /></td></tr>
<tr class="separator:a5950d2b910e737a241ef57c7bd07ce45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4523f575b6a8c919d80824e85a093dcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a4523f575b6a8c919d80824e85a093dcd">yValStatus_</a></td></tr>
<tr class="memdesc:a4523f575b6a8c919d80824e85a093dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member becomes <em>Available</em> if the values of the dual variables of the optimal solution can be accessed with the function <em><a class="el" href="classabacus_1_1_l_p.html#a6a561cec2e45a9eee87627e0891bda18">yVal()</a></em>, otherwise it has the value <em>Missing/</em>.  <a href="#a4523f575b6a8c919d80824e85a093dcd">More...</a><br /></td></tr>
<tr class="separator:a4523f575b6a8c919d80824e85a093dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a39a2a05ef552170288e1a2a2f3371985"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a39a2a05ef552170288e1a2a2f3371985">LP</a> (const <a class="el" href="classabacus_1_1_l_p.html">LP</a> &amp;<a class="el" href="classabacus_1_1_l_p.html#a17faeb4b7f9e400cdf8367b718d3de0e">rhs</a>)</td></tr>
<tr class="separator:a39a2a05ef552170288e1a2a2f3371985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9559abdfbdbd45066d76250895c256"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a0a9559abdfbdbd45066d76250895c256">initPostOpt</a> ()</td></tr>
<tr class="memdesc:a0a9559abdfbdbd45066d76250895c256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the optimization status and the availability statuses of the solution.  <a href="#a0a9559abdfbdbd45066d76250895c256">More...</a><br /></td></tr>
<tr class="separator:a0a9559abdfbdbd45066d76250895c256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d04a6937dc854fa03e518aa0f5f380"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classabacus_1_1_l_p.html">LP</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#a51d04a6937dc854fa03e518aa0f5f380">operator=</a> (const <a class="el" href="classabacus_1_1_l_p.html">LP</a> &amp;<a class="el" href="classabacus_1_1_l_p.html#a17faeb4b7f9e400cdf8367b718d3de0e">rhs</a>)</td></tr>
<tr class="separator:a51d04a6937dc854fa03e518aa0f5f380"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:affd271e58e45d6dc3e650e0854767654"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_l_p.html#affd271e58e45d6dc3e650e0854767654">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classabacus_1_1_l_p.html">LP</a> &amp;<a class="el" href="classabacus_1_1_l_p.html#a17faeb4b7f9e400cdf8367b718d3de0e">rhs</a>)</td></tr>
<tr class="memdesc:affd271e58e45d6dc3e650e0854767654"><td class="mdescLeft">&#160;</td><td class="mdescRight">The output operator writes the objective function, followed by the constraints, the bounds on the columns and the solution values (if available) to an output stream.  <a href="#affd271e58e45d6dc3e650e0854767654">More...</a><br /></td></tr>
<tr class="separator:affd271e58e45d6dc3e650e0854767654"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classabacus_1_1_abacus_root"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classabacus_1_1_abacus_root')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classabacus_1_1_abacus_root.html">abacus::AbacusRoot</a></td></tr>
<tr class="memitem:a28a9cfb3b9a4cd4990c046581f9bbd78 inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_abacus_root.html#a28a9cfb3b9a4cd4990c046581f9bbd78">ascii2bool</a> (const string &amp;str)</td></tr>
<tr class="memdesc:a28a9cfb3b9a4cd4990c046581f9bbd78 inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the string <em>str</em> to a boolean value.  <a href="classabacus_1_1_abacus_root.html#a28a9cfb3b9a4cd4990c046581f9bbd78">More...</a><br /></td></tr>
<tr class="separator:a28a9cfb3b9a4cd4990c046581f9bbd78 inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b9fba6fabf13294e0af48534ae40ff inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_abacus_root.html#a13b9fba6fabf13294e0af48534ae40ff">endsWith</a> (const string &amp;str, const string &amp;end)</td></tr>
<tr class="memdesc:a13b9fba6fabf13294e0af48534ae40ff inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <em>str</em> ends with <em>end</em>, false otherwise.  <a href="classabacus_1_1_abacus_root.html#a13b9fba6fabf13294e0af48534ae40ff">More...</a><br /></td></tr>
<tr class="separator:a13b9fba6fabf13294e0af48534ae40ff inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa15fbdee10063826f95e9bba642f2bd inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_abacus_root.html#afa15fbdee10063826f95e9bba642f2bd">fracPart</a> (double x)</td></tr>
<tr class="memdesc:afa15fbdee10063826f95e9bba642f2bd inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of the fractional part of <em>x</em>.  <a href="classabacus_1_1_abacus_root.html#afa15fbdee10063826f95e9bba642f2bd">More...</a><br /></td></tr>
<tr class="separator:afa15fbdee10063826f95e9bba642f2bd inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2eda31050d9b9a135a55fce76a7aedd inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_abacus_root.html#af2eda31050d9b9a135a55fce76a7aedd">onOff</a> (bool value)</td></tr>
<tr class="memdesc:af2eda31050d9b9a135a55fce76a7aedd inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a boolean variable to the strings <em>"on"</em> and <em>"off"</em>.  <a href="classabacus_1_1_abacus_root.html#af2eda31050d9b9a135a55fce76a7aedd">More...</a><br /></td></tr>
<tr class="separator:af2eda31050d9b9a135a55fce76a7aedd inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Linear programs. </p>
<p>The following section provides a generic interface class to linear programs, from which we will derive further classes both for the solution of LP-relaxations (<a class="el" href="classabacus_1_1_lp_sub.html" title="The linear program of a subproblem. ">LpSub</a>) with a linear-programming based branch-and-bound algorithm and for interfaces to LP-solvers (<a class="el" href="classabacus_1_1_osi_i_f.html">OsiIF</a>).</p>
<p>The framework should be very flexible in the use of different LP-solvers. Therefore, we implement in the class <a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a> a very general interface to the linear program. All functions of the framework communicate with the linear program only by the public functions of the class <a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a>.</p>
<p>The public functions call pure virtual functions starting with the prefix <em>_</em>, which have to be implemented in the derived class for each specific LP-solver.</p>
<p>Linear programs cannot only be used for solving the LP-relaxation within the branch-and-cut algorithm. There are also techniques in integer programming where linear programming is used for generating cutting planes and for applying heuristics. Therefore, we design the class <a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a> that it can be used very generally. </p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00070">70</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a80d390b461dca15f5aba8068995b0063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d390b461dca15f5aba8068995b0063">&sect;&nbsp;</a></span>METHOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classabacus_1_1_l_p.html#a80d390b461dca15f5aba8068995b0063">abacus::LP::METHOD</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The solution method for the linear program. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a80d390b461dca15f5aba8068995b0063aa779fe3c73e5abb3006ea218b88fc649"></a>Primal&#160;</td><td class="fielddoc"><p>The primal simplex method. </p>
</td></tr>
<tr><td class="fieldname"><a id="a80d390b461dca15f5aba8068995b0063a140644b022296cc7d1819e98abe0897e"></a>Dual&#160;</td><td class="fielddoc"><p>The dual simplex method. </p>
</td></tr>
<tr><td class="fieldname"><a id="a80d390b461dca15f5aba8068995b0063a712cbbde8ba9412aeaee7d118efff5b6"></a>BarrierAndCrossover&#160;</td><td class="fielddoc"><p>The barrier method followed by a crossover to a basis. </p>
</td></tr>
<tr><td class="fieldname"><a id="a80d390b461dca15f5aba8068995b0063a91891705b80b35ba7c112403735b2b0e"></a>BarrierNoCrossover&#160;</td><td class="fielddoc"><p>The barrier method without crossover. </p>
</td></tr>
<tr><td class="fieldname"><a id="a80d390b461dca15f5aba8068995b0063af072e7bd770b14bda45848638e26d575"></a>Approximate&#160;</td><td class="fielddoc"><p>An approximative solver. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00093">93</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a395bcfe1e844ad315ef7751c2ecc7dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395bcfe1e844ad315ef7751c2ecc7dce">&sect;&nbsp;</a></span>OPTSTAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dce">abacus::LP::OPTSTAT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The optimization status of the linear program. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a395bcfe1e844ad315ef7751c2ecc7dcea938ec3a6a577b393131776cf38fb58f8"></a>Optimal&#160;</td><td class="fielddoc"><p>The optimal solution has been computed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a395bcfe1e844ad315ef7751c2ecc7dcea2fbbc93edd9cad3ccbccbd3ca3c76a10"></a>Unoptimized&#160;</td><td class="fielddoc"><p>Unoptimized Optimization is still required, this is also the case for reoptimization. </p>
</td></tr>
<tr><td class="fieldname"><a id="a395bcfe1e844ad315ef7751c2ecc7dceac84a5243eaab09120e0c3507ac6055f2"></a>Error&#160;</td><td class="fielddoc"><p>An error has happened during optimization. </p>
</td></tr>
<tr><td class="fieldname"><a id="a395bcfe1e844ad315ef7751c2ecc7dcea05391eac30b1538c8e6068353cd71624"></a>Feasible&#160;</td><td class="fielddoc"><p>A primal feasible solution for the linear program, but not the optimal solution has been found. </p>
</td></tr>
<tr><td class="fieldname"><a id="a395bcfe1e844ad315ef7751c2ecc7dcea9d816f40986df5ce23605be3cf48dd4d"></a>Infeasible&#160;</td><td class="fielddoc"><p>The linear program is primal infeasible. </p>
</td></tr>
<tr><td class="fieldname"><a id="a395bcfe1e844ad315ef7751c2ecc7dceaaede2940973aaedafefe5dc4ce66d2b6"></a>Unbounded&#160;</td><td class="fielddoc"><p>The linear program is unbounded. </p>
</td></tr>
<tr><td class="fieldname"><a id="a395bcfe1e844ad315ef7751c2ecc7dcea0d254d6f1d870756a1a21a786a699639"></a>LimitReached&#160;</td><td class="fielddoc"><p>The iteration limit was reached while optimizing. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00074">74</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="ad3412c25dc5258be2d6a6336c364693b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3412c25dc5258be2d6a6336c364693b">&sect;&nbsp;</a></span>SOLSTAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">abacus::LP::SOLSTAT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes if parts of the solution like x-values, reduced costs, etc. are available. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad3412c25dc5258be2d6a6336c364693bae1d8d4a84a6f95cdbd26127b0cb2d091"></a>Available&#160;</td><td class="fielddoc"><p>The part of the solution is available. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3412c25dc5258be2d6a6336c364693baae5256fcee8d4e973b9fdb062051261d"></a>Missing&#160;</td><td class="fielddoc"><p>Missing The part of the solution is missing. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00087">87</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a88c9fecae5520857eeafc75f355e96fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c9fecae5520857eeafc75f355e96fc">&sect;&nbsp;</a></span>LP() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abacus::LP::LP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_master.html">Master</a> *&#160;</td>
          <td class="paramname"><em>master</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a linear program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">master</td><td>A pointer to the corresponding master of the optimization. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00105">105</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="aad96ee883633635f03b6998846fe6a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad96ee883633635f03b6998846fe6a67">&sect;&nbsp;</a></span>~LP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual abacus::LP::~LP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The destructor. </p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00118">118</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a39a2a05ef552170288e1a2a2f3371985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a2a05ef552170288e1a2a2f3371985">&sect;&nbsp;</a></span>LP() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abacus::LP::LP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classabacus_1_1_l_p.html">LP</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5a790a5d32c5f3683ed6a0aae9fc8aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a790a5d32c5f3683ed6a0aae9fc8aad">&sect;&nbsp;</a></span>_addCols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::LP::_addCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_column.html">Column</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>newCols</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a5a790a5d32c5f3683ed6a0aae9fc8aad" title="The pure virtual function _addCols() must be defined by the used LP-solver and should add the columns...">_addCols()</a></em> must be defined by the used LP-solver and should add the columns <em>newCols</em> to the <a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a>. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#ab2e0f3193f18ea2c2467c6181224c80e">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a811a81248bfa09a441ea28de823f2b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811a81248bfa09a441ea28de823f2b66">&sect;&nbsp;</a></span>_addRows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::LP::_addRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_row.html">Row</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>newRows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a811a81248bfa09a441ea28de823f2b66" title="The pure virtual function _addRows() must be defined by the used LP-solver and should add the rows gi...">_addRows()</a></em> must be defined by the used LP-solver and should add the rows given in the buffer <em>newRows</em> to the <a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a>. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a981e328a9a7c4f66ddfc8247040a5155">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a4dcbbff20e1347b34dde590c8679a4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcbbff20e1347b34dde590c8679a4df">&sect;&nbsp;</a></span>_approx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dce">OPTSTAT</a> abacus::LP::_approx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a4dcbbff20e1347b34dde590c8679a4df" title="The pure virtual function _approx() must be defined by the used LP-solver and should call the approxi...">_approx()</a></em> must be defined by the used LP-solver and should call the approximative method of the used LP-solver. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#acc29bac57ad18e8841d1ef05eb4c461e">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="aa91af637e3bc9f0f739864a3a96237b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91af637e3bc9f0f739864a3a96237b5">&sect;&nbsp;</a></span>_barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dce">OPTSTAT</a> abacus::LP::_barrier </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doCrossover</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#aa91af637e3bc9f0f739864a3a96237b5" title="The pure virtual function _barrier() must be defined by the used LP-solver and should call the barrie...">_barrier()</a></em> must be defined by the used LP-solver and should call the barrier method of the used LP-solver. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a6fd4e99675bff462f781968b1649e15c">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a75347fe85fbdf137512372b31b01f99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75347fe85fbdf137512372b31b01f99e">&sect;&nbsp;</a></span>_barXVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::LP::_barXVal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a45478fcc9d630e09d3951f004947623a">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="ae17a576eb3307b9961ddd185eb905cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17a576eb3307b9961ddd185eb905cfc">&sect;&nbsp;</a></span>_changeLBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::LP::_changeLBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>newLb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#ae17a576eb3307b9961ddd185eb905cfc" title="The pure virtual function _changeLBound() must be defined by the used LP-solver and should set the lo...">_changeLBound()</a></em> must be defined by the used LP-solver and should set the lower bound of variable <em>i</em> to <em>newLb</em>. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a4c65c7dfcdfa646bbff9f48bbb3cae70">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a293de2aed9a9dabd0a93bd12a292023d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293de2aed9a9dabd0a93bd12a292023d">&sect;&nbsp;</a></span>_changeRhs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::LP::_changeRhs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>newRhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a293de2aed9a9dabd0a93bd12a292023d" title="The pure virtual function _changeRhs() must be defined by the used LP-solver and should set the right...">_changeRhs()</a></em> must be defined by the used LP-solver and should set the right hand side of the constraint matrix of the <a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a> to <em>newRhs</em>. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a0a4f254b3a83c7c5f61b368cda78fa11">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="ab6926cb13e4ccc343bc60343e8f11739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6926cb13e4ccc343bc60343e8f11739">&sect;&nbsp;</a></span>_changeUBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::LP::_changeUBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>newUb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#ae17a576eb3307b9961ddd185eb905cfc" title="The pure virtual function _changeLBound() must be defined by the used LP-solver and should set the lo...">_changeLBound()</a></em> must be defined by the used LP-solver and should set the upper bound of variable <em>i</em> to <em>newUb</em>. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#ab48297c1f04b028f9ba6732de152d48d">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a70cbbacd5adb60c4fbb40dfc9d207a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70cbbacd5adb60c4fbb40dfc9d207a1d">&sect;&nbsp;</a></span>_colRealloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::LP::_colRealloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a70cbbacd5adb60c4fbb40dfc9d207a1d" title="The pure virtual function _colRealloc() must be defined by the used LP-solver and should reallocate i...">_colRealloc()</a></em> must be defined by the used LP-solver and should reallocate its memory such that up to <em>newSize</em> columns can be handled. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#acc756cc34a0da0b21c15e7e256f42946">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a77268ead1c5376d13ac6646b5ea48f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77268ead1c5376d13ac6646b5ea48f95">&sect;&nbsp;</a></span>_dualSimplex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dce">OPTSTAT</a> abacus::LP::_dualSimplex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a77268ead1c5376d13ac6646b5ea48f95" title="The pure virtual function _dualSimplex() must be defined by the used LP-solver and should call the du...">_dualSimplex()</a></em> must be defined by the used LP-solver and should call the dual simplex method of the used LP-solver. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#aae8511fbfafe12481409fd2fd6d0e105">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a00621477dcd3565de7765ed4e1b0699e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00621477dcd3565de7765ed4e1b0699e">&sect;&nbsp;</a></span>_getInfeas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::LP::_getInfeas </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>infeasRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>infeasCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>bInvRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a00621477dcd3565de7765ed4e1b0699e" title="The pure virtual function _getInfeas() must be defined by the used LP-solver and can be called if the...">_getInfeas()</a></em> must be defined by the used LP-solver and can be called if the last linear program has been solved with the dual simplex method and is infeasible. </p>
<p>In this case it should compute the infeasible basic variable or constraint and the corresponding row <em>bInvRow</em> of the basis inverse. Either <em>infeasRow</em> or <em>infeasCol</em> is nonnegative. The nonnegative argument is an infeasible row or column, respectively.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if it is successful </dd>
<dd>
1 otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a61f3cd0fbfe4c4cc02e02b542fcc7f89">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a3643db55c879004aacbbf661b303b993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3643db55c879004aacbbf661b303b993">&sect;&nbsp;</a></span>_getSimplexIterationLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::LP::_getSimplexIterationLimit </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function <em><a class="el" href="classabacus_1_1_l_p.html#ac2b76d347de6c4c4a1e9eadad21de62c">getSimplexIterationLimit()</a></em> retrieves the value of the iteration limit of the simplex algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>0 If the iteration limit could be get, </dd>
<dd>
1 otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>Stores the value of the iteration limit if the function returns 0. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a666976143a11334de84ee208ae7a44aa">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="abacc389579d42c4cd14297ca91aa0c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abacc389579d42c4cd14297ca91aa0c48">&sect;&nbsp;</a></span>_initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::LP::_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_opt_sense.html">OptSense</a>&#160;</td>
          <td class="paramname"><em>sense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>lBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>uBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_row.html">Row</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#abacc389579d42c4cd14297ca91aa0c48" title="The pure virtual function _initialize() must be defined by the used LP-solver and should initialize t...">_initialize()</a></em> must be defined by the used LP-solver and should initialize the LP-solver with. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sense</td><td>The sense of the optimization. </td></tr>
    <tr><td class="paramname">nRow</td><td>The number of rows. </td></tr>
    <tr><td class="paramname">maxRow</td><td>The maximal number of rows. </td></tr>
    <tr><td class="paramname">nCol</td><td>The number of columns. </td></tr>
    <tr><td class="paramname">maxCol</td><td>The maximal number of columns. </td></tr>
    <tr><td class="paramname">obj</td><td>An array with the objective functions coefficients. </td></tr>
    <tr><td class="paramname">lBound</td><td>An array with the lower bounds of the variables. </td></tr>
    <tr><td class="paramname">uBound</td><td>An array with the upper bounds of the variables. </td></tr>
    <tr><td class="paramname">rows</td><td>An array storing the constraint matrix in row format. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a54b86d2108d0ee524d9f89d1c1414715">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="ab91c80d913b085c3be5af835c96520a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91c80d913b085c3be5af835c96520a0">&sect;&nbsp;</a></span>_lBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::LP::_lBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#ab91c80d913b085c3be5af835c96520a0" title="The pure virtual function _lBound() must be defined by the used LP-solver and return the lower bound ...">_lBound()</a></em> must be defined by the used LP-solver and return the lower bound of variable <em>i</em>. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a2d55f62afcc10622623e45bdbfd824ca">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a02a31f0a99f9e492ca60eb5a3ce55ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a31f0a99f9e492ca60eb5a3ce55ef4">&sect;&nbsp;</a></span>_loadBasis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::LP::_loadBasis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_l_p_v_a_r_s_t_a_t.html#a26136feb2521120a7c71e02e830af809">LPVARSTAT::STATUS</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lpVarStat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_slack_stat.html#a7aaac2c567af8d69a233ee04b7dc0bcb">SlackStat::STATUS</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>slackStat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This pure virtual function should load a basis into the LP-solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lpVarStat</td><td>An array storing the status of the variables. </td></tr>
    <tr><td class="paramname">slackStat</td><td>An array storing the status of the slack variables. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a90bf7069b327279a286ea5464546f5f9">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a70652f1ddccc3c9fa9c75e9bbc58ea94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70652f1ddccc3c9fa9c75e9bbc58ea94">&sect;&nbsp;</a></span>_lpVarStat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classabacus_1_1_l_p_v_a_r_s_t_a_t.html#a26136feb2521120a7c71e02e830af809">LPVARSTAT::STATUS</a> abacus::LP::_lpVarStat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a70652f1ddccc3c9fa9c75e9bbc58ea94" title="The pure virtual function _lpVarStat() must be defined by the used LP-solver and should return the st...">_lpVarStat()</a></em> must be defined by the used LP-solver and should return the status of the variable <em>i</em> in the LP-solution. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a14f9c0fa088683b725ca661c64e10490">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="ab1d49b2b20bd820cbde5d17e969f6e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d49b2b20bd820cbde5d17e969f6e7b">&sect;&nbsp;</a></span>_maxCol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::LP::_maxCol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#ab1d49b2b20bd820cbde5d17e969f6e7b" title="The pure virtual function _maxCol() must be defined by the the used LP-solver and return the maximal ...">_maxCol()</a></em> must be defined by the the used LP-solver and return the maximal number of columns. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a7d72b7091c323ae1925dbaf3401b5097">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a607e065f36b9ef50b0fdae61d5c91e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607e065f36b9ef50b0fdae61d5c91e25">&sect;&nbsp;</a></span>_maxRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::LP::_maxRow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a607e065f36b9ef50b0fdae61d5c91e25" title="The pure virtual function _maxRow() must be defined by the used LP-solver and return the maximal numb...">_maxRow()</a></em> must be defined by the used LP-solver and return the maximal number of rows. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#aff0a2f8f84b76adb90dc7aea7d118a6a">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a2f64460fc0744a935b97e446908e32f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f64460fc0744a935b97e446908e32f8">&sect;&nbsp;</a></span>_nCol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::LP::_nCol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a2f64460fc0744a935b97e446908e32f8" title="The pure virtual function _nCol() must be defined by the used LP-solver and return the number of colu...">_nCol()</a></em> must be defined by the used LP-solver and return the number of columns. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a39bfb15a7ade58d189b26a0cb66e0612">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a6c38437e0e2ee6fdc0dedf309b1114b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c38437e0e2ee6fdc0dedf309b1114b3">&sect;&nbsp;</a></span>_nnz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::LP::_nnz </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a6c38437e0e2ee6fdc0dedf309b1114b3" title="The pure virtual function _nnz() must be defined by the used LP-solver and return the number of nonze...">_nnz()</a></em> must be defined by the used LP-solver and return the number of nonzero elements of the constraint matrix not including the right hand side and the bounds of the variables. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#aded28567e38a6c0cf77d07866267603c">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="ad874de501e118f3e00b7ebf4393d8836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad874de501e118f3e00b7ebf4393d8836">&sect;&nbsp;</a></span>_nRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::LP::_nRow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#ad874de501e118f3e00b7ebf4393d8836" title="The pure virtual function _nRow() must be defined by the used LP-solver and return the number of rows...">_nRow()</a></em> must be defined by the used LP-solver and return the number of rows of the problem. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#adee1e057521f2a70242f8801a6bba8b4">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a754dffa1c2f1dd53ac2819edf6ed0f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754dffa1c2f1dd53ac2819edf6ed0f67">&sect;&nbsp;</a></span>_obj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::LP::_obj </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a754dffa1c2f1dd53ac2819edf6ed0f67" title="The pure virtual function _obj() must be defined by the used LP-solver and return the objective funct...">_obj()</a></em> must be defined by the used LP-solver and return the objective function coefficient of variable <em>i</em>. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a83793e33dfa8e906bef9e688ada302d7">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a8dadb9e79b93029db3181eab931d2b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dadb9e79b93029db3181eab931d2b0d">&sect;&nbsp;</a></span>_pivotSlackVariableIn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::LP::_pivotSlackVariableIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function <em><a class="el" href="classabacus_1_1_l_p.html#a0f7d31b7e6ec21b482c58ebbd7490fa1" title="Pivots the slack variables stored in the buffer rows into the basis. ">pivotSlackVariableIn()</a></em> pivots the slack variables stored in the buffer <em>rows</em> into the basis. </p>
<dl class="section return"><dt>Returns</dt><dd>0 All variables could be pivoted in, </dd>
<dd>
1 otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The numbers of the slack variables that should be pivoted in. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#ad05b74bc6b22227666cc983c7d526f5d">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a04e7b008ff9addd031b9147762e4142f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e7b008ff9addd031b9147762e4142f">&sect;&nbsp;</a></span>_primalSimplex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dce">OPTSTAT</a> abacus::LP::_primalSimplex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a04e7b008ff9addd031b9147762e4142f" title="The pure virtual function _primalSimplex() must be defined by the used LP-solver and should call the ...">_primalSimplex()</a></em> must be defined by the used LP-solver and should call the primal simplex method of the used LP-solver. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#ab09d7b79090cfb20f5e536c2fa08ca16">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a3f3e2058b7af5031059975c488ff5903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3e2058b7af5031059975c488ff5903">&sect;&nbsp;</a></span>_reco()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::LP::_reco </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a3f3e2058b7af5031059975c488ff5903" title="The pure virtual function _reco() must be defined by the used LP-solver and should return the reduced...">_reco()</a></em> must be defined by the used LP-solver and should return the reduced cost of variable <em>i</em>. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#ab8f5c377b98ada02140edab0e7590f14">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a4c36aaca7768fb55624ef77275044a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c36aaca7768fb55624ef77275044a31">&sect;&nbsp;</a></span>_remCols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::LP::_remCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a4c36aaca7768fb55624ef77275044a31" title="The pure virtual function _remCols() must be defined by the used LP-solver and should remove the colu...">_remCols()</a></em> must be defined by the used LP-solver and should remove the columns with numbers given in <em>vars</em> from the <a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a>. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a04295ac6bee4d5fe2a231c8c1080bdb5">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a8467dbb4deb2d00d04466fec3644ccd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8467dbb4deb2d00d04466fec3644ccd0">&sect;&nbsp;</a></span>_remRows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::LP::_remRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a8467dbb4deb2d00d04466fec3644ccd0" title="The pure virtual function _remRows() must be defined by the used LP-solver and should remove the rows...">_remRows()</a></em> must be defined by the used LP-solver and should remove the rows with numbers given in the buffer <em>ind</em> from the LP-solver. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a8f845e4bd6941794904dbd4713ae08b0">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a4d21fa7fe7b0d290b20dd04a7ee7ee9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d21fa7fe7b0d290b20dd04a7ee7ee9c">&sect;&nbsp;</a></span>_rhs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::LP::_rhs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a4d21fa7fe7b0d290b20dd04a7ee7ee9c" title="The pure virtual function _rhs() must be defined by the used LP-solver and return the right hand side...">_rhs()</a></em> must be defined by the used LP-solver and return the right hand side of constraint <em>i</em>. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a6a0ec2933494047970d67570daa7fa12">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a8c713bdee5a93f8c6b4f6b689fdf71fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c713bdee5a93f8c6b4f6b689fdf71fc">&sect;&nbsp;</a></span>_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::LP::_row </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_row.html">Row</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a8c713bdee5a93f8c6b4f6b689fdf71fc" title="The pure virtual function _row() must be defined by the used LP-solver and store the i-th row of the ...">_row()</a></em> must be defined by the used LP-solver and store the <em>i-th</em> row of the problem in the row <em>r</em>. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a235de2f25bf4287ea33c325feffd4f32">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="adc4c6243ee546bfdcbf6f04bfddf1cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4c6243ee546bfdcbf6f04bfddf1cfe">&sect;&nbsp;</a></span>_rowRealloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::LP::_rowRealloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#adc4c6243ee546bfdcbf6f04bfddf1cfe" title="The pure virtual function _rowRealloc() must be defined in the used LP-solver and should reallocate i...">_rowRealloc()</a></em> must be defined in the used LP-solver and should reallocate its memory such that up to <em>newSize</em> rows can be handled. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a4f18be5901e6cc5a8be0976e52248d51">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="aabcc99aae7fe8ae61a880d46f31b1b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabcc99aae7fe8ae61a880d46f31b1b81">&sect;&nbsp;</a></span>_sense() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classabacus_1_1_opt_sense.html">OptSense</a> abacus::LP::_sense </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#aabcc99aae7fe8ae61a880d46f31b1b81" title="The pure virtual function _sense() must be defined by the used LP-solver and return the sense of the ...">_sense()</a></em> must be defined by the used LP-solver and return the sense of the optimization. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#afde6b8d21039d6a809fc7be19158df13">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="ac1eb6463c435da25e0399191bf718827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1eb6463c435da25e0399191bf718827">&sect;&nbsp;</a></span>_sense() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::LP::_sense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classabacus_1_1_opt_sense.html">OptSense</a> &amp;&#160;</td>
          <td class="paramname"><em>newSense</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a41854a1910107eab63200ee8e69fe4d2">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a07d455b0d4d3795a0ca1acfeaf3b4d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d455b0d4d3795a0ca1acfeaf3b4d64">&sect;&nbsp;</a></span>_setSimplexIterationLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::LP::_setSimplexIterationLimit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function <em><a class="el" href="classabacus_1_1_l_p.html#ad1eba72e8f92680cad57e8fc6999f2dc" title="Changes the iteration limit of the Simplex algorithm. ">setSimplexIterationLimit()</a></em> changes the iteration limit of the Simplex algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>0 If the iteration limit could be set, </dd>
<dd>
1 otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>The new value of the iteration limit. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a381fb9355a3515e2b39846f8d8a0cca4">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a78366d982204f8cedbb324042ecd3341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78366d982204f8cedbb324042ecd3341">&sect;&nbsp;</a></span>_slack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::LP::_slack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a78366d982204f8cedbb324042ecd3341" title="The pure virtual function _slack() must be defined by the used LP-solver and should return the value ...">_slack()</a></em> must be defined by the used LP-solver and should return the value of the slack variable <em>i</em>. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#acb31677506f8d77793ebcd0656f46a1e">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="af5b998e9d1e98bfdc507767547f46a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b998e9d1e98bfdc507767547f46a63">&sect;&nbsp;</a></span>_slackStat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classabacus_1_1_slack_stat.html#a7aaac2c567af8d69a233ee04b7dc0bcb">SlackStat::STATUS</a> abacus::LP::_slackStat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#af5b998e9d1e98bfdc507767547f46a63" title="The pure virtual function _slackStat() must be defined by the used LP-solver and should return the st...">_slackStat()</a></em> must be defined by the used LP-solver and should return the status of the slack variable <em>i</em> in the LP-solution. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a6674b02823dd40043f9be7aee60b40da">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="ad34df605cd972d993a830b79c18e007a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34df605cd972d993a830b79c18e007a">&sect;&nbsp;</a></span>_uBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::LP::_uBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#ad34df605cd972d993a830b79c18e007a" title="The pure virtual function _uBound() must be defined by the used LP-solver and return the upper bound ...">_uBound()</a></em> must be defined by the used LP-solver and return the upper bound of variable <em>i</em>. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#a799ef63beba86072fd9c540f041e7226">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a146c75a6b63bc0e41e0f5cea136124f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a146c75a6b63bc0e41e0f5cea136124f6">&sect;&nbsp;</a></span>_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::LP::_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a146c75a6b63bc0e41e0f5cea136124f6" title="The pure virtual function _value() must be defined by the used LP-solver and should return the optimu...">_value()</a></em> must be defined by the used LP-solver and should return the optimum value of the linear program after it has been solved. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#acf6a67725cb8a183a28b77f094204855">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a3066f3da3599f74ed22c41a692b6b969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3066f3da3599f74ed22c41a692b6b969">&sect;&nbsp;</a></span>_xVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::LP::_xVal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a3066f3da3599f74ed22c41a692b6b969" title="The pure virtual function _xVal() must be defined by the used LP-solver and should return the value o...">_xVal()</a></em> must be defined by the used LP-solver and should return the value of variable <em>i</em> in the LP-solution. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#af63ec3d6b875f0c42ff632f4aab424b4">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a62cd15eeb0a377bee7884f8776237fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62cd15eeb0a377bee7884f8776237fb4">&sect;&nbsp;</a></span>_yVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::LP::_yVal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pure virtual function <em><a class="el" href="classabacus_1_1_l_p.html#a62cd15eeb0a377bee7884f8776237fb4" title="The pure virtual function _yVal() must be defined by the used LP-solver and should return the value o...">_yVal()</a></em> must be defined by the used LP-solver and should return the value of the dual variable of the constraint <em>i</em>. </p>

<p>Implemented in <a class="el" href="classabacus_1_1_osi_i_f.html#ae3d64c8c499376fff8834e53fd68008f">abacus::OsiIF</a>.</p>

</div>
</div>
<a id="a75a2d40f40c7546d3bdd88a7439356ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a2d40f40c7546d3bdd88a7439356ff">&sect;&nbsp;</a></span>addCols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::LP::addCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_column.html">Column</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>newCols</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds columns to the linear program. </p>
<p>If the new number of columns exceeds the maximal number of columns a reallocation is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newCols</td><td>The new columns that are added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fefb06fef51e65e05c060f03d9a7d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fefb06fef51e65e05c060f03d9a7d5d">&sect;&nbsp;</a></span>addRows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::LP::addRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_row.html">Row</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>newRows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds rows to the linear program. </p>
<p>If the new number of rows exceeds the maximal number of rows a reallocation is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newRows</td><td>The rows that should be added to the linear program. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad08f11773a94f5088aeebee18c908db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08f11773a94f5088aeebee18c908db0">&sect;&nbsp;</a></span>barXVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::LP::barXVal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classabacus_1_1_lp_sub.html#a9b02c113fd56224ecf37ae190326ee0e">abacus::LpSub</a>.</p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00273">273</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="abbb7cc563da968a8a5377baa6914d03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb7cc563da968a8a5377baa6914d03d">&sect;&nbsp;</a></span>barXValStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a> abacus::LP::barXValStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00303">303</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a7a3e7f38f2d55f85dea608eb2f92f5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3e7f38f2d55f85dea608eb2f92f5d5">&sect;&nbsp;</a></span>basisStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a> abacus::LP::basisStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00311">311</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a9526432e360be1d3a1f6aa485389b8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9526432e360be1d3a1f6aa485389b8c2">&sect;&nbsp;</a></span>changeLBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::LP::changeLBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>newLb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the lower bound of a single column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The column. </td></tr>
    <tr><td class="paramname">newLb</td><td>The new lower bound of the column. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classabacus_1_1_lp_sub.html#af443dcd55d0b0774822985c0151211d9">abacus::LpSub</a>.</p>

</div>
</div>
<a id="a8e7c23292e45467e893ce94ca08e90bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7c23292e45467e893ce94ca08e90bc">&sect;&nbsp;</a></span>changeRhs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::LP::changeRhs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>newRhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the complete right hand side of the linear program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newRhs</td><td>The new right hand side of the rows. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00412">412</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a5255cefa00d9d2aa98512ed71ec5ee41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5255cefa00d9d2aa98512ed71ec5ee41">&sect;&nbsp;</a></span>changeUBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::LP::changeUBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>newUb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the upper bound of a single column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The column. </td></tr>
    <tr><td class="paramname">newUb</td><td>The new upper bound of the column. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classabacus_1_1_lp_sub.html#a87878d0b9e5606f7d6f80bac63427ef8">abacus::LpSub</a>.</p>

</div>
</div>
<a id="a7888959f2e3ec7c9680985d9eccbe9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7888959f2e3ec7c9680985d9eccbe9ec">&sect;&nbsp;</a></span>colRangeCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::LP::colRangeCheck </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Terminates the program if there is no column with index <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The number of a column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80d6af6866177f8ca1211d1c2920a573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d6af6866177f8ca1211d1c2920a573">&sect;&nbsp;</a></span>colRealloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::LP::colRealloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reallocation of the column space of the linear program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>The new maximal number of columns of the linear program. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00453">453</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a58ea843da891327307073ac26e18a0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ea843da891327307073ac26e18a0a0">&sect;&nbsp;</a></span>colsNnz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::LP::colsNnz </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_row.html">Row</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of nonzero elements in each column of a given set of rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nRow</td><td>The number of rows. </td></tr>
    <tr><td class="paramname">rows</td><td>The array storing the rows. </td></tr>
    <tr><td class="paramname">nnz</td><td>An array of length at least the number of columns of the linear program which will hold the number of nonzero elements of each column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87f4998ab35470adde7a4248e92183db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f4998ab35470adde7a4248e92183db">&sect;&nbsp;</a></span>getInfeas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::LP::getInfeas </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>infeasRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>infeasCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>bInvRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be called if the last linear program has been solved with the dual simplex method and is infeasible and all inactive variables price out correctly. </p>
<p>Then, the basis is dual feasible, but primal infeasible, i.e., some variables or slack variables violate their bounds. In this case the function <em><a class="el" href="classabacus_1_1_l_p.html#a87f4998ab35470adde7a4248e92183db" title="Can be called if the last linear program has been solved with the dual simplex method and is infeasib...">getInfeas()</a></em> determines an infeasible variable or slack variable.</p>
<p>If <em><a class="el" href="classabacus_1_1_l_p.html#a87f4998ab35470adde7a4248e92183db" title="Can be called if the last linear program has been solved with the dual simplex method and is infeasib...">getInfeas()</a></em> is successful, then either <em>infeasRow</em> or <em>infeasVar</em> is \(-1\) and the other argument holds the nonnegative number of the infeasible variable.</p>
<dl class="section return"><dt>Returns</dt><dd>0 On success, </dd>
<dd>
1 otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">infeasRow</td><td>Holds after the execution the number of an infeasible slack variable, or \(-1\). </td></tr>
    <tr><td class="paramname">infeasCol</td><td>Holds after the execution the number of an infeasible column, or \(-1\). </td></tr>
    <tr><td class="paramname">bInvRow</td><td>Holds after the execution the row of the basis inverse corresponding to the infeasible column or slack variable, which is always a basic variable. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classabacus_1_1_lp_sub.html#a3ed43d10b1ae0cf35f51b15a8e4a904c">abacus::LpSub</a>.</p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00346">346</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="ac2b76d347de6c4c4a1e9eadad21de62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b76d347de6c4c4a1e9eadad21de62c">&sect;&nbsp;</a></span>getSimplexIterationLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::LP::getSimplexIterationLimit </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>0 If the iteration limit could be get, </dd>
<dd>
1 otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>Stores the iteration limit if the return value is 0. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00485">485</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a043f9be10050bfd1d373a52f68d941e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043f9be10050bfd1d373a52f68d941e2">&sect;&nbsp;</a></span>infeasible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool abacus::LP::infeasible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classabacus_1_1_lp_sub.html#a9ab670cf98ca5bfe9f116360545980bb">abacus::LpSub</a>.</p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00315">315</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a4f2b2599c34a8a3b5c2566c0b99fb1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2b2599c34a8a3b5c2566c0b99fb1fc">&sect;&nbsp;</a></span>initialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::LP::initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_opt_sense.html">OptSense</a>&#160;</td>
          <td class="paramname"><em>sense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>lBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>uBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_row.html">Row</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads the linear program defined by its arguments. </p>
<p>We do not perform the initialization via arguments of a constructor, since for the most frequent application of linear programs within ABACUS, the solution of the linear programming relaxations in the subproblems, the problem data is preprocessed before it is loaded. Only after the preprocessing in the constructor of the derived class, we can call <em><a class="el" href="classabacus_1_1_l_p.html#a4f2b2599c34a8a3b5c2566c0b99fb1fc" title="Loads the linear program defined by its arguments. ">initialize()</a></em>.</p>
<p>Of course, it would be possible to provide an extra constructor with automatic initialization if required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sense</td><td>The sense of the objective function. </td></tr>
    <tr><td class="paramname">nRow</td><td>The number of rows. </td></tr>
    <tr><td class="paramname">maxRow</td><td>The maximal number of rows. </td></tr>
    <tr><td class="paramname">nCol</td><td>The number of columns (variables). </td></tr>
    <tr><td class="paramname">maxCol</td><td>The maximal number of columns. </td></tr>
    <tr><td class="paramname">obj</td><td>An array with the objective function coefficients. </td></tr>
    <tr><td class="paramname">lBound</td><td>An array with the lower bounds of the columns. </td></tr>
    <tr><td class="paramname">uBound</td><td>An array with the upper bounds of the columns. </td></tr>
    <tr><td class="paramname">rows</td><td>An array storing the rows of the problem. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00160">160</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a25d4c994fa96f2d137f17a28f6ff37f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d4c994fa96f2d137f17a28f6ff37f1">&sect;&nbsp;</a></span>initialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::LP::initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_opt_sense.html">OptSense</a>&#160;</td>
          <td class="paramname"><em>sense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>lBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>uBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_row.html">Row</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_l_p_v_a_r_s_t_a_t.html#a26136feb2521120a7c71e02e830af809">LPVARSTAT::STATUS</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lpVarStat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_slack_stat.html#a7aaac2c567af8d69a233ee04b7dc0bcb">SlackStat::STATUS</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>slackStat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This version of the function <em><a class="el" href="classabacus_1_1_l_p.html#a4f2b2599c34a8a3b5c2566c0b99fb1fc" title="Loads the linear program defined by its arguments. ">initialize()</a></em> performs like its previous version, but also initializes the basis with the arguments: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sense</td><td>The sense of the objective function. </td></tr>
    <tr><td class="paramname">nRow</td><td>The number of rows. </td></tr>
    <tr><td class="paramname">maxRow</td><td>The maximal number of rows. </td></tr>
    <tr><td class="paramname">nCol</td><td>The number of columns (variables). </td></tr>
    <tr><td class="paramname">maxCol</td><td>The maximal number of columns. </td></tr>
    <tr><td class="paramname">obj</td><td>An array with the objective function coefficients. </td></tr>
    <tr><td class="paramname">lBound</td><td>An array with the lower bounds of the columns. </td></tr>
    <tr><td class="paramname">uBound</td><td>An array with the upper bounds of the columns. </td></tr>
    <tr><td class="paramname">rows</td><td>An array storing the rows of the problem. </td></tr>
    <tr><td class="paramname">lpVarStat</td><td>An array storing the status of the columns. </td></tr>
    <tr><td class="paramname">slackStat</td><td>An array storing the status of the slack variables. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00189">189</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a0a9559abdfbdbd45066d76250895c256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9559abdfbdbd45066d76250895c256">&sect;&nbsp;</a></span>initPostOpt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::LP::initPostOpt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the optimization status and the availability statuses of the solution. </p>
<p>The function <em><a class="el" href="classabacus_1_1_l_p.html#a0a9559abdfbdbd45066d76250895c256" title="Resets the optimization status and the availability statuses of the solution. ">initPostOpt()</a></em> must be called after each modification of the linear program. It resets the optimization status and the availability status of the solution. </p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00841">841</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a6602176eee0665ce5f79e73c6dfe0df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6602176eee0665ce5f79e73c6dfe0df1">&sect;&nbsp;</a></span>lBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double abacus::LP::lBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00236">236</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="ae0a4c8000cd415695543e51af9677b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a4c8000cd415695543e51af9677b14">&sect;&nbsp;</a></span>loadBasis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::LP::loadBasis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_l_p_v_a_r_s_t_a_t.html#a26136feb2521120a7c71e02e830af809">LPVARSTAT::STATUS</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lpVarStat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_slack_stat.html#a7aaac2c567af8d69a233ee04b7dc0bcb">SlackStat::STATUS</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>slackStat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a new basis for the linear program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lpVarStat</td><td>An array storing the status of the columns. </td></tr>
    <tr><td class="paramname">slackStat</td><td>An array storing the status of the slack variables. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classabacus_1_1_lp_sub.html#a0ba5f30964fe277072ad7fd5490a6895">abacus::LpSub</a>.</p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00209">209</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a9da50003a771fcb023899ea4e79112ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da50003a771fcb023899ea4e79112ac">&sect;&nbsp;</a></span>lpSolverTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_stopwatch_c_p_u.html">ogdf::StopwatchCPU</a>* abacus::LP::lpSolverTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00489">489</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a1b44feb09201b79fc0b6ba8c8807fb9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b44feb09201b79fc0b6ba8c8807fb9b">&sect;&nbsp;</a></span>lpVarStat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classabacus_1_1_l_p_v_a_r_s_t_a_t.html#a26136feb2521120a7c71e02e830af809">LPVARSTAT::STATUS</a> abacus::LP::lpVarStat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classabacus_1_1_lp_sub.html#a7d484d209bd7d660ce9afa6b9aa9cfe0">abacus::LpSub</a>.</p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00350">350</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="ae40937f14564d39f0765048361095523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40937f14564d39f0765048361095523">&sect;&nbsp;</a></span>maxCol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::LP::maxCol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00225">225</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a24baf164e9e3d2c88afc73ef3dfebdc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24baf164e9e3d2c88afc73ef3dfebdc2">&sect;&nbsp;</a></span>maxRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::LP::maxRow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00221">221</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a5fba2c3f47ba007afc672634c17e2293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fba2c3f47ba007afc672634c17e2293">&sect;&nbsp;</a></span>nCol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::LP::nCol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00223">223</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a17bdc5cf22e0c52452c793bf32dd9b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bdc5cf22e0c52452c793bf32dd9b9d">&sect;&nbsp;</a></span>nnz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::LP::nnz </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00227">227</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="ac461cec05b89fbbd424ecc5d021f807b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac461cec05b89fbbd424ecc5d021f807b">&sect;&nbsp;</a></span>nOpt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::LP::nOpt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00313">313</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="ab7da9ce19af761f5f802291b5074c5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7da9ce19af761f5f802291b5074c5db">&sect;&nbsp;</a></span>nRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::LP::nRow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00219">219</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="ab625238c8ec36fe47f6c1ff9330fce4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab625238c8ec36fe47f6c1ff9330fce4d">&sect;&nbsp;</a></span>obj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double abacus::LP::obj </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00229">229</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a51d04a6937dc854fa03e518aa0f5f380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d04a6937dc854fa03e518aa0f5f380">&sect;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classabacus_1_1_l_p.html">LP</a>&amp; abacus::LP::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classabacus_1_1_l_p.html">LP</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9459572d6d04b194c493122977f22cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9459572d6d04b194c493122977f22cd">&sect;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dce">OPTSTAT</a> abacus::LP::optimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_l_p.html#a80d390b461dca15f5aba8068995b0063">METHOD</a>&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the optimization of the linear program. </p>
<dl class="section return"><dt>Returns</dt><dd>The status of the optimization.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>The method with which the optimization is performed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classabacus_1_1_lp_sub.html#a47ac99b18487e54b71e80a2614c7617b">abacus::LpSub</a>.</p>

</div>
</div>
<a id="a0f7d31b7e6ec21b482c58ebbd7490fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7d31b7e6ec21b482c58ebbd7490fa1">&sect;&nbsp;</a></span>pivotSlackVariableIn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::LP::pivotSlackVariableIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pivots the slack variables stored in the buffer <em>rows</em> into the basis. </p>
<dl class="section return"><dt>Returns</dt><dd>0 All variables could be pivoted in, </dd>
<dd>
1 otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The numbers of the slack variables that should be pivoted in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5554da2bde032986bd1d7956a5ff3194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5554da2bde032986bd1d7956a5ff3194">&sect;&nbsp;</a></span>reco()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::LP::reco </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classabacus_1_1_lp_sub.html#a746f6116ba7ffb5a409de6aefb1cfe16">abacus::LpSub</a>.</p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00280">280</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="ac756edff57de5d8a073d27f5ada4505b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac756edff57de5d8a073d27f5ada4505b">&sect;&nbsp;</a></span>recoStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a> abacus::LP::recoStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00307">307</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a11de783a1f17846f7652cdf71a4b382e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11de783a1f17846f7652cdf71a4b382e">&sect;&nbsp;</a></span>remCols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::LP::remCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes columns from the linear program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cols</td><td>The numbers of the columns that should be removed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00394">394</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a8684247a0616681d8af24882e1b19b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8684247a0616681d8af24882e1b19b5d">&sect;&nbsp;</a></span>remRows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::LP::remRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes rows of the linear program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ind</td><td>The numbers of the rows that should be removed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00376">376</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a17faeb4b7f9e400cdf8367b718d3de0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17faeb4b7f9e400cdf8367b718d3de0e">&sect;&nbsp;</a></span>rhs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double abacus::LP::rhs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00257">257</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a0261fde619e348415b63928c944b3a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0261fde619e348415b63928c944b3a52">&sect;&nbsp;</a></span>row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::LP::row </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_row.html">Row</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00250">250</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="ad4ca0aa1f3f77f98da42b772562b258a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ca0aa1f3f77f98da42b772562b258a">&sect;&nbsp;</a></span>rowRangeCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::LP::rowRangeCheck </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Terminates the program if there is no row with index <em>r</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The number of a row of the linear program. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a624c75dec155251d5d5f468f94a249a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624c75dec155251d5d5f468f94a249a1">&sect;&nbsp;</a></span>rowRealloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::LP::rowRealloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reallocation of the row space of the linear program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>The new maximal number of rows of the linear program. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00445">445</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a887c43776e1f97b1967df33e8e7bb266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887c43776e1f97b1967df33e8e7bb266">&sect;&nbsp;</a></span>rows2cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::LP::rows2cols </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_row.html">Row</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_spar_vec.html">SparVec</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the columnwise representation of the row matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nRow</td><td>The number of rows. </td></tr>
    <tr><td class="paramname">rows</td><td>The array storing the rows. </td></tr>
    <tr><td class="paramname">cols</td><td>An array holding pointers to sparse vectors which will contain the columnwise representation of the constraint matrix defined by <em>rows</em>. The length of this array must be at least the number of columns. The elements of the array must not be 0-pointers. Sparse vectors of sufficient length should be allocated before the function is called. The size of these sparse vectors can be determined with the function <em><a class="el" href="classabacus_1_1_l_p.html#a58ea843da891327307073ac26e18a0a0" title="Computes the number of nonzero elements in each column of a given set of rows. ">colsNnz()</a></em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7184374cd10742c38f26164757eacc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7184374cd10742c38f26164757eacc2d">&sect;&nbsp;</a></span>sense() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_opt_sense.html">OptSense</a> abacus::LP::sense </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00215">215</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="ad29d96d3a191c8af85fb8a9fb9e92130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29d96d3a191c8af85fb8a9fb9e92130">&sect;&nbsp;</a></span>sense() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::LP::sense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classabacus_1_1_opt_sense.html">OptSense</a> &amp;&#160;</td>
          <td class="paramname"><em>newSense</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00217">217</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="ad1eba72e8f92680cad57e8fc6999f2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1eba72e8f92680cad57e8fc6999f2dc">&sect;&nbsp;</a></span>setSimplexIterationLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::LP::setSimplexIterationLimit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the iteration limit of the Simplex algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>0 If the iteration limit could be set, </dd>
<dd>
1 otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>The new value of the iteration limit. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00475">475</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a7181ea4803725e79e4c7c585f61fe666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7181ea4803725e79e4c7c585f61fe666">&sect;&nbsp;</a></span>slack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::LP::slack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00294">294</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a80cc53d882e8ec9a068b448e323f8601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cc53d882e8ec9a068b448e323f8601">&sect;&nbsp;</a></span>slackStat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classabacus_1_1_slack_stat.html#a7aaac2c567af8d69a233ee04b7dc0bcb">SlackStat::STATUS</a> abacus::LP::slackStat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00357">357</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a0c7ab054d5a8c97dc49c1316bccac236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7ab054d5a8c97dc49c1316bccac236">&sect;&nbsp;</a></span>slackStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a> abacus::LP::slackStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00309">309</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="aaa2333a128e0a3eb5429e180e1f1be52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2333a128e0a3eb5429e180e1f1be52">&sect;&nbsp;</a></span>uBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double abacus::LP::uBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00243">243</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a7c8ebc42f83d415025efdd14af1ef06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8ebc42f83d415025efdd14af1ef06b">&sect;&nbsp;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::LP::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classabacus_1_1_lp_sub.html#a6f4daffba142284a9521fdec6c4d308f">abacus::LpSub</a>.</p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00264">264</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a9bcca1cf514226f3d7aa16837044f6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bcca1cf514226f3d7aa16837044f6b5">&sect;&nbsp;</a></span>writeBasisMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::LP::writeBasisMatrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the complete basis of an optimal linear program to a file. </p>
<dl class="section return"><dt>Returns</dt><dd>0 If a basis is available and could be written, </dd>
<dd>
1 otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>The name of the file the basis is written to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4850f2f08186f8bd36ac2cfdc6149eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4850f2f08186f8bd36ac2cfdc6149eb9">&sect;&nbsp;</a></span>xVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::LP::xVal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classabacus_1_1_lp_sub.html#adbf8799cd11de31ed966b6568ec56f52">abacus::LpSub</a>.</p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00266">266</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="ad2e8566a848120256715b6529badc527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e8566a848120256715b6529badc527">&sect;&nbsp;</a></span>xValStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a> abacus::LP::xValStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00301">301</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a6a561cec2e45a9eee87627e0891bda18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a561cec2e45a9eee87627e0891bda18">&sect;&nbsp;</a></span>yVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::LP::yVal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00287">287</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a33ac5e3995dc60c27ee798566d5e19e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ac5e3995dc60c27ee798566d5e19e8">&sect;&nbsp;</a></span>yValStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a> abacus::LP::yValStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00305">305</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="affd271e58e45d6dc3e650e0854767654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd271e58e45d6dc3e650e0854767654">&sect;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classabacus_1_1_l_p.html">LP</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The output operator writes the objective function, followed by the constraints, the bounds on the columns and the solution values (if available) to an output stream. </p>
<p>Every ten output columns we perform a line break for better readability. This has also the advantage that LP-solvers with an input function requiring a limited length of a line (e.g., Cplex 255 characters) have a higher chance to read a file generated by this output operator.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the output stream.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output stream. </td></tr>
    <tr><td class="paramname">rhs</td><td>The linear program being output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5d86eadb5cddccea373404a6170e7400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d86eadb5cddccea373404a6170e7400">&sect;&nbsp;</a></span>barXValStatus_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a> abacus::LP::barXValStatus_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00797">797</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a65ab24d983cd17a0850e37727e782960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ab24d983cd17a0850e37727e782960">&sect;&nbsp;</a></span>basisStatus_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a> abacus::LP::basisStatus_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member becomes <em>Available</em> if the status of the variables and the slack variables of the optimal solution can be accessed with the functions <em><a class="el" href="classabacus_1_1_l_p.html#a1b44feb09201b79fc0b6ba8c8807fb9b">lpVarStat()</a></em> and <em><a class="el" href="classabacus_1_1_l_p.html#a80cc53d882e8ec9a068b448e323f8601">slackStat()</a></em>, otherwise it has the value <em>Missing</em>. </p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00825">825</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="aacb2493b8dab9def91778033dd36c14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb2493b8dab9def91778033dd36c14b">&sect;&nbsp;</a></span>lpSolverTime_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_stopwatch_c_p_u.html">ogdf::StopwatchCPU</a> abacus::LP::lpSolverTime_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lp_8h_source.html#l00830">830</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a18da23ceeb50d5f17f1d04a9441cb551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18da23ceeb50d5f17f1d04a9441cb551">&sect;&nbsp;</a></span>master_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_master.html">Master</a>* abacus::LP::master_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to the corresponding master of the optimization. </p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00786">786</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a9e0cf4cfc09702c69a79d945cc36902a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0cf4cfc09702c69a79d945cc36902a">&sect;&nbsp;</a></span>nOpt_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::LP::nOpt_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of optimizations of the linear program. </p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00829">829</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a551c42baea74b8261b0cca552cf1df3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551c42baea74b8261b0cca552cf1df3e">&sect;&nbsp;</a></span>optStat_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_l_p.html#a395bcfe1e844ad315ef7751c2ecc7dce">OPTSTAT</a> abacus::LP::optStat_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The status of the linear program. </p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00790">790</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a6f36c2e95234964193450a852ef0b534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f36c2e95234964193450a852ef0b534">&sect;&nbsp;</a></span>recoStatus_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a> abacus::LP::recoStatus_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member becomes <em>Available</em> if the reduced costs of the optimal solution can be accessed with the function <em><a class="el" href="classabacus_1_1_l_p.html#a5554da2bde032986bd1d7956a5ff3194">reco()</a></em>, otherwise it has the value <em>Missing</em>. </p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00810">810</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="aa10f78dc7360d8d4fc2eb1f93e805d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10f78dc7360d8d4fc2eb1f93e805d0e">&sect;&nbsp;</a></span>slackStatus_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a> abacus::LP::slackStatus_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member becomes <em>Available</em> if the values of the slack variables of the optimal solution can be accessed with the function <em><a class="el" href="classabacus_1_1_l_p.html#a7181ea4803725e79e4c7c585f61fe666">slack()</a></em>, otherwise it has the value <em>Missing</em>. </p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00817">817</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a5950d2b910e737a241ef57c7bd07ce45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5950d2b910e737a241ef57c7bd07ce45">&sect;&nbsp;</a></span>xValStatus_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a> abacus::LP::xValStatus_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member becomes <em>Available</em> if the \(x\)-values of the optimal solution can be accessed with the function <em><a class="el" href="classabacus_1_1_l_p.html#a4850f2f08186f8bd36ac2cfdc6149eb9">xVal()</a></em>, otherwise it has the value <em>Missing</em>. </p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00796">796</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<a id="a4523f575b6a8c919d80824e85a093dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4523f575b6a8c919d80824e85a093dcd">&sect;&nbsp;</a></span>yValStatus_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_l_p.html#ad3412c25dc5258be2d6a6336c364693b">SOLSTAT</a> abacus::LP::yValStatus_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member becomes <em>Available</em> if the values of the dual variables of the optimal solution can be accessed with the function <em><a class="el" href="classabacus_1_1_l_p.html#a6a561cec2e45a9eee87627e0891bda18">yVal()</a></em>, otherwise it has the value <em>Missing/</em>. </p>

<p>Definition at line <a class="el" href="lp_8h_source.html#l00804">804</a> of file <a class="el" href="lp_8h_source.html">lp.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ogdf/lib/abacus/<a class="el" href="lp_8h_source.html">lp.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceabacus.html">abacus</a></li><li class="navelem"><a class="el" href="classabacus_1_1_l_p.html">LP</a></li>
    <li class="footer">&copy; 1999&ndash;2016 <a href="http://ogdf.net/doku.php/team:about">The OGDF Team</a></li>
  </ul>
</div>
</body>
</html>
