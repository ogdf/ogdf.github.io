<!-- HTML header for doxygen 1.8.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>ogdf: abacus::Sub Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="govisual.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogdf-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
  <td align="center">
   <table border="0" cellspacing="0" cellpadding="0">
    <tr>
     <td width="264"><a href="http://www.ogdf.net" title="Go to www.ogdf.net" target="blank"><img  style="border-width: 0px" src="http://www.ogdf.net/lib/images/logoA.png"/></a></td>
     <td align="left"><h1 class="ogdftitle">Open<br>Graph Drawing<br>Framework</h1></td>
        <td align="left" valign="bottom" >
      <span style="font-size:110%; color:rgb(56,95,118)">&nbsp;v. snapshot-2017-02-16</span><br>&nbsp;
        </td>
    </tr>
   </table>
  </td>
 </tr>
 <tr>
  <td valign="bottom">
   <div class="menubox">
    <table border="0" cellpadding="0" cellspacing="0" class="menutable">
     <tr>
      <td><a class="menu" href="index.html" title="Start page with overview">Overview</a></td>
      <td><a class="menu" href="hierarchy.html" title="Inheritance hierarchies">Class&nbsp;Hierarchy</a></td>
      <td><a class="menu" href="classes.html" title="Alphabetical list of classes">Class&nbsp;Index</a></td>
      <td><a class="menu" href="annotated.html" title="Classes with brief descriptions">Class&nbsp;List</a></td>
      <td><a class="menu" href="functions.html" title="Complete list of member functions, enumerations, and variables">Members</a></td>
      <td><a class="menu" href="namespaces.html" title="Namespaces with brief descriptions">Namespaces</a></td>
      <td><a class="menu" href="files.html" title="Complete list of files with brief descriptions">Source&nbsp;Files</a></td>
          <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
     </tr>
    </table>
   </div><br>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classabacus_1_1_sub.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classabacus_1_1_sub-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">abacus::Sub Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The subproblem.  
 <a href="classabacus_1_1_sub.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sub_8h_source.html">ogdf/lib/abacus/sub.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for abacus::Sub:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classabacus_1_1_sub__inherit__graph.png" border="0" usemap="#abacus_1_1_sub_inherit__map" alt="Inheritance graph"/></div>
<map name="abacus_1_1_sub_inherit__map" id="abacus_1_1_sub_inherit__map">
<area shape="rect" id="node3" href="classogdf_1_1cluster__planarity_1_1_c_planarity_sub.html" title="ogdf::cluster_planarity\l::CPlanaritySub" alt="" coords="361,5,511,47"/>
<area shape="rect" id="node4" href="classogdf_1_1cluster__planarity_1_1_max_c_planar_sub.html" title="ogdf::cluster_planarity\l::MaxCPlanarSub" alt="" coords="361,71,511,112"/>
<area shape="rect" id="node5" href="classogdf_1_1_min_steiner_tree_directed_cut_1_1_sub.html" title="Subproblem of Steiner tree algorithm. " alt="" coords="340,136,532,177"/>
<area shape="rect" id="node2" href="classabacus_1_1_abacus_root.html" title="Base class of all other classes of ABACUS. " alt="" coords="5,78,149,105"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa9fe7d3a08b8ba4d97a8e4927178256e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aa9fe7d3a08b8ba4d97a8e4927178256e">PHASE</a> { <a class="el" href="classabacus_1_1_sub.html#aa9fe7d3a08b8ba4d97a8e4927178256ea11cf0b42c8fd79313439fd783c4dad60">Done</a>, 
<a class="el" href="classabacus_1_1_sub.html#aa9fe7d3a08b8ba4d97a8e4927178256ea2b697243e942f3023325fc7ba76ddd36">Cutting</a>, 
<a class="el" href="classabacus_1_1_sub.html#aa9fe7d3a08b8ba4d97a8e4927178256ea269cf6042e08ab945d99d3d9acb1c89f">Branching</a>, 
<a class="el" href="classabacus_1_1_sub.html#aa9fe7d3a08b8ba4d97a8e4927178256eab185bc7a9f947e039fcb627bcfc356c7">Fathoming</a>
 }<tr class="memdesc:aa9fe7d3a08b8ba4d97a8e4927178256e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The optimization of the subproblem can be in one of the following phases.  <a href="classabacus_1_1_sub.html#aa9fe7d3a08b8ba4d97a8e4927178256e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa9fe7d3a08b8ba4d97a8e4927178256e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49aa228f17967fc8ac589b5fb7bc3297"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a49aa228f17967fc8ac589b5fb7bc3297">STATUS</a> { <a class="el" href="classabacus_1_1_sub.html#a49aa228f17967fc8ac589b5fb7bc3297a09527dd8b24e222471d1d6d20c85e032">Unprocessed</a>, 
<a class="el" href="classabacus_1_1_sub.html#a49aa228f17967fc8ac589b5fb7bc3297a3dd81d2a00aece62a7337796a9575ffc">ActiveSub</a>, 
<a class="el" href="classabacus_1_1_sub.html#a49aa228f17967fc8ac589b5fb7bc3297a021d53f593fc734ddd605b06fd6f5455">Dormant</a>, 
<a class="el" href="classabacus_1_1_sub.html#a49aa228f17967fc8ac589b5fb7bc3297a16d99ac8fc568816d35ecdf08b9faf9c">Processed</a>, 
<a class="el" href="classabacus_1_1_sub.html#a49aa228f17967fc8ac589b5fb7bc3297a321890ae1302f574a9fd7f9a224604ac">Fathomed</a>
 }<tr class="memdesc:a49aa228f17967fc8ac589b5fb7bc3297"><td class="mdescLeft">&#160;</td><td class="mdescRight">A subproblem can have different statuses.  <a href="classabacus_1_1_sub.html#a49aa228f17967fc8ac589b5fb7bc3297">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a49aa228f17967fc8ac589b5fb7bc3297"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3d615932674f03cc77b4cc82e5f9b835"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a3d615932674f03cc77b4cc82e5f9b835">Sub</a> (<a class="el" href="classabacus_1_1_master.html">Master</a> *<a class="el" href="classabacus_1_1_sub.html#acef4a106b35486eee20ad545dcf956b6">master</a>, double conRes, double varRes, double nnzRes, bool relativeRes=true, <a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_pool_slot.html">PoolSlot</a>&lt; <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a> &gt; *&gt; *constraints=nullptr, <a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_pool_slot.html">PoolSlot</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; *&gt; *variables=nullptr)</td></tr>
<tr class="memdesc:a3d615932674f03cc77b4cc82e5f9b835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the root node of the enumeration tree.  <a href="#a3d615932674f03cc77b4cc82e5f9b835">More...</a><br /></td></tr>
<tr class="separator:a3d615932674f03cc77b4cc82e5f9b835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9918bc44c9a54813aa7f8a6a47a6ea8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ac9918bc44c9a54813aa7f8a6a47a6ea8">Sub</a> (<a class="el" href="classabacus_1_1_master.html">Master</a> *<a class="el" href="classabacus_1_1_sub.html#acef4a106b35486eee20ad545dcf956b6">master</a>, <a class="el" href="classabacus_1_1_sub.html">Sub</a> *<a class="el" href="classabacus_1_1_sub.html#a52d759383224a35cab360cc54b9d559a">father</a>, <a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a> *<a class="el" href="classabacus_1_1_sub.html#a73a26e269e8af3c052b7c76ade24b1a9">branchRule</a>)</td></tr>
<tr class="memdesc:ac9918bc44c9a54813aa7f8a6a47a6ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a non-root node of the enumeration tree.  <a href="#ac9918bc44c9a54813aa7f8a6a47a6ea8">More...</a><br /></td></tr>
<tr class="separator:ac9918bc44c9a54813aa7f8a6a47a6ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1f6f719dfa8526c602d113e8a931e9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a2c1f6f719dfa8526c602d113e8a931e9">~Sub</a> ()</td></tr>
<tr class="memdesc:a2c1f6f719dfa8526c602d113e8a931e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor only deletes the sons of the node.  <a href="#a2c1f6f719dfa8526c602d113e8a931e9">More...</a><br /></td></tr>
<tr class="separator:a2c1f6f719dfa8526c602d113e8a931e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019fc4f549f7de90f503de8e8fe9d55c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_active.html">Active</a>&lt; <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a019fc4f549f7de90f503de8e8fe9d55c">actCon</a> () const</td></tr>
<tr class="memdesc:a019fc4f549f7de90f503de8e8fe9d55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the currently active constraints.  <a href="#a019fc4f549f7de90f503de8e8fe9d55c">More...</a><br /></td></tr>
<tr class="separator:a019fc4f549f7de90f503de8e8fe9d55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe61332b73e4acdaf15fae6dfd319c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_active.html">Active</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aafe61332b73e4acdaf15fae6dfd319c0">actVar</a> () const</td></tr>
<tr class="memdesc:aafe61332b73e4acdaf15fae6dfd319c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the currently active variables.  <a href="#aafe61332b73e4acdaf15fae6dfd319c0">More...</a><br /></td></tr>
<tr class="separator:aafe61332b73e4acdaf15fae6dfd319c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae222662b978e24c00bb491b00f288ed"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aae222662b978e24c00bb491b00f288ed">addBranchingConstraint</a> (<a class="el" href="classabacus_1_1_pool_slot.html">PoolSlot</a>&lt; <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a> &gt; *slot)</td></tr>
<tr class="memdesc:aae222662b978e24c00bb491b00f288ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a branching constraint to the constraint buffer.  <a href="#aae222662b978e24c00bb491b00f288ed">More...</a><br /></td></tr>
<tr class="separator:aae222662b978e24c00bb491b00f288ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3ddf271847abc08dd0ab8132afb5fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a9f3ddf271847abc08dd0ab8132afb5fd">addConBufferSpace</a> () const</td></tr>
<tr class="memdesc:a9f3ddf271847abc08dd0ab8132afb5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used to determine the maximal number of the constraints which still can be added to the constraint buffer.  <a href="#a9f3ddf271847abc08dd0ab8132afb5fd">More...</a><br /></td></tr>
<tr class="separator:a9f3ddf271847abc08dd0ab8132afb5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f8a09630f7ad302431078abdd6962f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a69f8a09630f7ad302431078abdd6962f">addVarBufferSpace</a> () const</td></tr>
<tr class="memdesc:a69f8a09630f7ad302431078abdd6962f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used to determine the maximal number of the variables which still can be added to the variable buffer.  <a href="#a69f8a09630f7ad302431078abdd6962f">More...</a><br /></td></tr>
<tr class="separator:a69f8a09630f7ad302431078abdd6962f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02ac5e6bb195e7ce583d1fbda047cf7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aa02ac5e6bb195e7ce583d1fbda047cf7">ancestor</a> (const <a class="el" href="classabacus_1_1_sub.html">Sub</a> *sub) const</td></tr>
<tr class="memdesc:aa02ac5e6bb195e7ce583d1fbda047cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this subproblem is an ancestor of the subproblem <em>sub</em>, false otherwise.  <a href="#aa02ac5e6bb195e7ce583d1fbda047cf7">More...</a><br /></td></tr>
<tr class="separator:aa02ac5e6bb195e7ce583d1fbda047cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a26e269e8af3c052b7c76ade24b1a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a73a26e269e8af3c052b7c76ade24b1a9">branchRule</a> () const</td></tr>
<tr class="memdesc:a73a26e269e8af3c052b7c76ade24b1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the branching rule of the subproblem.  <a href="#a73a26e269e8af3c052b7c76ade24b1a9">More...</a><br /></td></tr>
<tr class="separator:a73a26e269e8af3c052b7c76ade24b1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2fe1cd061f8c2ba19fa518bbb481e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_constraint.html">Constraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a4a2fe1cd061f8c2ba19fa518bbb481e5">constraint</a> (int i) const</td></tr>
<tr class="memdesc:a4a2fe1cd061f8c2ba19fa518bbb481e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the <em>i</em>-th active constraint.  <a href="#a4a2fe1cd061f8c2ba19fa518bbb481e5">More...</a><br /></td></tr>
<tr class="separator:a4a2fe1cd061f8c2ba19fa518bbb481e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6b032a0f3a6ae9d87b845998ca3bce"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a8e6b032a0f3a6ae9d87b845998ca3bce">dualBound</a> () const</td></tr>
<tr class="memdesc:a8e6b032a0f3a6ae9d87b845998ca3bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bound which is "better" than the optimal solution of the subproblem w.r.t. the sense of the optimization.  <a href="#a8e6b032a0f3a6ae9d87b845998ca3bce">More...</a><br /></td></tr>
<tr class="separator:a8e6b032a0f3a6ae9d87b845998ca3bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d2e2f05d17dc1210460c606b0a33b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a09d2e2f05d17dc1210460c606b0a33b0">dualBound</a> (double x)</td></tr>
<tr class="memdesc:a09d2e2f05d17dc1210460c606b0a33b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dual bound of the subproblem.  <a href="#a09d2e2f05d17dc1210460c606b0a33b0">More...</a><br /></td></tr>
<tr class="separator:a09d2e2f05d17dc1210460c606b0a33b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d759383224a35cab360cc54b9d559a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classabacus_1_1_sub.html">Sub</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a52d759383224a35cab360cc54b9d559a">father</a> () const</td></tr>
<tr class="memdesc:a52d759383224a35cab360cc54b9d559a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the father of the subproblem in the branch-and-bound tree.  <a href="#a52d759383224a35cab360cc54b9d559a">More...</a><br /></td></tr>
<tr class="separator:a52d759383224a35cab360cc54b9d559a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631b64bf67b97816e398feaafeb362f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a631b64bf67b97816e398feaafeb362f8">forceExactSolver</a> () const</td></tr>
<tr class="memdesc:a631b64bf67b97816e398feaafeb362f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether using the exact solver is forced.  <a href="#a631b64bf67b97816e398feaafeb362f8">More...</a><br /></td></tr>
<tr class="separator:a631b64bf67b97816e398feaafeb362f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0539f5d44119789bc4ae9b7a9d26f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_f_s_var_stat.html">FSVarStat</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a8b0539f5d44119789bc4ae9b7a9d26f3">fsVarStat</a> (int i) const</td></tr>
<tr class="memdesc:a8b0539f5d44119789bc4ae9b7a9d26f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the status of fixing/setting of the <em>i</em>-th variable.  <a href="#a8b0539f5d44119789bc4ae9b7a9d26f3">More...</a><br /></td></tr>
<tr class="separator:a8b0539f5d44119789bc4ae9b7a9d26f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd6f95c28ec9d4fd820e92fe69ace53"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a6fd6f95c28ec9d4fd820e92fe69ace53">id</a> () const</td></tr>
<tr class="memdesc:a6fd6f95c28ec9d4fd820e92fe69ace53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the identity number of the subproblem.  <a href="#a6fd6f95c28ec9d4fd820e92fe69ace53">More...</a><br /></td></tr>
<tr class="separator:a6fd6f95c28ec9d4fd820e92fe69ace53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd373c0f807d36399d4db25ff5967a70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#abd373c0f807d36399d4db25ff5967a70">ignoreInTailingOff</a> ()</td></tr>
<tr class="memdesc:abd373c0f807d36399d4db25ff5967a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used to control better the tailing-off effect.  <a href="#abd373c0f807d36399d4db25ff5967a70">More...</a><br /></td></tr>
<tr class="separator:abd373c0f807d36399d4db25ff5967a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716918ee48ba0ced38c53b4660c0b789"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a716918ee48ba0ced38c53b4660c0b789">lBound</a> (int i) const</td></tr>
<tr class="memdesc:a716918ee48ba0ced38c53b4660c0b789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used to access the lower of an active variable of the subproblem.  <a href="#a716918ee48ba0ced38c53b4660c0b789">More...</a><br /></td></tr>
<tr class="separator:a716918ee48ba0ced38c53b4660c0b789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6192b550ac8e271bbd354d66648c223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aa6192b550ac8e271bbd354d66648c223">lBound</a> (int i, double l)</td></tr>
<tr class="memdesc:aa6192b550ac8e271bbd354d66648c223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the local lower bound of variable <em>i</em> to <em>l</em>.  <a href="#aa6192b550ac8e271bbd354d66648c223">More...</a><br /></td></tr>
<tr class="separator:aa6192b550ac8e271bbd354d66648c223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada62018cc513c76d8cf584b3a31cae88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ada62018cc513c76d8cf584b3a31cae88">level</a> () const</td></tr>
<tr class="memdesc:ada62018cc513c76d8cf584b3a31cae88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the level of the subproblem in the branch-and-bound tree.  <a href="#ada62018cc513c76d8cf584b3a31cae88">More...</a><br /></td></tr>
<tr class="separator:ada62018cc513c76d8cf584b3a31cae88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45e45488fbd3eec22dfc62e9145a9d8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ac45e45488fbd3eec22dfc62e9145a9d8">lowerBound</a> () const</td></tr>
<tr class="memdesc:ac45e45488fbd3eec22dfc62e9145a9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lower bound on the optimal solution of the subproblem.  <a href="#ac45e45488fbd3eec22dfc62e9145a9d8">More...</a><br /></td></tr>
<tr class="separator:ac45e45488fbd3eec22dfc62e9145a9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65afc40098dc0d4ed9638fe366b0efae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_lp_sub.html">LpSub</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a65afc40098dc0d4ed9638fe366b0efae">lp</a> () const</td></tr>
<tr class="memdesc:a65afc40098dc0d4ed9638fe366b0efae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the linear program of the subproblem.  <a href="#a65afc40098dc0d4ed9638fe366b0efae">More...</a><br /></td></tr>
<tr class="separator:a65afc40098dc0d4ed9638fe366b0efae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d51a569116411cdb082f9c8b32a26b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_l_p_v_a_r_s_t_a_t.html">LPVARSTAT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a25d51a569116411cdb082f9c8b32a26b">lpVarStat</a> (int i) const</td></tr>
<tr class="memdesc:a25d51a569116411cdb082f9c8b32a26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the status of the variable <em>i</em> in the last solved linear program.  <a href="#a25d51a569116411cdb082f9c8b32a26b">More...</a><br /></td></tr>
<tr class="separator:a25d51a569116411cdb082f9c8b32a26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef4a106b35486eee20ad545dcf956b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_master.html">Master</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#acef4a106b35486eee20ad545dcf956b6">master</a> ()</td></tr>
<tr class="memdesc:acef4a106b35486eee20ad545dcf956b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the master of the optimization.  <a href="#acef4a106b35486eee20ad545dcf956b6">More...</a><br /></td></tr>
<tr class="separator:acef4a106b35486eee20ad545dcf956b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6143a5d18cd5446523a465a1383bd05"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classabacus_1_1_master.html">Master</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ad6143a5d18cd5446523a465a1383bd05">master</a> () const</td></tr>
<tr class="memdesc:ad6143a5d18cd5446523a465a1383bd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the const master of the optimization.  <a href="#ad6143a5d18cd5446523a465a1383bd05">More...</a><br /></td></tr>
<tr class="separator:ad6143a5d18cd5446523a465a1383bd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44562162d12252db0defa7718f1336b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#af44562162d12252db0defa7718f1336b">maxCon</a> () const</td></tr>
<tr class="memdesc:af44562162d12252db0defa7718f1336b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of constraints which can be handled without reallocation.  <a href="#af44562162d12252db0defa7718f1336b">More...</a><br /></td></tr>
<tr class="separator:af44562162d12252db0defa7718f1336b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c5c15d639b7a56c8ccd950d1644df5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ae7c5c15d639b7a56c8ccd950d1644df5">maxIterations</a> (int max)</td></tr>
<tr class="memdesc:ae7c5c15d639b7a56c8ccd950d1644df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximal number of iterations in the cutting plane phase.  <a href="#ae7c5c15d639b7a56c8ccd950d1644df5">More...</a><br /></td></tr>
<tr class="separator:ae7c5c15d639b7a56c8ccd950d1644df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f3c3d1aa62a9f9834c4de6df9ec7e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a07f3c3d1aa62a9f9834c4de6df9ec7e4">maxVar</a> () const</td></tr>
<tr class="memdesc:a07f3c3d1aa62a9f9834c4de6df9ec7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of variables which can be handled without reallocation.  <a href="#a07f3c3d1aa62a9f9834c4de6df9ec7e4">More...</a><br /></td></tr>
<tr class="separator:a07f3c3d1aa62a9f9834c4de6df9ec7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc5c85feec629376510f8bc2d1585a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#abbc5c85feec629376510f8bc2d1585a8">nCon</a> () const</td></tr>
<tr class="memdesc:abbc5c85feec629376510f8bc2d1585a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of active constraints.  <a href="#abbc5c85feec629376510f8bc2d1585a8">More...</a><br /></td></tr>
<tr class="separator:abbc5c85feec629376510f8bc2d1585a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0686811c13e9c8d18fa40e1664a5496"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ac0686811c13e9c8d18fa40e1664a5496">nDormantRounds</a> () const</td></tr>
<tr class="separator:ac0686811c13e9c8d18fa40e1664a5496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77f15badcdab5335a865cacf0a6d9fd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aa77f15badcdab5335a865cacf0a6d9fd">nnzReserve</a> () const</td></tr>
<tr class="memdesc:aa77f15badcdab5335a865cacf0a6d9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the additional space for nonzero elements of the constraint matrix when it is passed to the LP-solver.  <a href="#aa77f15badcdab5335a865cacf0a6d9fd">More...</a><br /></td></tr>
<tr class="separator:aa77f15badcdab5335a865cacf0a6d9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c9b6ec6cc12fd1a51562f3340ee2d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ab8c9b6ec6cc12fd1a51562f3340ee2d5">nVar</a> () const</td></tr>
<tr class="memdesc:ab8c9b6ec6cc12fd1a51562f3340ee2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of active variables.  <a href="#ab8c9b6ec6cc12fd1a51562f3340ee2d5">More...</a><br /></td></tr>
<tr class="separator:ab8c9b6ec6cc12fd1a51562f3340ee2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c04bd3a7e82af81a0c12f8272f9bf88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a6c04bd3a7e82af81a0c12f8272f9bf88">objAllInteger</a> () const</td></tr>
<tr class="memdesc:a6c04bd3a7e82af81a0c12f8272f9bf88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if all active variables and objective function coefficients are integer.  <a href="#a6c04bd3a7e82af81a0c12f8272f9bf88">More...</a><br /></td></tr>
<tr class="separator:a6c04bd3a7e82af81a0c12f8272f9bf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a074666eb8fbcf5c98ad8500207a012"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a4a074666eb8fbcf5c98ad8500207a012">relativeReserve</a> () const</td></tr>
<tr class="separator:a4a074666eb8fbcf5c98ad8500207a012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c74b0dbce3008ebb66f9caa318cce3f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a0c74b0dbce3008ebb66f9caa318cce3f">removeCon</a> (int i)</td></tr>
<tr class="memdesc:a0c74b0dbce3008ebb66f9caa318cce3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a single constraint to the set of constraints which are removed from the active set at the beginning of the next iteration.  <a href="#a0c74b0dbce3008ebb66f9caa318cce3f">More...</a><br /></td></tr>
<tr class="separator:a0c74b0dbce3008ebb66f9caa318cce3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6b883a073f846d0a15bed605251326"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#abd6b883a073f846d0a15bed605251326">removeCons</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;remove)</td></tr>
<tr class="memdesc:abd6b883a073f846d0a15bed605251326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints to the buffer of the removed constraints.  <a href="#abd6b883a073f846d0a15bed605251326">More...</a><br /></td></tr>
<tr class="separator:abd6b883a073f846d0a15bed605251326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47c5813d504e46d2b3ab4f1c900acba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ae47c5813d504e46d2b3ab4f1c900acba">removeVar</a> (int i)</td></tr>
<tr class="memdesc:ae47c5813d504e46d2b3ab4f1c900acba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove variable <em>i</em> from the set of active variables.  <a href="#ae47c5813d504e46d2b3ab4f1c900acba">More...</a><br /></td></tr>
<tr class="separator:ae47c5813d504e46d2b3ab4f1c900acba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5dde1eba98c6ad2c40c9d352a480e43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ae5dde1eba98c6ad2c40c9d352a480e43">removeVars</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;remove)</td></tr>
<tr class="memdesc:ae5dde1eba98c6ad2c40c9d352a480e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the variables in <em>remove</em> from the set of active variables.  <a href="#ae5dde1eba98c6ad2c40c9d352a480e43">More...</a><br /></td></tr>
<tr class="separator:ae5dde1eba98c6ad2c40c9d352a480e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4a1006350c86b48eb4f0f4d5acc87c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_slack_stat.html">SlackStat</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#acb4a1006350c86b48eb4f0f4d5acc87c">slackStat</a> (int i) const</td></tr>
<tr class="memdesc:acb4a1006350c86b48eb4f0f4d5acc87c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the status of the slack variable <em>i</em> in the last solved linear program.  <a href="#acb4a1006350c86b48eb4f0f4d5acc87c">More...</a><br /></td></tr>
<tr class="separator:acb4a1006350c86b48eb4f0f4d5acc87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d98d1ebca0564df200ada33c8d1f2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_sub.html#a49aa228f17967fc8ac589b5fb7bc3297">STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ab4d98d1ebca0564df200ada33c8d1f2c">status</a> () const</td></tr>
<tr class="memdesc:ab4d98d1ebca0564df200ada33c8d1f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the status of the subproblem optimization.  <a href="#ab4d98d1ebca0564df200ada33c8d1f2c">More...</a><br /></td></tr>
<tr class="separator:ab4d98d1ebca0564df200ada33c8d1f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071c193c10af908b7643dea5afee67f1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a071c193c10af908b7643dea5afee67f1">uBound</a> (int i) const</td></tr>
<tr class="memdesc:a071c193c10af908b7643dea5afee67f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used to access the upper of an active variable of the subproblem.  <a href="#a071c193c10af908b7643dea5afee67f1">More...</a><br /></td></tr>
<tr class="separator:a071c193c10af908b7643dea5afee67f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb89c42e0413c8f11c9707d40b7e6df2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#acb89c42e0413c8f11c9707d40b7e6df2">uBound</a> (int i, double u)</td></tr>
<tr class="memdesc:acb89c42e0413c8f11c9707d40b7e6df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the local upper bound of variable <em>i</em> to <em>u</em>.  <a href="#acb89c42e0413c8f11c9707d40b7e6df2">More...</a><br /></td></tr>
<tr class="separator:acb89c42e0413c8f11c9707d40b7e6df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa461990f43ce14c6b2027e0b7aa819ae"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aa461990f43ce14c6b2027e0b7aa819ae">upperBound</a> () const</td></tr>
<tr class="memdesc:aa461990f43ce14c6b2027e0b7aa819ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an upper bound on the optimal solution of the subproblem.  <a href="#aa461990f43ce14c6b2027e0b7aa819ae">More...</a><br /></td></tr>
<tr class="separator:aa461990f43ce14c6b2027e0b7aa819ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7939f6fcf325cb0b5bb96cf0cea54773"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_variable.html">Variable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a7939f6fcf325cb0b5bb96cf0cea54773">variable</a> (int i) const</td></tr>
<tr class="memdesc:a7939f6fcf325cb0b5bb96cf0cea54773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the <em>i-th</em> active variable.  <a href="#a7939f6fcf325cb0b5bb96cf0cea54773">More...</a><br /></td></tr>
<tr class="separator:a7939f6fcf325cb0b5bb96cf0cea54773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae924b80497818945f96f8658d1394b45"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ae924b80497818945f96f8658d1394b45">xVal</a> (int i) const</td></tr>
<tr class="memdesc:ae924b80497818945f96f8658d1394b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the <em>i-th</em> variable in the last solved linear program.  <a href="#ae924b80497818945f96f8658d1394b45">More...</a><br /></td></tr>
<tr class="separator:ae924b80497818945f96f8658d1394b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ba9bc95672b5e054cdbc68f0af0c95"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a28ba9bc95672b5e054cdbc68f0af0c95">yVal</a> (int i) const</td></tr>
<tr class="memdesc:a28ba9bc95672b5e054cdbc68f0af0c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the <em>i-th</em> dual variable in the last solved linear program.  <a href="#a28ba9bc95672b5e054cdbc68f0af0c95">More...</a><br /></td></tr>
<tr class="separator:a28ba9bc95672b5e054cdbc68f0af0c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classabacus_1_1_abacus_root"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classabacus_1_1_abacus_root')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classabacus_1_1_abacus_root.html">abacus::AbacusRoot</a></td></tr>
<tr class="memitem:a91426fee38507bff91199b0302a1b77f inherit pub_methods_classabacus_1_1_abacus_root"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_abacus_root.html#a91426fee38507bff91199b0302a1b77f">~AbacusRoot</a> ()</td></tr>
<tr class="memdesc:a91426fee38507bff91199b0302a1b77f inherit pub_methods_classabacus_1_1_abacus_root"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor.  <a href="classabacus_1_1_abacus_root.html#a91426fee38507bff91199b0302a1b77f">More...</a><br /></td></tr>
<tr class="separator:a91426fee38507bff91199b0302a1b77f inherit pub_methods_classabacus_1_1_abacus_root"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae22a4eb3419a6665e28cbeb0b592bcba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ae22a4eb3419a6665e28cbeb0b592bcba">activate</a> ()</td></tr>
<tr class="memdesc:ae22a4eb3419a6665e28cbeb0b592bcba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used as an entrance point for problem specific activations.  <a href="#ae22a4eb3419a6665e28cbeb0b592bcba">More...</a><br /></td></tr>
<tr class="separator:ae22a4eb3419a6665e28cbeb0b592bcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ba1c129b6d87aee50dc45a36bb0db5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a89ba1c129b6d87aee50dc45a36bb0db5">addCons</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> *&gt; &amp;constraints, <a class="el" href="classabacus_1_1_pool.html">Pool</a>&lt; <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a> &gt; *pool=nullptr, <a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; bool &gt; *keepInPool=nullptr, <a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; double &gt; *rank=nullptr)</td></tr>
<tr class="memdesc:a89ba1c129b6d87aee50dc45a36bb0db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to add new constraints to the constraint buffer and a pool.  <a href="#a89ba1c129b6d87aee50dc45a36bb0db5">More...</a><br /></td></tr>
<tr class="separator:a89ba1c129b6d87aee50dc45a36bb0db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9623edf0d0714db06a39a477f55e3d3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ab9623edf0d0714db06a39a477f55e3d3">addCons</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_pool_slot.html">PoolSlot</a>&lt; <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a> &gt; *&gt; &amp;newCons)</td></tr>
<tr class="memdesc:ab9623edf0d0714db06a39a477f55e3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints to the active constraints and the linear program.  <a href="#ab9623edf0d0714db06a39a477f55e3d3">More...</a><br /></td></tr>
<tr class="separator:ab9623edf0d0714db06a39a477f55e3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f2926e01b7ef45d8acbe6f478ce293"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a47f2926e01b7ef45d8acbe6f478ce293">addVars</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a> *&gt; &amp;variables, <a class="el" href="classabacus_1_1_pool.html">Pool</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; *pool=nullptr, <a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; bool &gt; *keepInPool=nullptr, <a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; double &gt; *rank=nullptr)</td></tr>
<tr class="memdesc:a47f2926e01b7ef45d8acbe6f478ce293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to add new variables to the variable buffer and a pool.  <a href="#a47f2926e01b7ef45d8acbe6f478ce293">More...</a><br /></td></tr>
<tr class="separator:a47f2926e01b7ef45d8acbe6f478ce293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76c54f5d68d3137445bce5ec9675ab1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aa76c54f5d68d3137445bce5ec9675ab1">addVars</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_pool_slot.html">PoolSlot</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; *&gt; &amp;newVars)</td></tr>
<tr class="memdesc:aa76c54f5d68d3137445bce5ec9675ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds both the variables in <em>newVars</em> to the set of active variables and to the linear program of the subproblem.  <a href="#aa76c54f5d68d3137445bce5ec9675ab1">More...</a><br /></td></tr>
<tr class="separator:aa76c54f5d68d3137445bce5ec9675ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a2e6d38295199c8faf1cdafe19bd5a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ad4a2e6d38295199c8faf1cdafe19bd5a">basicConEliminate</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;remove)</td></tr>
<tr class="memdesc:ad4a2e6d38295199c8faf1cdafe19bd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves all dynamic constraints having basic slack variable.  <a href="#ad4a2e6d38295199c8faf1cdafe19bd5a">More...</a><br /></td></tr>
<tr class="separator:ad4a2e6d38295199c8faf1cdafe19bd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61092d362478ab614782ae600942762d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a61092d362478ab614782ae600942762d">betterDual</a> (double x) const</td></tr>
<tr class="memdesc:a61092d362478ab614782ae600942762d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <em>x</em> is better than the best known dual bound of the subproblem, false otherwise.  <a href="#a61092d362478ab614782ae600942762d">More...</a><br /></td></tr>
<tr class="separator:a61092d362478ab614782ae600942762d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3931b3ea0464ffff3b23cccc191b39a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a3931b3ea0464ffff3b23cccc191b39a3">boundCrash</a> () const</td></tr>
<tr class="memdesc:a3931b3ea0464ffff3b23cccc191b39a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the dual bound is worse than the best known primal bound, false otherwise.  <a href="#a3931b3ea0464ffff3b23cccc191b39a3">More...</a><br /></td></tr>
<tr class="separator:a3931b3ea0464ffff3b23cccc191b39a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e6b365d422803e6a0f8020e53576b3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classabacus_1_1_sub.html#aa9fe7d3a08b8ba4d97a8e4927178256e">PHASE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a63e6b365d422803e6a0f8020e53576b3">branching</a> ()</td></tr>
<tr class="memdesc:a63e6b365d422803e6a0f8020e53576b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs branching.  <a href="#a63e6b365d422803e6a0f8020e53576b3">More...</a><br /></td></tr>
<tr class="separator:a63e6b365d422803e6a0f8020e53576b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a77f2d3be3fd16e33ee1afc309e5d24"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a0a77f2d3be3fd16e33ee1afc309e5d24">branchingOnVariable</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a> *&gt; &amp;rules)</td></tr>
<tr class="memdesc:a0a77f2d3be3fd16e33ee1afc309e5d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates branching rules for two new subproblems by selecting a branching variable with the function <em><a class="el" href="classabacus_1_1_sub.html#a02aacd191c773efc09d75eaa810f81fd" title="Chooses a branching variable. ">selectBranchingVariable()</a></em>.  <a href="#a0a77f2d3be3fd16e33ee1afc309e5d24">More...</a><br /></td></tr>
<tr class="separator:a0a77f2d3be3fd16e33ee1afc309e5d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889be067e2a76eead7f19a8c4a6a2ce2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classabacus_1_1_l_p.html#a80d390b461dca15f5aba8068995b0063">LP::METHOD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a889be067e2a76eead7f19a8c4a6a2ce2">chooseLpMethod</a> (int nVarRemoved, int nConRemoved, int nVarAdded, int nConAdded)</td></tr>
<tr class="memdesc:a889be067e2a76eead7f19a8c4a6a2ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the method used to solve a linear programming relaxation.  <a href="#a889be067e2a76eead7f19a8c4a6a2ce2">More...</a><br /></td></tr>
<tr class="separator:a889be067e2a76eead7f19a8c4a6a2ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe81fab62b5a2254f5012db64d457358"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#abe81fab62b5a2254f5012db64d457358">closeHalf</a> (int &amp;branchVar, <a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499">VarType::TYPE</a> branchVarType)</td></tr>
<tr class="memdesc:abe81fab62b5a2254f5012db64d457358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a branching variable of type <em>branchVarType</em>, with fraction as close to \(0.5\) as possible.  <a href="#abe81fab62b5a2254f5012db64d457358">More...</a><br /></td></tr>
<tr class="separator:abe81fab62b5a2254f5012db64d457358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e55fb194778da501e8c03efa631f541"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a2e55fb194778da501e8c03efa631f541">closeHalf</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;branchVar, <a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499">VarType::TYPE</a> branchVarType)</td></tr>
<tr class="memdesc:a2e55fb194778da501e8c03efa631f541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches searches several possible branching variable of type <em>branchVarType</em>, with fraction as close to \(0.5\) as possible.  <a href="#a2e55fb194778da501e8c03efa631f541">More...</a><br /></td></tr>
<tr class="separator:a2e55fb194778da501e8c03efa631f541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafd465c112581df369e86693195e8ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#abafd465c112581df369e86693195e8ae">closeHalfExpensive</a> (int &amp;branchVar, <a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499">VarType::TYPE</a> branchVarType)</td></tr>
<tr class="memdesc:abafd465c112581df369e86693195e8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects a single branching variable of type <em>branchVarType</em>, with fractional part close to \(0.5\) and high absolute objective function coefficient.  <a href="#abafd465c112581df369e86693195e8ae">More...</a><br /></td></tr>
<tr class="separator:abafd465c112581df369e86693195e8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae633fe804712ea37fa83a046cd47cc40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ae633fe804712ea37fa83a046cd47cc40">closeHalfExpensive</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;variables, <a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499">VarType::TYPE</a> branchVarType)</td></tr>
<tr class="memdesc:ae633fe804712ea37fa83a046cd47cc40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects several candidates for branching variables of type <em>branchVarType</em>.  <a href="#ae633fe804712ea37fa83a046cd47cc40">More...</a><br /></td></tr>
<tr class="separator:ae633fe804712ea37fa83a046cd47cc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5069c072c786c83e3db9ad322730e0bd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a5069c072c786c83e3db9ad322730e0bd">compareBranchingSampleRanks</a> (<a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;rank1, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;rank2)</td></tr>
<tr class="memdesc:a5069c072c786c83e3db9ad322730e0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the ranks of two branching samples.  <a href="#a5069c072c786c83e3db9ad322730e0bd">More...</a><br /></td></tr>
<tr class="separator:a5069c072c786c83e3db9ad322730e0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de91731faf1ec85059209adec248125"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a3de91731faf1ec85059209adec248125">conEliminate</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;remove)</td></tr>
<tr class="memdesc:a3de91731faf1ec85059209adec248125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used as an entry point for application specific elimination of constraints.  <a href="#a3de91731faf1ec85059209adec248125">More...</a><br /></td></tr>
<tr class="separator:a3de91731faf1ec85059209adec248125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26712852d933c7ce5e04bb07e16ad00e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a26712852d933c7ce5e04bb07e16ad00e">conRealloc</a> (int newSize)</td></tr>
<tr class="memdesc:a26712852d933c7ce5e04bb07e16ad00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates memory that at most <em>newSize</em> constraints can be handled in the subproblem.  <a href="#a26712852d933c7ce5e04bb07e16ad00e">More...</a><br /></td></tr>
<tr class="separator:a26712852d933c7ce5e04bb07e16ad00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4dd78fb330f3494b43349c10c57cd62"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ac4dd78fb330f3494b43349c10c57cd62">constraintPoolSeparation</a> (int ranking=0, <a class="el" href="classabacus_1_1_pool.html">Pool</a>&lt; <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a> &gt; *pool=nullptr, double minViolation=0.001)</td></tr>
<tr class="memdesc:ac4dd78fb330f3494b43349c10c57cd62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to generate inactive constraints from a pool.  <a href="#ac4dd78fb330f3494b43349c10c57cd62">More...</a><br /></td></tr>
<tr class="separator:ac4dd78fb330f3494b43349c10c57cd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c42546387f8d877a3886282baea8051"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classabacus_1_1_sub.html#aa9fe7d3a08b8ba4d97a8e4927178256e">PHASE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a3c42546387f8d877a3886282baea8051">cutting</a> ()</td></tr>
<tr class="memdesc:a3c42546387f8d877a3886282baea8051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratively solves the LP-relaxation, generates constraints and/or variables.  <a href="#a3c42546387f8d877a3886282baea8051">More...</a><br /></td></tr>
<tr class="separator:a3c42546387f8d877a3886282baea8051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3738dfb4be5571ddc4bbd5b1b4afe9f0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a3738dfb4be5571ddc4bbd5b1b4afe9f0">deactivate</a> ()</td></tr>
<tr class="memdesc:a3738dfb4be5571ddc4bbd5b1b4afe9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used as entrance point for problem specific deactivations after the subproblem optimization.  <a href="#a3738dfb4be5571ddc4bbd5b1b4afe9f0">More...</a><br /></td></tr>
<tr class="separator:a3738dfb4be5571ddc4bbd5b1b4afe9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83bd3cd76a57c50870da3fbf130eb85"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#af83bd3cd76a57c50870da3fbf130eb85">dualRound</a> (double x)</td></tr>
<tr class="separator:af83bd3cd76a57c50870da3fbf130eb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a8853e72d40dc7177c2a775cad1669"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a63a8853e72d40dc7177c2a775cad1669">exceptionBranch</a> ()</td></tr>
<tr class="memdesc:a63a8853e72d40dc7177c2a775cad1669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used to specify a problem specific criteria for enforcing a branching step.  <a href="#a63a8853e72d40dc7177c2a775cad1669">More...</a><br /></td></tr>
<tr class="separator:a63a8853e72d40dc7177c2a775cad1669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94768c41fb19ce07d9e6fbfcd16c4564"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a94768c41fb19ce07d9e6fbfcd16c4564">exceptionFathom</a> ()</td></tr>
<tr class="memdesc:a94768c41fb19ce07d9e6fbfcd16c4564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used to specify a problem specific fathoming criterium that is checked before the separation or pricing.  <a href="#a94768c41fb19ce07d9e6fbfcd16c4564">More...</a><br /></td></tr>
<tr class="separator:a94768c41fb19ce07d9e6fbfcd16c4564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da75b4e2968be2d260fef3635b4e08a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a1da75b4e2968be2d260fef3635b4e08a">fathom</a> (bool <a class="el" href="classabacus_1_1_sub.html#a7dd477fadcb66cda3b11f4d4d462f516">reoptimize</a>)</td></tr>
<tr class="memdesc:a1da75b4e2968be2d260fef3635b4e08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fathoms a node and recursively tries to fathom its father.  <a href="#a1da75b4e2968be2d260fef3635b4e08a">More...</a><br /></td></tr>
<tr class="separator:a1da75b4e2968be2d260fef3635b4e08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e70257891b0fc53557bfd32a07e0649"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classabacus_1_1_sub.html#aa9fe7d3a08b8ba4d97a8e4927178256e">PHASE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a8e70257891b0fc53557bfd32a07e0649">fathoming</a> ()</td></tr>
<tr class="memdesc:a8e70257891b0fc53557bfd32a07e0649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fathoms the node, and if certain conditions are satisfied, also its ancestor.  <a href="#a8e70257891b0fc53557bfd32a07e0649">More...</a><br /></td></tr>
<tr class="separator:a8e70257891b0fc53557bfd32a07e0649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc79787a7be7c11797db7b608587da00"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#adc79787a7be7c11797db7b608587da00">fathomTheSubTree</a> ()</td></tr>
<tr class="memdesc:adc79787a7be7c11797db7b608587da00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fathoms all nodes in the subtree rooted at this subproblem.  <a href="#adc79787a7be7c11797db7b608587da00">More...</a><br /></td></tr>
<tr class="separator:adc79787a7be7c11797db7b608587da00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef66b56a1aa2069cd9676c0d8ae2a3c8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aef66b56a1aa2069cd9676c0d8ae2a3c8">feasible</a> ()=0</td></tr>
<tr class="memdesc:aef66b56a1aa2069cd9676c0d8ae2a3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must check the feasibility of a solution of the LP-relaxation.  <a href="#aef66b56a1aa2069cd9676c0d8ae2a3c8">More...</a><br /></td></tr>
<tr class="separator:aef66b56a1aa2069cd9676c0d8ae2a3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732025b90331ed19140ef4bb9b72bb7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a732025b90331ed19140ef4bb9b72bb7d">findNonFixedSet</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;branchVar, <a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499">VarType::TYPE</a> branchVarType)</td></tr>
<tr class="memdesc:a732025b90331ed19140ef4bb9b72bb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the first variables that are neither fixed nor set.  <a href="#a732025b90331ed19140ef4bb9b72bb7d">More...</a><br /></td></tr>
<tr class="separator:a732025b90331ed19140ef4bb9b72bb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7891d14913788495c2b714a56e4a4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a7f7891d14913788495c2b714a56e4a4a">findNonFixedSet</a> (int &amp;branchVar, <a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499">VarType::TYPE</a> branchVarType)</td></tr>
<tr class="memdesc:a7f7891d14913788495c2b714a56e4a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the first variable that is neither fixed nor set.  <a href="#a7f7891d14913788495c2b714a56e4a4a">More...</a><br /></td></tr>
<tr class="separator:a7f7891d14913788495c2b714a56e4a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab198d2caec6321608bc5caecf8691e3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aab198d2caec6321608bc5caecf8691e3">fix</a> (int i, <a class="el" href="classabacus_1_1_f_s_var_stat.html">FSVarStat</a> *newStat, bool &amp;newValue)</td></tr>
<tr class="memdesc:aab198d2caec6321608bc5caecf8691e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixes a variable.  <a href="#aab198d2caec6321608bc5caecf8691e3">More...</a><br /></td></tr>
<tr class="separator:aab198d2caec6321608bc5caecf8691e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36040e50ff2659d8990afb0626d130b7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a36040e50ff2659d8990afb0626d130b7">fixAndSet</a> (bool &amp;newValues)</td></tr>
<tr class="memdesc:a36040e50ff2659d8990afb0626d130b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to fix and set variables both by logical implications and reduced cost criteria.  <a href="#a36040e50ff2659d8990afb0626d130b7">More...</a><br /></td></tr>
<tr class="separator:a36040e50ff2659d8990afb0626d130b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3353315f00b3bfcfa103dfe6ef93748"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ae3353315f00b3bfcfa103dfe6ef93748">fixAndSetTime</a> ()</td></tr>
<tr class="memdesc:ae3353315f00b3bfcfa103dfe6ef93748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls if variables should be fixed or set when all variables price out correctly.  <a href="#ae3353315f00b3bfcfa103dfe6ef93748">More...</a><br /></td></tr>
<tr class="separator:ae3353315f00b3bfcfa103dfe6ef93748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ceae0290ba087243d4e265006a1b0c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ae2ceae0290ba087243d4e265006a1b0c">fixByLogImp</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;variables, <a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_f_s_var_stat.html">FSVarStat</a> *&gt; &amp;<a class="el" href="classabacus_1_1_sub.html#ab4d98d1ebca0564df200ada33c8d1f2c">status</a>)</td></tr>
<tr class="memdesc:ae2ceae0290ba087243d4e265006a1b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should collect the numbers of the variables to be fixed in <em>variable</em> and the respective statuses in <em>status</em>.  <a href="#ae2ceae0290ba087243d4e265006a1b0c">More...</a><br /></td></tr>
<tr class="separator:ae2ceae0290ba087243d4e265006a1b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356eb76abe3c3eafe11267e087f81cc2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a356eb76abe3c3eafe11267e087f81cc2">fixByRedCost</a> (bool &amp;newValues, bool saveCand)</td></tr>
<tr class="memdesc:a356eb76abe3c3eafe11267e087f81cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to fix variables according to the reduced cost criterion.  <a href="#a356eb76abe3c3eafe11267e087f81cc2">More...</a><br /></td></tr>
<tr class="separator:a356eb76abe3c3eafe11267e087f81cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28743afe6f5292c150ad6b6708aca2a5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a28743afe6f5292c150ad6b6708aca2a5">fixing</a> (bool &amp;newValues, bool saveCand=false)</td></tr>
<tr class="memdesc:a28743afe6f5292c150ad6b6708aca2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to fix variables by reduced cost criteria and logical implications.  <a href="#a28743afe6f5292c150ad6b6708aca2a5">More...</a><br /></td></tr>
<tr class="separator:a28743afe6f5292c150ad6b6708aca2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37388e582ebbc4c6f303ad9a60bcd8a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ae37388e582ebbc4c6f303ad9a60bcd8a">generateBranchRules</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a> *&gt; &amp;rules)</td></tr>
<tr class="memdesc:ae37388e582ebbc4c6f303ad9a60bcd8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find rules for splitting the current subproblem in further subproblems.  <a href="#ae37388e582ebbc4c6f303ad9a60bcd8a">More...</a><br /></td></tr>
<tr class="separator:ae37388e582ebbc4c6f303ad9a60bcd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbc981714ace71da11273cd2ab30389"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classabacus_1_1_lp_sub.html">LpSub</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a7cbc981714ace71da11273cd2ab30389">generateLp</a> ()</td></tr>
<tr class="memdesc:a7cbc981714ace71da11273cd2ab30389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates an <em><a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a></em> for the solution of the <em>LP-relaxation</em> in this subproblem.  <a href="#a7cbc981714ace71da11273cd2ab30389">More...</a><br /></td></tr>
<tr class="separator:a7cbc981714ace71da11273cd2ab30389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa252b9d1b9d6d0bd844fd292883bb29a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classabacus_1_1_sub.html">Sub</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aa252b9d1b9d6d0bd844fd292883bb29a">generateSon</a> (<a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a> *rule)=0</td></tr>
<tr class="memdesc:aa252b9d1b9d6d0bd844fd292883bb29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to an object of a problem specific subproblem, which is generated from the current subproblem by branching rule <em>rule</em>.  <a href="#aa252b9d1b9d6d0bd844fd292883bb29a">More...</a><br /></td></tr>
<tr class="separator:aa252b9d1b9d6d0bd844fd292883bb29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf90413f54f6b222b47128fb612e4f6c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#acf90413f54f6b222b47128fb612e4f6c">goodCol</a> (<a class="el" href="classabacus_1_1_column.html">Column</a> &amp;col, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;row, double x, double lb, double ub)</td></tr>
<tr class="separator:acf90413f54f6b222b47128fb612e4f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50d9403f536bb35c92fc6542c4a5ca2"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ae50d9403f536bb35c92fc6542c4a5ca2">guarantee</a> () const</td></tr>
<tr class="memdesc:ae50d9403f536bb35c92fc6542c4a5ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">May not be called if the lower bound is 0 and upper bound not equal to 0.  <a href="#ae50d9403f536bb35c92fc6542c4a5ca2">More...</a><br /></td></tr>
<tr class="separator:ae50d9403f536bb35c92fc6542c4a5ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44c6552a2cd18a343c44fcb29dbe9af"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#af44c6552a2cd18a343c44fcb29dbe9af">guaranteed</a> () const</td></tr>
<tr class="separator:af44c6552a2cd18a343c44fcb29dbe9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6b6ba861ffe427b587f43047e73420"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a4c6b6ba861ffe427b587f43047e73420">improve</a> (double &amp;primalValue)</td></tr>
<tr class="memdesc:a4c6b6ba861ffe427b587f43047e73420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be redefined in order to implement primal heuristics for finding feasible solutions.  <a href="#a4c6b6ba861ffe427b587f43047e73420">More...</a><br /></td></tr>
<tr class="separator:a4c6b6ba861ffe427b587f43047e73420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb1bdd6273fc1ef629824c83cd046bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a0cb1bdd6273fc1ef629824c83cd046bf">infeasible</a> ()</td></tr>
<tr class="memdesc:a0cb1bdd6273fc1ef629824c83cd046bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the subproblem does not contain a feasible solution, false otherwise.  <a href="#a0cb1bdd6273fc1ef629824c83cd046bf">More...</a><br /></td></tr>
<tr class="separator:a0cb1bdd6273fc1ef629824c83cd046bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b51158c54bba3fd22b5258fced69bb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a24b51158c54bba3fd22b5258fced69bb">initializeCons</a> (int <a class="el" href="classabacus_1_1_sub.html#af44562162d12252db0defa7718f1336b">maxCon</a>)</td></tr>
<tr class="memdesc:a24b51158c54bba3fd22b5258fced69bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the active constraint set.  <a href="#a24b51158c54bba3fd22b5258fced69bb">More...</a><br /></td></tr>
<tr class="separator:a24b51158c54bba3fd22b5258fced69bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d1340ac33a6fd33516309aa75275d1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a73d1340ac33a6fd33516309aa75275d1">initializeLp</a> ()</td></tr>
<tr class="memdesc:a73d1340ac33a6fd33516309aa75275d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the linear program.  <a href="#a73d1340ac33a6fd33516309aa75275d1">More...</a><br /></td></tr>
<tr class="separator:a73d1340ac33a6fd33516309aa75275d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb2af166e8ab4dfe3390da9fd296455"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a8eb2af166e8ab4dfe3390da9fd296455">initializeVars</a> (int <a class="el" href="classabacus_1_1_sub.html#a07f3c3d1aa62a9f9834c4de6df9ec7e4">maxVar</a>)</td></tr>
<tr class="memdesc:a8eb2af166e8ab4dfe3390da9fd296455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the active variable set.  <a href="#a8eb2af166e8ab4dfe3390da9fd296455">More...</a><br /></td></tr>
<tr class="separator:a8eb2af166e8ab4dfe3390da9fd296455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2211b5377d19d6863fddfe1ad7ec558d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a2211b5377d19d6863fddfe1ad7ec558d">initMakeFeas</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_infeas_con.html">InfeasCon</a> *&gt; &amp;infeasCon, <a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a> *&gt; &amp;newVars, <a class="el" href="classabacus_1_1_pool.html">Pool</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; **pool)</td></tr>
<tr class="memdesc:a2211b5377d19d6863fddfe1ad7ec558d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default implementation of the virtual <em><a class="el" href="classabacus_1_1_sub.html#a2211b5377d19d6863fddfe1ad7ec558d" title="The default implementation of the virtual initMakeFeas() does nothing. ">initMakeFeas()</a></em> does nothing.  <a href="#a2211b5377d19d6863fddfe1ad7ec558d">More...</a><br /></td></tr>
<tr class="separator:a2211b5377d19d6863fddfe1ad7ec558d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1463bb7807f513afee25ce55593bcc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aa1463bb7807f513afee25ce55593bcc3">integerFeasible</a> ()</td></tr>
<tr class="memdesc:aa1463bb7807f513afee25ce55593bcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used to check if the solution of the LP-relaxation is primally feasible if integrality is suficinet.  <a href="#aa1463bb7807f513afee25ce55593bcc3">More...</a><br /></td></tr>
<tr class="separator:aa1463bb7807f513afee25ce55593bcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a9e0f1ee671a49f0d0febb4c5a3b8d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ac9a9e0f1ee671a49f0d0febb4c5a3b8d">lpRankBranchingRule</a> (<a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a> *<a class="el" href="classabacus_1_1_sub.html#a73a26e269e8af3c052b7c76ade24b1a9">branchRule</a>, int iterLimit=-1)</td></tr>
<tr class="memdesc:ac9a9e0f1ee671a49f0d0febb4c5a3b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rank of a branching rule by modifying the linear programming relaxation of the subproblem according to the branching rule and solving it.  <a href="#ac9a9e0f1ee671a49f0d0febb4c5a3b8d">More...</a><br /></td></tr>
<tr class="separator:ac9a9e0f1ee671a49f0d0febb4c5a3b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02304f8dd7d726523507b91ad04ed306"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a02304f8dd7d726523507b91ad04ed306">makeFeasible</a> ()</td></tr>
<tr class="memdesc:a02304f8dd7d726523507b91ad04ed306"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default implementation of <em><a class="el" href="classabacus_1_1_sub.html#a02304f8dd7d726523507b91ad04ed306" title="The default implementation of makeFeasible()does nothing. ">makeFeasible()</a>does</em> nothing.  <a href="#a02304f8dd7d726523507b91ad04ed306">More...</a><br /></td></tr>
<tr class="separator:a02304f8dd7d726523507b91ad04ed306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa2ac08974bc4f8be27290a32fa9ee7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a2aa2ac08974bc4f8be27290a32fa9ee7">nonBindingConEliminate</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;remove)</td></tr>
<tr class="memdesc:a2aa2ac08974bc4f8be27290a32fa9ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the dynamic constraints with slack exceeding the value given by the parameter <code>ConElimEps</code>.  <a href="#a2aa2ac08974bc4f8be27290a32fa9ee7">More...</a><br /></td></tr>
<tr class="separator:a2aa2ac08974bc4f8be27290a32fa9ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8256c74d20333b9f24e2808d93d76d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a7d8256c74d20333b9f24e2808d93d76d">optimize</a> ()</td></tr>
<tr class="memdesc:a7d8256c74d20333b9f24e2808d93d76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the optimization of the subproblem.  <a href="#a7d8256c74d20333b9f24e2808d93d76d">More...</a><br /></td></tr>
<tr class="separator:a7d8256c74d20333b9f24e2808d93d76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecb2914ee0193c6fb278973a31bbcc0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a9ecb2914ee0193c6fb278973a31bbcc0">pausing</a> ()</td></tr>
<tr class="memdesc:a9ecb2914ee0193c6fb278973a31bbcc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sometimes it is appropriate to put a subproblem back into the list of open subproblems.  <a href="#a9ecb2914ee0193c6fb278973a31bbcc0">More...</a><br /></td></tr>
<tr class="separator:a9ecb2914ee0193c6fb278973a31bbcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdab7e4b5981335e38b9090da5d4a51a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#acdab7e4b5981335e38b9090da5d4a51a">prepareBranching</a> (bool &amp;lastIteration)</td></tr>
<tr class="memdesc:acdab7e4b5981335e38b9090da5d4a51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is called before a branching step to remove constraints.  <a href="#acdab7e4b5981335e38b9090da5d4a51a">More...</a><br /></td></tr>
<tr class="separator:acdab7e4b5981335e38b9090da5d4a51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d683e41039bae1b2c266ef25352fb4e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a7d683e41039bae1b2c266ef25352fb4e">pricing</a> ()</td></tr>
<tr class="memdesc:a7d683e41039bae1b2c266ef25352fb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should generate inactive variables which do not price out correctly.  <a href="#a7d683e41039bae1b2c266ef25352fb4e">More...</a><br /></td></tr>
<tr class="separator:a7d683e41039bae1b2c266ef25352fb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324277f9c5ea2f36682f087841726d22"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a324277f9c5ea2f36682f087841726d22">primalSeparation</a> ()</td></tr>
<tr class="memdesc:a324277f9c5ea2f36682f087841726d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls if during the cutting plane phase a (primal) separation step or a pricing step (dual separation) should be performed.  <a href="#a324277f9c5ea2f36682f087841726d22">More...</a><br /></td></tr>
<tr class="separator:a324277f9c5ea2f36682f087841726d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc89a32429cf1139034e9c2489c08e9"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a3dc89a32429cf1139034e9c2489c08e9">rankBranchingRule</a> (<a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a> *<a class="el" href="classabacus_1_1_sub.html#a73a26e269e8af3c052b7c76ade24b1a9">branchRule</a>)</td></tr>
<tr class="memdesc:a3dc89a32429cf1139034e9c2489c08e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rank of a branching rule.  <a href="#a3dc89a32429cf1139034e9c2489c08e9">More...</a><br /></td></tr>
<tr class="separator:a3dc89a32429cf1139034e9c2489c08e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883a8df946d44494be003f73b581e3d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a883a8df946d44494be003f73b581e3d4">rankBranchingSample</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a> *&gt; &amp;sample, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;rank)</td></tr>
<tr class="memdesc:a883a8df946d44494be003f73b581e3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes for each branching rule of a branching sample a rank with the function <em><a class="el" href="classabacus_1_1_sub.html#a3dc89a32429cf1139034e9c2489c08e9" title="Computes the rank of a branching rule. ">rankBranchingRule()</a></em>.  <a href="#a883a8df946d44494be003f73b581e3d4">More...</a><br /></td></tr>
<tr class="separator:a883a8df946d44494be003f73b581e3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3e6e24e11921064297c78891fc7316"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a6f3e6e24e11921064297c78891fc7316">redCostVarEliminate</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;remove)</td></tr>
<tr class="memdesc:a6f3e6e24e11921064297c78891fc7316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves all variables with "wrong" reduced costs.  <a href="#a6f3e6e24e11921064297c78891fc7316">More...</a><br /></td></tr>
<tr class="separator:a6f3e6e24e11921064297c78891fc7316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6657fd8f00ad76e44a60b9dc1a8c6d4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ae6657fd8f00ad76e44a60b9dc1a8c6d4">removeNonLiftableCons</a> ()</td></tr>
<tr class="separator:ae6657fd8f00ad76e44a60b9dc1a8c6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd477fadcb66cda3b11f4d4d462f516"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a7dd477fadcb66cda3b11f4d4d462f516">reoptimize</a> ()</td></tr>
<tr class="memdesc:a7dd477fadcb66cda3b11f4d4d462f516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeats the optimization of an already optimized subproblem.  <a href="#a7dd477fadcb66cda3b11f4d4d462f516">More...</a><br /></td></tr>
<tr class="separator:a7dd477fadcb66cda3b11f4d4d462f516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521efb5513b6086312192b6e9b29c528"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a521efb5513b6086312192b6e9b29c528">selectBestBranchingSample</a> (int nSamples, <a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a> *&gt; **samples)</td></tr>
<tr class="memdesc:a521efb5513b6086312192b6e9b29c528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates branching samples.  <a href="#a521efb5513b6086312192b6e9b29c528">More...</a><br /></td></tr>
<tr class="separator:a521efb5513b6086312192b6e9b29c528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02aacd191c773efc09d75eaa810f81fd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a02aacd191c773efc09d75eaa810f81fd">selectBranchingVariable</a> (int &amp;<a class="el" href="classabacus_1_1_sub.html#a7939f6fcf325cb0b5bb96cf0cea54773">variable</a>)</td></tr>
<tr class="memdesc:a02aacd191c773efc09d75eaa810f81fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses a branching variable.  <a href="#a02aacd191c773efc09d75eaa810f81fd">More...</a><br /></td></tr>
<tr class="separator:a02aacd191c773efc09d75eaa810f81fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d04080b6f001627ecb9119a150b811c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a2d04080b6f001627ecb9119a150b811c">selectBranchingVariableCandidates</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;candidates)</td></tr>
<tr class="memdesc:a2d04080b6f001627ecb9119a150b811c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects candidates for branching variables.  <a href="#a2d04080b6f001627ecb9119a150b811c">More...</a><br /></td></tr>
<tr class="separator:a2d04080b6f001627ecb9119a150b811c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f9fd4634aa0b70e3ffef3b1c0a76ff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a74f9fd4634aa0b70e3ffef3b1c0a76ff">selectCons</a> ()</td></tr>
<tr class="memdesc:a74f9fd4634aa0b70e3ffef3b1c0a76ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is called before constraint are selected from the constraint buffer.  <a href="#a74f9fd4634aa0b70e3ffef3b1c0a76ff">More...</a><br /></td></tr>
<tr class="separator:a74f9fd4634aa0b70e3ffef3b1c0a76ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54754a8f1cbb344825cfc45492114e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aa54754a8f1cbb344825cfc45492114e7">selectVars</a> ()</td></tr>
<tr class="memdesc:aa54754a8f1cbb344825cfc45492114e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is called before variables are selected from the variable buffer.  <a href="#aa54754a8f1cbb344825cfc45492114e7">More...</a><br /></td></tr>
<tr class="separator:aa54754a8f1cbb344825cfc45492114e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8bd1dfbc1944934caeaa43ea3e43b8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a1e8bd1dfbc1944934caeaa43ea3e43b8">separate</a> ()</td></tr>
<tr class="memdesc:a1e8bd1dfbc1944934caeaa43ea3e43b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be redefined in derived classes for the generation of cutting planes.  <a href="#a1e8bd1dfbc1944934caeaa43ea3e43b8">More...</a><br /></td></tr>
<tr class="separator:a1e8bd1dfbc1944934caeaa43ea3e43b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac5130d4b5374cd8b8951aa9c074d9b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#acac5130d4b5374cd8b8951aa9c074d9b">set</a> (int i, <a class="el" href="classabacus_1_1_f_s_var_stat.html">FSVarStat</a> *newStat, bool &amp;newValue)</td></tr>
<tr class="memdesc:acac5130d4b5374cd8b8951aa9c074d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a variable.  <a href="#acac5130d4b5374cd8b8951aa9c074d9b">More...</a><br /></td></tr>
<tr class="separator:acac5130d4b5374cd8b8951aa9c074d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668e20f3c1ce17ca355aea69894a1edd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a668e20f3c1ce17ca355aea69894a1edd">set</a> (int i, <a class="el" href="classabacus_1_1_f_s_var_stat.html#a0b174a15f4bfd9c3a20cbd3ccc0efbb9">FSVarStat::STATUS</a> newStat, bool &amp;newValue)</td></tr>
<tr class="memdesc:a668e20f3c1ce17ca355aea69894a1edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a variable.  <a href="#a668e20f3c1ce17ca355aea69894a1edd">More...</a><br /></td></tr>
<tr class="separator:a668e20f3c1ce17ca355aea69894a1edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48db8ebb4354d6012a3a2951a1dd3c8c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a48db8ebb4354d6012a3a2951a1dd3c8c">set</a> (int i, <a class="el" href="classabacus_1_1_f_s_var_stat.html#a0b174a15f4bfd9c3a20cbd3ccc0efbb9">FSVarStat::STATUS</a> newStat, double value, bool &amp;newValue)</td></tr>
<tr class="memdesc:a48db8ebb4354d6012a3a2951a1dd3c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a variable.  <a href="#a48db8ebb4354d6012a3a2951a1dd3c8c">More...</a><br /></td></tr>
<tr class="separator:a48db8ebb4354d6012a3a2951a1dd3c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e4677db92404769c2a075702ae77ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a29e4677db92404769c2a075702ae77ef">setByLogImp</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;<a class="el" href="classabacus_1_1_sub.html#a7939f6fcf325cb0b5bb96cf0cea54773">variable</a>, <a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_f_s_var_stat.html">FSVarStat</a> *&gt; &amp;<a class="el" href="classabacus_1_1_sub.html#ab4d98d1ebca0564df200ada33c8d1f2c">status</a>)</td></tr>
<tr class="memdesc:a29e4677db92404769c2a075702ae77ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default implementation of <em><a class="el" href="classabacus_1_1_sub.html#a29e4677db92404769c2a075702ae77ef" title="The default implementation of setByLogImp() does nothing. ">setByLogImp()</a></em> does nothing.  <a href="#a29e4677db92404769c2a075702ae77ef">More...</a><br /></td></tr>
<tr class="separator:a29e4677db92404769c2a075702ae77ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f9bbab838f2ca4d36a75f5e93f1c90"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ad1f9bbab838f2ca4d36a75f5e93f1c90">setByRedCost</a> ()</td></tr>
<tr class="memdesc:ad1f9bbab838f2ca4d36a75f5e93f1c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to set variables according to the reduced cost criterion.  <a href="#ad1f9bbab838f2ca4d36a75f5e93f1c90">More...</a><br /></td></tr>
<tr class="separator:ad1f9bbab838f2ca4d36a75f5e93f1c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb506ab5dd3d08e03cef11d805a31537"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aeb506ab5dd3d08e03cef11d805a31537">setting</a> (bool &amp;newValues)</td></tr>
<tr class="memdesc:aeb506ab5dd3d08e03cef11d805a31537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to set variables by reduced cost criteria and logical implications like <em><a class="el" href="classabacus_1_1_sub.html#a28743afe6f5292c150ad6b6708aca2a5" title="Tries to fix variables by reduced cost criteria and logical implications. ">fixing()</a></em>.  <a href="#aeb506ab5dd3d08e03cef11d805a31537">More...</a><br /></td></tr>
<tr class="separator:aeb506ab5dd3d08e03cef11d805a31537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c56c94f842adef22f52e150c337c50"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ad1c56c94f842adef22f52e150c337c50">solveApproxNow</a> ()</td></tr>
<tr class="memdesc:ad1c56c94f842adef22f52e150c337c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default implementation always returns false.  <a href="#ad1c56c94f842adef22f52e150c337c50">More...</a><br /></td></tr>
<tr class="separator:ad1c56c94f842adef22f52e150c337c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba415669914df13a57b5c10477672e0d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aba415669914df13a57b5c10477672e0d">solveLp</a> ()</td></tr>
<tr class="memdesc:aba415669914df13a57b5c10477672e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the LP-relaxation of the subproblem.  <a href="#aba415669914df13a57b5c10477672e0d">More...</a><br /></td></tr>
<tr class="separator:aba415669914df13a57b5c10477672e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2f9a7f911e7f65369770320c59c2a3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a0e2f9a7f911e7f65369770320c59c2a3">tailingOff</a> ()</td></tr>
<tr class="memdesc:a0e2f9a7f911e7f65369770320c59c2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a tailing off effect according to the parameters <code>TailOffPercent</code> and <code>TailOffNLps</code> is observed.  <a href="#a0e2f9a7f911e7f65369770320c59c2a3">More...</a><br /></td></tr>
<tr class="separator:a0e2f9a7f911e7f65369770320c59c2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591534e443fdba749329af01b468cf70"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a591534e443fdba749329af01b468cf70">varEliminate</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;remove)</td></tr>
<tr class="memdesc:a591534e443fdba749329af01b468cf70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for application specific variable elimination.  <a href="#a591534e443fdba749329af01b468cf70">More...</a><br /></td></tr>
<tr class="separator:a591534e443fdba749329af01b468cf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdff593017388db94d300c5240fd3186"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#abdff593017388db94d300c5240fd3186">variablePoolSeparation</a> (int ranking=0, <a class="el" href="classabacus_1_1_pool.html">Pool</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; *pool=nullptr, double minViolation=0.001)</td></tr>
<tr class="memdesc:abdff593017388db94d300c5240fd3186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to generate inactive variables from a pool.  <a href="#abdff593017388db94d300c5240fd3186">More...</a><br /></td></tr>
<tr class="separator:abdff593017388db94d300c5240fd3186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfc781df11fed36a633a551e394e6e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#acdfc781df11fed36a633a551e394e6e9">varRealloc</a> (int newSize)</td></tr>
<tr class="memdesc:acdfc781df11fed36a633a551e394e6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates memory that at most <em>newSize</em> variables can be handled in the subproblem.  <a href="#acdfc781df11fed36a633a551e394e6e9">More...</a><br /></td></tr>
<tr class="separator:acdfc781df11fed36a633a551e394e6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad5468340a0cf0c2bf8c21f2b165576e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_active.html">Active</a>&lt; <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ad5468340a0cf0c2bf8c21f2b165576e0">actCon_</a></td></tr>
<tr class="memdesc:ad5468340a0cf0c2bf8c21f2b165576e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The active constraints of the subproblem.  <a href="#ad5468340a0cf0c2bf8c21f2b165576e0">More...</a><br /></td></tr>
<tr class="separator:ad5468340a0cf0c2bf8c21f2b165576e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc2faec4d94cb5e02443fc6e0181b57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_active.html">Active</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aadc2faec4d94cb5e02443fc6e0181b57">actVar_</a></td></tr>
<tr class="memdesc:aadc2faec4d94cb5e02443fc6e0181b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">The active variables of the subproblem.  <a href="#aadc2faec4d94cb5e02443fc6e0181b57">More...</a><br /></td></tr>
<tr class="separator:aadc2faec4d94cb5e02443fc6e0181b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba078252265efe4627589816f97a79cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_cut_buffer.html">CutBuffer</a>&lt; <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aba078252265efe4627589816f97a79cf">addConBuffer_</a></td></tr>
<tr class="memdesc:aba078252265efe4627589816f97a79cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer of the newly generated constraints.  <a href="#aba078252265efe4627589816f97a79cf">More...</a><br /></td></tr>
<tr class="separator:aba078252265efe4627589816f97a79cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6bd55440ef8cbbbfcf47ea5ef49214"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_cut_buffer.html">CutBuffer</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a7a6bd55440ef8cbbbfcf47ea5ef49214">addVarBuffer_</a></td></tr>
<tr class="memdesc:a7a6bd55440ef8cbbbfcf47ea5ef49214"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer of the newly generated variables.  <a href="#a7a6bd55440ef8cbbbfcf47ea5ef49214">More...</a><br /></td></tr>
<tr class="separator:a7a6bd55440ef8cbbbfcf47ea5ef49214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbf51d85ba335dc187ad1091cc01753"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a6cbf51d85ba335dc187ad1091cc01753">allBranchOnSetVars_</a></td></tr>
<tr class="memdesc:a6cbf51d85ba335dc187ad1091cc01753"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <em>true</em>, then the branching rule of the subproblem and of all ancestor on the path to the root node are branching on a binary variable.  <a href="#a6cbf51d85ba335dc187ad1091cc01753">More...</a><br /></td></tr>
<tr class="separator:a6cbf51d85ba335dc187ad1091cc01753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7256d650a1b4aee831f10307af839f4b"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a7256d650a1b4aee831f10307af839f4b">bInvRow_</a></td></tr>
<tr class="memdesc:a7256d650a1b4aee831f10307af839f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row of the basis inverse associated with the infeasible variable <em>infeasVar_</em> or slack variable <em>infeasCon_</em>.  <a href="#a7256d650a1b4aee831f10307af839f4b">More...</a><br /></td></tr>
<tr class="separator:a7256d650a1b4aee831f10307af839f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ec2cdf25ad585ece88a6a8082a2b5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a28ec2cdf25ad585ece88a6a8082a2b5f">branchRule_</a></td></tr>
<tr class="memdesc:a28ec2cdf25ad585ece88a6a8082a2b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The branching rule for the subproblem.  <a href="#a28ec2cdf25ad585ece88a6a8082a2b5f">More...</a><br /></td></tr>
<tr class="separator:a28ec2cdf25ad585ece88a6a8082a2b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65685ce21f0fa98c2c5009d0c9932bbf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a65685ce21f0fa98c2c5009d0c9932bbf">dualBound_</a></td></tr>
<tr class="memdesc:a65685ce21f0fa98c2c5009d0c9932bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dual bound of the subproblem.  <a href="#a65685ce21f0fa98c2c5009d0c9932bbf">More...</a><br /></td></tr>
<tr class="separator:a65685ce21f0fa98c2c5009d0c9932bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b53451afbd864a53e832ae8a3ea98b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_sub.html">Sub</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ab6b53451afbd864a53e832ae8a3ea98b">father_</a></td></tr>
<tr class="memdesc:ab6b53451afbd864a53e832ae8a3ea98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the father in the branch-and-cut tree.  <a href="#ab6b53451afbd864a53e832ae8a3ea98b">More...</a><br /></td></tr>
<tr class="separator:ab6b53451afbd864a53e832ae8a3ea98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03823561636c5e96f282c2291a87612"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_f_s_var_stat.html">FSVarStat</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ab03823561636c5e96f282c2291a87612">fsVarStat_</a></td></tr>
<tr class="memdesc:ab03823561636c5e96f282c2291a87612"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to an array storing the status of fixing and setting of the active variables.  <a href="#ab03823561636c5e96f282c2291a87612">More...</a><br /></td></tr>
<tr class="separator:ab03823561636c5e96f282c2291a87612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35b65e53b38f697bf162f053ac403f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aa35b65e53b38f697bf162f053ac403f8">genNonLiftCons_</a></td></tr>
<tr class="memdesc:aa35b65e53b38f697bf162f053ac403f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <em>true</em>, then the management of non-liftable constraints is performed.  <a href="#aa35b65e53b38f697bf162f053ac403f8">More...</a><br /></td></tr>
<tr class="separator:aa35b65e53b38f697bf162f053ac403f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6aca20e9610687f972379fba19b5123"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ac6aca20e9610687f972379fba19b5123">infeasCon_</a></td></tr>
<tr class="memdesc:ac6aca20e9610687f972379fba19b5123"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of an infeasible constraint.  <a href="#ac6aca20e9610687f972379fba19b5123">More...</a><br /></td></tr>
<tr class="separator:ac6aca20e9610687f972379fba19b5123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab884230dec22075a51a393708dff82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a1ab884230dec22075a51a393708dff82">infeasVar_</a></td></tr>
<tr class="memdesc:a1ab884230dec22075a51a393708dff82"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of an infeasible variable.  <a href="#a1ab884230dec22075a51a393708dff82">More...</a><br /></td></tr>
<tr class="separator:a1ab884230dec22075a51a393708dff82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14667d0a59ebe4858f60250b7faca617"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a14667d0a59ebe4858f60250b7faca617">lastIterConAdd_</a></td></tr>
<tr class="memdesc:a14667d0a59ebe4858f60250b7faca617"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last iteration in which constraints have been added.  <a href="#a14667d0a59ebe4858f60250b7faca617">More...</a><br /></td></tr>
<tr class="separator:a14667d0a59ebe4858f60250b7faca617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a35f82c83ebecf0c9aecd2bca051add"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a7a35f82c83ebecf0c9aecd2bca051add">lastIterVarAdd_</a></td></tr>
<tr class="memdesc:a7a35f82c83ebecf0c9aecd2bca051add"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last iteration in which variables have been added.  <a href="#a7a35f82c83ebecf0c9aecd2bca051add">More...</a><br /></td></tr>
<tr class="separator:a7a35f82c83ebecf0c9aecd2bca051add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a6aa61019e8476ebf4545969da651a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ac7a6aa61019e8476ebf4545969da651a">lBound_</a></td></tr>
<tr class="memdesc:ac7a6aa61019e8476ebf4545969da651a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to an array with the local lower bound of the active variables.  <a href="#ac7a6aa61019e8476ebf4545969da651a">More...</a><br /></td></tr>
<tr class="separator:ac7a6aa61019e8476ebf4545969da651a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721065f2cdc9c75a7c2fdc30e14987db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_lp_sub.html">LpSub</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a721065f2cdc9c75a7c2fdc30e14987db">lp_</a></td></tr>
<tr class="memdesc:a721065f2cdc9c75a7c2fdc30e14987db"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the corresponding linear program.  <a href="#a721065f2cdc9c75a7c2fdc30e14987db">More...</a><br /></td></tr>
<tr class="separator:a721065f2cdc9c75a7c2fdc30e14987db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2907985939af27d06eb78959fade1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_l_p.html#a80d390b461dca15f5aba8068995b0063">LP::METHOD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a0e2907985939af27d06eb78959fade1c">lpMethod_</a></td></tr>
<tr class="memdesc:a0e2907985939af27d06eb78959fade1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The solution method for the next linear program.  <a href="#a0e2907985939af27d06eb78959fade1c">More...</a><br /></td></tr>
<tr class="separator:a0e2907985939af27d06eb78959fade1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc1b0772e8e0190032e7c3d46b8c711"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_l_p_v_a_r_s_t_a_t.html">LPVARSTAT</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a7dc1b0772e8e0190032e7c3d46b8c711">lpVarStat_</a></td></tr>
<tr class="memdesc:a7dc1b0772e8e0190032e7c3d46b8c711"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to an array storing the status of each active variable in the linear program.  <a href="#a7dc1b0772e8e0190032e7c3d46b8c711">More...</a><br /></td></tr>
<tr class="separator:a7dc1b0772e8e0190032e7c3d46b8c711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37af4a37e334552fa3179f3f9229663"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_master.html">Master</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ad37af4a37e334552fa3179f3f9229663">master_</a></td></tr>
<tr class="memdesc:ad37af4a37e334552fa3179f3f9229663"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the corresponding master of the optimization.  <a href="#ad37af4a37e334552fa3179f3f9229663">More...</a><br /></td></tr>
<tr class="separator:ad37af4a37e334552fa3179f3f9229663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7278521411cf0104edbf3fa62d4075c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a7278521411cf0104edbf3fa62d4075c6">nIter_</a></td></tr>
<tr class="memdesc:a7278521411cf0104edbf3fa62d4075c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of iterations in the cutting plane phase.  <a href="#a7278521411cf0104edbf3fa62d4075c6">More...</a><br /></td></tr>
<tr class="separator:a7278521411cf0104edbf3fa62d4075c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db882b9bb022036456e6fb575104db0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a6db882b9bb022036456e6fb575104db0">removeConBuffer_</a></td></tr>
<tr class="memdesc:a6db882b9bb022036456e6fb575104db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer of the constraints which are removed at the beginning of the next iteration.  <a href="#a6db882b9bb022036456e6fb575104db0">More...</a><br /></td></tr>
<tr class="separator:a6db882b9bb022036456e6fb575104db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077e405efdfa53cebbca96851df163dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a077e405efdfa53cebbca96851df163dc">removeVarBuffer_</a></td></tr>
<tr class="memdesc:a077e405efdfa53cebbca96851df163dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer of the variables which are removed at the beginning of the next iteration.  <a href="#a077e405efdfa53cebbca96851df163dc">More...</a><br /></td></tr>
<tr class="separator:a077e405efdfa53cebbca96851df163dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc296377f537c233ee5ee1893dca5a86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="classabacus_1_1_slack_stat.html">SlackStat</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#acc296377f537c233ee5ee1893dca5a86">slackStat_</a></td></tr>
<tr class="memdesc:acc296377f537c233ee5ee1893dca5a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to an array storing the statuses of the slack variables of the last solved linear program.  <a href="#acc296377f537c233ee5ee1893dca5a86">More...</a><br /></td></tr>
<tr class="separator:acc296377f537c233ee5ee1893dca5a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894b35a30a8be59719014ee7afcd2704"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_tail_off.html">TailOff</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a894b35a30a8be59719014ee7afcd2704">tailOff_</a></td></tr>
<tr class="memdesc:a894b35a30a8be59719014ee7afcd2704"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the tailing off manager.  <a href="#a894b35a30a8be59719014ee7afcd2704">More...</a><br /></td></tr>
<tr class="separator:a894b35a30a8be59719014ee7afcd2704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221a27d9555e4349ccb010374c003ec1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a221a27d9555e4349ccb010374c003ec1">uBound_</a></td></tr>
<tr class="memdesc:a221a27d9555e4349ccb010374c003ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to an array with the local upper bounds of the active variables.  <a href="#a221a27d9555e4349ccb010374c003ec1">More...</a><br /></td></tr>
<tr class="separator:a221a27d9555e4349ccb010374c003ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e1176f96f27168f1831c2a94e727a1"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ab6e1176f96f27168f1831c2a94e727a1">xVal_</a></td></tr>
<tr class="memdesc:ab6e1176f96f27168f1831c2a94e727a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last LP-solution.  <a href="#ab6e1176f96f27168f1831c2a94e727a1">More...</a><br /></td></tr>
<tr class="separator:ab6e1176f96f27168f1831c2a94e727a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1542533318ef9f52bd59e3db06e4ba5"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ae1542533318ef9f52bd59e3db06e4ba5">yVal_</a></td></tr>
<tr class="memdesc:ae1542533318ef9f52bd59e3db06e4ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dual variables of the last linear program.  <a href="#ae1542533318ef9f52bd59e3db06e4ba5">More...</a><br /></td></tr>
<tr class="separator:ae1542533318ef9f52bd59e3db06e4ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a08dd19a3cf879055f0a579fec3562737"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a08dd19a3cf879055f0a579fec3562737">Sub</a> (const <a class="el" href="classabacus_1_1_sub.html">Sub</a> &amp;rhs)</td></tr>
<tr class="separator:a08dd19a3cf879055f0a579fec3562737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4825021bf089410d94184c9f4c3350ec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classabacus_1_1_sub.html#aa9fe7d3a08b8ba4d97a8e4927178256e">PHASE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a4825021bf089410d94184c9f4c3350ec">_activate</a> ()</td></tr>
<tr class="memdesc:a4825021bf089410d94184c9f4c3350ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and initializes memory of the subproblem at the beginning of the optimization.  <a href="#a4825021bf089410d94184c9f4c3350ec">More...</a><br /></td></tr>
<tr class="separator:a4825021bf089410d94184c9f4c3350ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e3fde5667c06d9d4c6e4a1d6628252"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ad5e3fde5667c06d9d4c6e4a1d6628252">_atLowerBound</a> (int i)</td></tr>
<tr class="memdesc:ad5e3fde5667c06d9d4c6e4a1d6628252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the current value of variable i in the primal lp is equal to its lower bound.  <a href="#ad5e3fde5667c06d9d4c6e4a1d6628252">More...</a><br /></td></tr>
<tr class="separator:ad5e3fde5667c06d9d4c6e4a1d6628252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eca071b2c05307ac8e64c13c986951a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a5eca071b2c05307ac8e64c13c986951a">_atUpperBound</a> (int i)</td></tr>
<tr class="memdesc:a5eca071b2c05307ac8e64c13c986951a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the current value of variable i in the primal lp is equal to its upper bound.  <a href="#a5eca071b2c05307ac8e64c13c986951a">More...</a><br /></td></tr>
<tr class="separator:a5eca071b2c05307ac8e64c13c986951a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d68e9b9992f07f1ce41f9dee28e860"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a98d68e9b9992f07f1ce41f9dee28e860">_conEliminate</a> ()</td></tr>
<tr class="memdesc:a98d68e9b9992f07f1ce41f9dee28e860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of eliminated constraints.  <a href="#a98d68e9b9992f07f1ce41f9dee28e860">More...</a><br /></td></tr>
<tr class="separator:a98d68e9b9992f07f1ce41f9dee28e860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6953ef615122bf8aee1e1d8cf06d7027"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a6953ef615122bf8aee1e1d8cf06d7027">_deactivate</a> ()</td></tr>
<tr class="memdesc:a6953ef615122bf8aee1e1d8cf06d7027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates the memory which is not required after the optimization of the subproblem.  <a href="#a6953ef615122bf8aee1e1d8cf06d7027">More...</a><br /></td></tr>
<tr class="separator:a6953ef615122bf8aee1e1d8cf06d7027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecdee6ca7aa6c511a17a710c5d1594b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a2ecdee6ca7aa6c511a17a710c5d1594b">_fixByLogImp</a> (bool &amp;newValues)</td></tr>
<tr class="memdesc:a2ecdee6ca7aa6c511a17a710c5d1594b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1, if a contradiction has been found, 0 otherwise.  <a href="#a2ecdee6ca7aa6c511a17a710c5d1594b">More...</a><br /></td></tr>
<tr class="separator:a2ecdee6ca7aa6c511a17a710c5d1594b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48afa9e501150cf7fe3c6943489289d8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a48afa9e501150cf7fe3c6943489289d8">_improve</a> (double &amp;primalValue)</td></tr>
<tr class="memdesc:a48afa9e501150cf7fe3c6943489289d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find a better feasible solution.  <a href="#a48afa9e501150cf7fe3c6943489289d8">More...</a><br /></td></tr>
<tr class="separator:a48afa9e501150cf7fe3c6943489289d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda5bc10e09170417f03b8d9835db652"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#acda5bc10e09170417f03b8d9835db652">_initMakeFeas</a> ()</td></tr>
<tr class="memdesc:acda5bc10e09170417f03b8d9835db652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to add variables to restore infeasibilities detected at initialization time.  <a href="#acda5bc10e09170417f03b8d9835db652">More...</a><br /></td></tr>
<tr class="separator:acda5bc10e09170417f03b8d9835db652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee715441e1a048de31154f39ce8e518"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a9ee715441e1a048de31154f39ce8e518">_makeFeasible</a> ()</td></tr>
<tr class="memdesc:a9ee715441e1a048de31154f39ce8e518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is called if the <em><a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a></em> is infeasible and adds inactive variables, which can make the <em><a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a></em> feasible again, to the set of active variables.  <a href="#a9ee715441e1a048de31154f39ce8e518">More...</a><br /></td></tr>
<tr class="separator:a9ee715441e1a048de31154f39ce8e518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c45db3df12178ac303379a1608210f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a14c45db3df12178ac303379a1608210f">_pricing</a> (bool &amp;newValues, bool doFixSet=true)</td></tr>
<tr class="memdesc:a14c45db3df12178ac303379a1608210f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <em>doFixSet</em> is <em>true</em>, then we try to fix and set variables, if all inactive variables price out correctly.  <a href="#a14c45db3df12178ac303379a1608210f">More...</a><br /></td></tr>
<tr class="separator:a14c45db3df12178ac303379a1608210f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8ea1c1e311f7aa34f7b6324432a032"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a6c8ea1c1e311f7aa34f7b6324432a032">_removeCons</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;remove)</td></tr>
<tr class="memdesc:a6c8ea1c1e311f7aa34f7b6324432a032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the constraints with numbers <em>remove</em> from the set of active constraints.  <a href="#a6c8ea1c1e311f7aa34f7b6324432a032">More...</a><br /></td></tr>
<tr class="separator:a6c8ea1c1e311f7aa34f7b6324432a032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71f34af288a32498271acca731430d0"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ac71f34af288a32498271acca731430d0">_removeVars</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;remove)</td></tr>
<tr class="memdesc:ac71f34af288a32498271acca731430d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the variables with numbers <em>remove</em> from the set of active variables.  <a href="#ac71f34af288a32498271acca731430d0">More...</a><br /></td></tr>
<tr class="separator:ac71f34af288a32498271acca731430d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3238c09e496c5de8ed786be154a4fad1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a3238c09e496c5de8ed786be154a4fad1">_selectCons</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_pool_slot.html">PoolSlot</a>&lt; <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a> &gt; *&gt; &amp;newCons)</td></tr>
<tr class="memdesc:a3238c09e496c5de8ed786be154a4fad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the <em>master_-&gt;maxConAdd()</em> best constraints from the buffered constraints and stores them in <em>newCons</em>.  <a href="#a3238c09e496c5de8ed786be154a4fad1">More...</a><br /></td></tr>
<tr class="separator:a3238c09e496c5de8ed786be154a4fad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0822d126b98af48ff9ff5dd18c1ec1d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ae0822d126b98af48ff9ff5dd18c1ec1d">_selectVars</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_pool_slot.html">PoolSlot</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; *&gt; &amp;newVars)</td></tr>
<tr class="memdesc:ae0822d126b98af48ff9ff5dd18c1ec1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the <em>master_-&gt;maxVarAdd()</em> best variables from the buffered variables.  <a href="#ae0822d126b98af48ff9ff5dd18c1ec1d">More...</a><br /></td></tr>
<tr class="separator:ae0822d126b98af48ff9ff5dd18c1ec1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95c7a0d07dcd8b4645f5c5291921809"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ab95c7a0d07dcd8b4645f5c5291921809">_separate</a> ()</td></tr>
<tr class="memdesc:ab95c7a0d07dcd8b4645f5c5291921809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of generated cutting planes.  <a href="#ab95c7a0d07dcd8b4645f5c5291921809">More...</a><br /></td></tr>
<tr class="separator:ab95c7a0d07dcd8b4645f5c5291921809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906f6a256eaada8039365a8a7d9951a1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a906f6a256eaada8039365a8a7d9951a1">_setByLogImp</a> (bool &amp;newValues)</td></tr>
<tr class="memdesc:a906f6a256eaada8039365a8a7d9951a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to set variables according to logical implications of already set and fixed variables.  <a href="#a906f6a256eaada8039365a8a7d9951a1">More...</a><br /></td></tr>
<tr class="separator:a906f6a256eaada8039365a8a7d9951a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b20e72f968c19fc4269836627ea427"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ab8b20e72f968c19fc4269836627ea427">_varEliminate</a> ()</td></tr>
<tr class="memdesc:ab8b20e72f968c19fc4269836627ea427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of eliminated variables.  <a href="#ab8b20e72f968c19fc4269836627ea427">More...</a><br /></td></tr>
<tr class="separator:ab8b20e72f968c19fc4269836627ea427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886f08388d8a23e8b7edb5e05fcc718a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a886f08388d8a23e8b7edb5e05fcc718a">activateVars</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_pool_slot.html">PoolSlot</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; *&gt; &amp;newVars)</td></tr>
<tr class="memdesc:a886f08388d8a23e8b7edb5e05fcc718a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the variables stored in the pool slots of <em>newVars</em> to the set of active variables, but not to the linear program.  <a href="#a886f08388d8a23e8b7edb5e05fcc718a">More...</a><br /></td></tr>
<tr class="separator:a886f08388d8a23e8b7edb5e05fcc718a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0319ff82342610ca367e6196c79bac35"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a0319ff82342610ca367e6196c79bac35">addVarsToLp</a> (<a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_pool_slot.html">PoolSlot</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; *&gt; &amp;newVars, <a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_f_s_var_stat.html">FSVarStat</a> *&gt; *localStatus=nullptr)</td></tr>
<tr class="memdesc:a0319ff82342610ca367e6196c79bac35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the variables stored in the pool slots of <em>newVars</em> to the linear program. <em>localStatus</em> can specify a local status of fixing and setting.  <a href="#a0319ff82342610ca367e6196c79bac35">More...</a><br /></td></tr>
<tr class="separator:a0319ff82342610ca367e6196c79bac35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb38dae6842123c906092631ca4aff5f"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#acb38dae6842123c906092631ca4aff5f">fixSetNewBound</a> (int i)</td></tr>
<tr class="memdesc:acb38dae6842123c906092631ca4aff5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value which the upper and lower bounds of a variable should take after it is fixed or set.  <a href="#acb38dae6842123c906092631ca4aff5f">More...</a><br /></td></tr>
<tr class="separator:acb38dae6842123c906092631ca4aff5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945acefc7e42bf224d4fa35103d754b3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a945acefc7e42bf224d4fa35103d754b3">getBase</a> ()</td></tr>
<tr class="memdesc:a945acefc7e42bf224d4fa35103d754b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the status of the variables and the slack variables.  <a href="#a945acefc7e42bf224d4fa35103d754b3">More...</a><br /></td></tr>
<tr class="separator:a945acefc7e42bf224d4fa35103d754b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee72919a1b3d970e8495c9ce6dc869fd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aee72919a1b3d970e8495c9ce6dc869fd">infeasibleSub</a> ()</td></tr>
<tr class="memdesc:aee72919a1b3d970e8495c9ce6dc869fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should be called if a subproblem turns out to be infeasible.  <a href="#aee72919a1b3d970e8495c9ce6dc869fd">More...</a><br /></td></tr>
<tr class="separator:aee72919a1b3d970e8495c9ce6dc869fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa959d64f6cd7f7ac8299cd5ce8720612"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aa959d64f6cd7f7ac8299cd5ce8720612">newDormantRound</a> ()</td></tr>
<tr class="memdesc:aa959d64f6cd7f7ac8299cd5ce8720612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the counter for the number of rounds the subproblem is dormant.  <a href="#aa959d64f6cd7f7ac8299cd5ce8720612">More...</a><br /></td></tr>
<tr class="separator:aa959d64f6cd7f7ac8299cd5ce8720612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ccfe6cf93319aabc572867f788c642"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classabacus_1_1_sub.html">Sub</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a93ccfe6cf93319aabc572867f788c642">operator=</a> (const <a class="el" href="classabacus_1_1_sub.html">Sub</a> &amp;rhs)</td></tr>
<tr class="separator:a93ccfe6cf93319aabc572867f788c642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58402e7a567fc3c0a1ce51e7e58b1cf8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a58402e7a567fc3c0a1ce51e7e58b1cf8">updateBoundInLp</a> (int i)</td></tr>
<tr class="memdesc:a58402e7a567fc3c0a1ce51e7e58b1cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapts the bound of a fixed or set variable <em>i</em> also in the linear program.  <a href="#a58402e7a567fc3c0a1ce51e7e58b1cf8">More...</a><br /></td></tr>
<tr class="separator:a58402e7a567fc3c0a1ce51e7e58b1cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4780a09b3b06efd1c2683dbb5a259c74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a4780a09b3b06efd1c2683dbb5a259c74">activated_</a></td></tr>
<tr class="memdesc:a4780a09b3b06efd1c2683dbb5a259c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable is <em>true</em> if the function <em><a class="el" href="classabacus_1_1_sub.html#ae22a4eb3419a6665e28cbeb0b592bcba" title="Can be used as an entrance point for problem specific activations. ">activate()</a></em> has been called from the function <em><a class="el" href="classabacus_1_1_sub.html#a4825021bf089410d94184c9f4c3350ec" title="Allocates and initializes memory of the subproblem at the beginning of the optimization. ">_activate()</a></em>.  <a href="#a4780a09b3b06efd1c2683dbb5a259c74">More...</a><br /></td></tr>
<tr class="separator:a4780a09b3b06efd1c2683dbb5a259c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24b81e53fed6385ba07d7c5d6b02d69"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ae24b81e53fed6385ba07d7c5d6b02d69">conReserve_</a></td></tr>
<tr class="memdesc:ae24b81e53fed6385ba07d7c5d6b02d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">The additional space for constraints.  <a href="#ae24b81e53fed6385ba07d7c5d6b02d69">More...</a><br /></td></tr>
<tr class="separator:ae24b81e53fed6385ba07d7c5d6b02d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a23b352fe66ec04e79ba29aa2894203"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a9a23b352fe66ec04e79ba29aa2894203">forceExactSolver_</a></td></tr>
<tr class="memdesc:a9a23b352fe66ec04e79ba29aa2894203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether to force the use of an exact solver to prepare branching etc.  <a href="#a9a23b352fe66ec04e79ba29aa2894203">More...</a><br /></td></tr>
<tr class="separator:a9a23b352fe66ec04e79ba29aa2894203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc76c79c409c68eb4f6d00719d5f31e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a8dc76c79c409c68eb4f6d00719d5f31e">id_</a></td></tr>
<tr class="memdesc:a8dc76c79c409c68eb4f6d00719d5f31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of the subproblem.  <a href="#a8dc76c79c409c68eb4f6d00719d5f31e">More...</a><br /></td></tr>
<tr class="separator:a8dc76c79c409c68eb4f6d00719d5f31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed53999c8aa472004caa1469656ccdca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aed53999c8aa472004caa1469656ccdca">ignoreInTailingOff_</a></td></tr>
<tr class="memdesc:aed53999c8aa472004caa1469656ccdca"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this flag is set to <em>true</em> then the next LP-solution is ignored in the tailing-off control.  <a href="#aed53999c8aa472004caa1469656ccdca">More...</a><br /></td></tr>
<tr class="separator:aed53999c8aa472004caa1469656ccdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa446e79a69adc949422028a81db23e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_l_p.html#a80d390b461dca15f5aba8068995b0063">LP::METHOD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#acaa446e79a69adc949422028a81db23e">lastLP_</a></td></tr>
<tr class="memdesc:acaa446e79a69adc949422028a81db23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The method that was used to solve the last <a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a>.  <a href="#acaa446e79a69adc949422028a81db23e">More...</a><br /></td></tr>
<tr class="separator:acaa446e79a69adc949422028a81db23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4308fc252ddcf2b4adbf3e0d9e146fc5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a4308fc252ddcf2b4adbf3e0d9e146fc5">level_</a></td></tr>
<tr class="memdesc:a4308fc252ddcf2b4adbf3e0d9e146fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The level of the subproblem in the enumeration tree.  <a href="#a4308fc252ddcf2b4adbf3e0d9e146fc5">More...</a><br /></td></tr>
<tr class="separator:a4308fc252ddcf2b4adbf3e0d9e146fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad53c79fae7d51cd31e5e2167741165a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_stopwatch_c_p_u.html">ogdf::StopwatchCPU</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aad53c79fae7d51cd31e5e2167741165a">localTimer_</a></td></tr>
<tr class="separator:aad53c79fae7d51cd31e5e2167741165a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee3d66704b45c2ef04b6fabb15b752e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#acee3d66704b45c2ef04b6fabb15b752e">maxIterations_</a></td></tr>
<tr class="memdesc:acee3d66704b45c2ef04b6fabb15b752e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of iterations in the cutting plane phase.  <a href="#acee3d66704b45c2ef04b6fabb15b752e">More...</a><br /></td></tr>
<tr class="separator:acee3d66704b45c2ef04b6fabb15b752e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4ef28c3d7424d848b5dee7667b70dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aeb4ef28c3d7424d848b5dee7667b70dd">nDormantRounds_</a></td></tr>
<tr class="memdesc:aeb4ef28c3d7424d848b5dee7667b70dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of subproblem optimizations the subproblem has already the status <em>Dormant</em>.  <a href="#aeb4ef28c3d7424d848b5dee7667b70dd">More...</a><br /></td></tr>
<tr class="separator:aeb4ef28c3d7424d848b5dee7667b70dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6a0f9e88a7d3ce34bb8a25bf5d1b63"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#adb6a0f9e88a7d3ce34bb8a25bf5d1b63">nnzReserve_</a></td></tr>
<tr class="memdesc:adb6a0f9e88a7d3ce34bb8a25bf5d1b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">The additional space for nonzeros.  <a href="#adb6a0f9e88a7d3ce34bb8a25bf5d1b63">More...</a><br /></td></tr>
<tr class="separator:adb6a0f9e88a7d3ce34bb8a25bf5d1b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e11b2b659ba658d803e2fc4f7ed8a00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a7e11b2b659ba658d803e2fc4f7ed8a00">nOpt_</a></td></tr>
<tr class="memdesc:a7e11b2b659ba658d803e2fc4f7ed8a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of optimizations of the subproblem.  <a href="#a7e11b2b659ba658d803e2fc4f7ed8a00">More...</a><br /></td></tr>
<tr class="separator:a7e11b2b659ba658d803e2fc4f7ed8a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824244b4ef5f23606508e64662f1b397"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a824244b4ef5f23606508e64662f1b397">relativeReserve_</a></td></tr>
<tr class="memdesc:a824244b4ef5f23606508e64662f1b397"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this member is <em>true</em> then the space reserve of the following three members <em>varReserve_</em>, <em>conReserve_</em>, and <em>nnzReserve_</em> is relative to the initial numbers of constraints, variables, and nonzeros, respectively.  <a href="#a824244b4ef5f23606508e64662f1b397">More...</a><br /></td></tr>
<tr class="separator:a824244b4ef5f23606508e64662f1b397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b4ca87a0b6cad408b371820dae4cee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_sub.html">Sub</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#aa0b4ca87a0b6cad408b371820dae4cee">sons_</a></td></tr>
<tr class="memdesc:aa0b4ca87a0b6cad408b371820dae4cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sons of the node in the branch-and-cut tree.  <a href="#aa0b4ca87a0b6cad408b371820dae4cee">More...</a><br /></td></tr>
<tr class="separator:aa0b4ca87a0b6cad408b371820dae4cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f00b594075dc21be76b2e2988f0f702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classabacus_1_1_sub.html#a49aa228f17967fc8ac589b5fb7bc3297">STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a4f00b594075dc21be76b2e2988f0f702">status_</a></td></tr>
<tr class="memdesc:a4f00b594075dc21be76b2e2988f0f702"><td class="mdescLeft">&#160;</td><td class="mdescRight">The status of the subproblem.  <a href="#a4f00b594075dc21be76b2e2988f0f702">More...</a><br /></td></tr>
<tr class="separator:a4f00b594075dc21be76b2e2988f0f702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf8c65703b53568b30b3131560c58ff"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#adaf8c65703b53568b30b3131560c58ff">varReserve_</a></td></tr>
<tr class="memdesc:adaf8c65703b53568b30b3131560c58ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The additional space for variables.  <a href="#adaf8c65703b53568b30b3131560c58ff">More...</a><br /></td></tr>
<tr class="separator:adaf8c65703b53568b30b3131560c58ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2dcfa64745ea8a05bd13f95821de3c37"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a2dcfa64745ea8a05bd13f95821de3c37">BoundBranchRule</a></td></tr>
<tr class="separator:a2dcfa64745ea8a05bd13f95821de3c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fc97a80de99c3272c02c78c6b69774"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ae4fc97a80de99c3272c02c78c6b69774">LpSolution&lt; Constraint, Variable &gt;</a></td></tr>
<tr class="separator:ae4fc97a80de99c3272c02c78c6b69774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11ca7e42e9ab3ff4effadd18907942d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#ac11ca7e42e9ab3ff4effadd18907942d">LpSolution&lt; Variable, Constraint &gt;</a></td></tr>
<tr class="separator:ac11ca7e42e9ab3ff4effadd18907942d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b85c36cc2386b553fcff72fc15a596"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a34b85c36cc2386b553fcff72fc15a596">Master</a></td></tr>
<tr class="separator:a34b85c36cc2386b553fcff72fc15a596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5523bb2d3bd300638fc44f4cb0cc17a4"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_sub.html#a5523bb2d3bd300638fc44f4cb0cc17a4">OpenSub</a></td></tr>
<tr class="separator:a5523bb2d3bd300638fc44f4cb0cc17a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classabacus_1_1_abacus_root"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classabacus_1_1_abacus_root')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classabacus_1_1_abacus_root.html">abacus::AbacusRoot</a></td></tr>
<tr class="memitem:a28a9cfb3b9a4cd4990c046581f9bbd78 inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_abacus_root.html#a28a9cfb3b9a4cd4990c046581f9bbd78">ascii2bool</a> (const string &amp;str)</td></tr>
<tr class="memdesc:a28a9cfb3b9a4cd4990c046581f9bbd78 inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the string <em>str</em> to a boolean value.  <a href="classabacus_1_1_abacus_root.html#a28a9cfb3b9a4cd4990c046581f9bbd78">More...</a><br /></td></tr>
<tr class="separator:a28a9cfb3b9a4cd4990c046581f9bbd78 inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b9fba6fabf13294e0af48534ae40ff inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_abacus_root.html#a13b9fba6fabf13294e0af48534ae40ff">endsWith</a> (const string &amp;str, const string &amp;end)</td></tr>
<tr class="memdesc:a13b9fba6fabf13294e0af48534ae40ff inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <em>str</em> ends with <em>end</em>, false otherwise.  <a href="classabacus_1_1_abacus_root.html#a13b9fba6fabf13294e0af48534ae40ff">More...</a><br /></td></tr>
<tr class="separator:a13b9fba6fabf13294e0af48534ae40ff inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa15fbdee10063826f95e9bba642f2bd inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_abacus_root.html#afa15fbdee10063826f95e9bba642f2bd">fracPart</a> (double x)</td></tr>
<tr class="memdesc:afa15fbdee10063826f95e9bba642f2bd inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of the fractional part of <em>x</em>.  <a href="classabacus_1_1_abacus_root.html#afa15fbdee10063826f95e9bba642f2bd">More...</a><br /></td></tr>
<tr class="separator:afa15fbdee10063826f95e9bba642f2bd inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2eda31050d9b9a135a55fce76a7aedd inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabacus_1_1_abacus_root.html#af2eda31050d9b9a135a55fce76a7aedd">onOff</a> (bool value)</td></tr>
<tr class="memdesc:af2eda31050d9b9a135a55fce76a7aedd inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a boolean variable to the strings <em>"on"</em> and <em>"off"</em>.  <a href="classabacus_1_1_abacus_root.html#af2eda31050d9b9a135a55fce76a7aedd">More...</a><br /></td></tr>
<tr class="separator:af2eda31050d9b9a135a55fce76a7aedd inherit pub_static_methods_classabacus_1_1_abacus_root"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The subproblem. </p>
<p>This class implements an abstract base class for a subproblem of the enumeration, i.e., a node of the branch-and-bound tree. The core of this class is the solution of the linear programming relaxation. If a derived class provides methods for the generation of cutting planes and/or variables, then the subproblem is processed by a cutting plane and/or column generation algorithm. Essential is that every subproblem has its own sets of active constraints and variables, which provides a very high flexibility. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00068">68</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aa9fe7d3a08b8ba4d97a8e4927178256e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fe7d3a08b8ba4d97a8e4927178256e">&#9670;&nbsp;</a></span>PHASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classabacus_1_1_sub.html#aa9fe7d3a08b8ba4d97a8e4927178256e">abacus::Sub::PHASE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The optimization of the subproblem can be in one of the following phases. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa9fe7d3a08b8ba4d97a8e4927178256ea11cf0b42c8fd79313439fd783c4dad60"></a>Done&#160;</td><td class="fielddoc"><p>The optimization is done. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa9fe7d3a08b8ba4d97a8e4927178256ea2b697243e942f3023325fc7ba76ddd36"></a>Cutting&#160;</td><td class="fielddoc"><p>The iterative solution of the LP-relaxation and the generation of cutting planes and/or variables is currently performed. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa9fe7d3a08b8ba4d97a8e4927178256ea269cf6042e08ab945d99d3d9acb1c89f"></a>Branching&#160;</td><td class="fielddoc"><p>We try to generate further subproblems as sons of this subproblem. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa9fe7d3a08b8ba4d97a8e4927178256eab185bc7a9f947e039fcb627bcfc356c7"></a>Fathoming&#160;</td><td class="fielddoc"><p>The subproblem is currently being fathomed. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00089">89</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a49aa228f17967fc8ac589b5fb7bc3297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49aa228f17967fc8ac589b5fb7bc3297">&#9670;&nbsp;</a></span>STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classabacus_1_1_sub.html#a49aa228f17967fc8ac589b5fb7bc3297">abacus::Sub::STATUS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A subproblem can have different statuses. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a49aa228f17967fc8ac589b5fb7bc3297a09527dd8b24e222471d1d6d20c85e032"></a>Unprocessed&#160;</td><td class="fielddoc"><p>The status after generation, but before optimization of the subproblem. </p>
</td></tr>
<tr><td class="fieldname"><a id="a49aa228f17967fc8ac589b5fb7bc3297a3dd81d2a00aece62a7337796a9575ffc"></a>ActiveSub&#160;</td><td class="fielddoc"><p>The subproblem is currently processed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a49aa228f17967fc8ac589b5fb7bc3297a021d53f593fc734ddd605b06fd6f5455"></a>Dormant&#160;</td><td class="fielddoc"><p>The subproblem is partially processed and waiting in the set of open subproblems for further optimization. </p>
</td></tr>
<tr><td class="fieldname"><a id="a49aa228f17967fc8ac589b5fb7bc3297a16d99ac8fc568816d35ecdf08b9faf9c"></a>Processed&#160;</td><td class="fielddoc"><p>The subproblem is completely processed but could not be fathomed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a49aa228f17967fc8ac589b5fb7bc3297a321890ae1302f574a9fd7f9a224604ac"></a>Fathomed&#160;</td><td class="fielddoc"><p>The subproblem is fathomed. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00079">79</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3d615932674f03cc77b4cc82e5f9b835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d615932674f03cc77b4cc82e5f9b835">&#9670;&nbsp;</a></span>Sub() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abacus::Sub::Sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_master.html">Master</a> *&#160;</td>
          <td class="paramname"><em>master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>conRes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>varRes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nnzRes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>relativeRes</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_pool_slot.html">PoolSlot</a>&lt; <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a> &gt; *&gt; *&#160;</td>
          <td class="paramname"><em>constraints</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_pool_slot.html">PoolSlot</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; *&gt; *&#160;</td>
          <td class="paramname"><em>variables</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the root node of the enumeration tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">master</td><td>A pointer to the corresponding master of the optimization. </td></tr>
    <tr><td class="paramname">conRes</td><td>The additional memory allocated for constraints. </td></tr>
    <tr><td class="paramname">varRes</td><td>The additional memory allocated for variables. </td></tr>
    <tr><td class="paramname">nnzRes</td><td>The additional memory allocated for nonzero elements of the constraint matrix. </td></tr>
    <tr><td class="paramname">relativeRes</td><td>If this argument is <em>true</em>, then reserve space for variables, constraints, and nonzeros given by the previous three arguments, is given in percent of the original numbers. Otherwise, the numbers are interpreted as absolute values (casted to integer). The default value is <em>true</em>. </td></tr>
    <tr><td class="paramname">constraints</td><td>The pool slots of the initial constraints. If the value is 0, then the constraints of the default constraint pool are taken. The default value is 0. </td></tr>
    <tr><td class="paramname">variables</td><td>The pool slots of the initial variables. If the value is 0, then the variables of the default variable pool are taken. The default value is 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9918bc44c9a54813aa7f8a6a47a6ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9918bc44c9a54813aa7f8a6a47a6ea8">&#9670;&nbsp;</a></span>Sub() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abacus::Sub::Sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_master.html">Master</a> *&#160;</td>
          <td class="paramname"><em>master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_sub.html">Sub</a> *&#160;</td>
          <td class="paramname"><em>father</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a> *&#160;</td>
          <td class="paramname"><em>branchRule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a non-root node of the enumeration tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">master</td><td>A pointer to the corresponding master of the optimization. </td></tr>
    <tr><td class="paramname">father</td><td>A pointer to the father in the enumeration tree. </td></tr>
    <tr><td class="paramname">branchRule</td><td>The rule defining the subspace of the solution space associated with this subproblem. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c1f6f719dfa8526c602d113e8a931e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1f6f719dfa8526c602d113e8a931e9">&#9670;&nbsp;</a></span>~Sub()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual abacus::Sub::~Sub </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The destructor only deletes the sons of the node. </p>
<p>The deletion of allocated memory is already performed when the node is fathomed. We recursively call the destructors of all subproblems contained in the enumeration tree below this subproblem itself.</p>
<p>If a subproblem has no sons and its status is either <em>Unprocessed</em> or <em>Dormant</em>, then it is still contained in the set of open subproblems, where it is removed from. </p>

<p>Reimplemented in <a class="el" href="classogdf_1_1_min_steiner_tree_directed_cut_1_1_sub.html#a43c963c71ba9278fdc076b8c4f290eb2">ogdf::MinSteinerTreeDirectedCut&lt; T &gt;::Sub</a>.</p>

</div>
</div>
<a id="a08dd19a3cf879055f0a579fec3562737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dd19a3cf879055f0a579fec3562737">&#9670;&nbsp;</a></span>Sub() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abacus::Sub::Sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classabacus_1_1_sub.html">Sub</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4825021bf089410d94184c9f4c3350ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4825021bf089410d94184c9f4c3350ec">&#9670;&nbsp;</a></span>_activate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classabacus_1_1_sub.html#aa9fe7d3a08b8ba4d97a8e4927178256e">PHASE</a> abacus::Sub::_activate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates and initializes memory of the subproblem at the beginning of the optimization. </p>
<p>The function returns the next phase of the optimization. This is either <em>Cutting</em> or <em>Fathoming</em> if the subproblem immediately turns out to be infeasible.</p>
<p>Since many objects of the class <a class="el" href="classabacus_1_1_sub.html" title="The subproblem. ">Sub</a> can exist at the same time, yet in a sequential algorithm only one problem is active, a lot of memory can be saved if some memory is dynamically allocated when the subproblem becomes active and other information is stored in a compressed format for dormant problems.</p>
<p>These allocations and decompressions are performed by the function <em><a class="el" href="classabacus_1_1_sub.html#a4825021bf089410d94184c9f4c3350ec" title="Allocates and initializes memory of the subproblem at the beginning of the optimization. ">_activate()</a></em>, the respective deallocations and compression of data is executed by the function <em><a class="el" href="classabacus_1_1_sub.html#a6953ef615122bf8aee1e1d8cf06d7027" title="Deallocates the memory which is not required after the optimization of the subproblem. ">_deactivate()</a></em>.</p>
<p>Currently for all subproblems which have not been processed already (except for the root) we initialize the active constraints and variables with the respective data from the father node adapted by the branching information since so we can make sure that all fixed and set variables are active. A more flexible strategy might be desirable but also dangerous.</p>
<p>The virtual function <em><a class="el" href="classabacus_1_1_sub.html#ae22a4eb3419a6665e28cbeb0b592bcba" title="Can be used as an entrance point for problem specific activations. ">activate()</a></em> can perform problem specific activations. It is called before variables are fixed by logical implications, because, e.g., for problems on graphs, the graph associated with the subproblem might have to be activated.</p>
<p>Moreover, the function <em><a class="el" href="classabacus_1_1_sub.html#a4825021bf089410d94184c9f4c3350ec" title="Allocates and initializes memory of the subproblem at the beginning of the optimization. ">_activate()</a></em> is redundant in the sense that it is called only once and could be substituted by a function. However, having a future generalization to non linear-programming based branch-and-bound in mind, we keep this function. </p>

</div>
</div>
<a id="ad5e3fde5667c06d9d4c6e4a1d6628252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e3fde5667c06d9d4c6e4a1d6628252">&#9670;&nbsp;</a></span>_atLowerBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abacus::Sub::_atLowerBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true iff the current value of variable i in the primal lp is equal to its lower bound. </p>

</div>
</div>
<a id="a5eca071b2c05307ac8e64c13c986951a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eca071b2c05307ac8e64c13c986951a">&#9670;&nbsp;</a></span>_atUpperBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abacus::Sub::_atUpperBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true iff the current value of variable i in the primal lp is equal to its upper bound. </p>

</div>
</div>
<a id="a98d68e9b9992f07f1ce41f9dee28e860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d68e9b9992f07f1ce41f9dee28e860">&#9670;&nbsp;</a></span>_conEliminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::_conEliminate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of eliminated constraints. </p>
<p>Only dynamic constraints are eliminated from the <em><a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a></em>.</p>
<p>It might be worth to implement problem specific versions of this function. </p>

</div>
</div>
<a id="a6953ef615122bf8aee1e1d8cf06d7027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6953ef615122bf8aee1e1d8cf06d7027">&#9670;&nbsp;</a></span>_deactivate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::_deactivate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocates the memory which is not required after the optimization of the subproblem. </p>
<p>The virtual dummy function <em><a class="el" href="classabacus_1_1_sub.html#a3738dfb4be5571ddc4bbd5b1b4afe9f0" title="Can be used as entrance point for problem specific deactivations after the subproblem optimization...">deactivate()</a></em> can perform problem specific deactivations.</p>
<p>As the function <em><a class="el" href="classabacus_1_1_sub.html#a4825021bf089410d94184c9f4c3350ec" title="Allocates and initializes memory of the subproblem at the beginning of the optimization. ">_activate()</a></em>, the function <em><a class="el" href="classabacus_1_1_sub.html#a6953ef615122bf8aee1e1d8cf06d7027" title="Deallocates the memory which is not required after the optimization of the subproblem. ">_deactivate()</a></em> is redundant in the sense that it is called only once and could be substituted by a function. However, having a future generalization to non linear-programming based branch-and-bound in mind, we keep this function. </p>

</div>
</div>
<a id="a2ecdee6ca7aa6c511a17a710c5d1594b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ecdee6ca7aa6c511a17a710c5d1594b">&#9670;&nbsp;</a></span>_fixByLogImp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::_fixByLogImp </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>newValues</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1, if a contradiction has been found, 0 otherwise. </p>
<p>The parameter <em>newValues</em> is set to <em>true</em> if a variable is fixed to value different from its value in the last solved linear program. </p>

</div>
</div>
<a id="a48afa9e501150cf7fe3c6943489289d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48afa9e501150cf7fe3c6943489289d8">&#9670;&nbsp;</a></span>_improve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::_improve </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>primalValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to find a better feasible solution. </p>
<p>If a better solution is found its value is stored in <em>primalValue</em> and we return 1, otherwise we return 0.</p>
<p>If the upper bound has been initialized with the optimum solution or with the optimum solution plus/minus one these primal heuristics are skipped.</p>
<p>The primal bound, if improved, is either updated in the function <em><a class="el" href="classabacus_1_1_sub.html#a3c42546387f8d877a3886282baea8051" title="Iteratively solves the LP-relaxation, generates constraints and/or variables. ">cutting()</a></em>, from which <em>_improved()</em> is called, are can be updated in the function <em><a class="el" href="classabacus_1_1_sub.html#a4c6b6ba861ffe427b587f43047e73420" title="Can be redefined in order to implement primal heuristics for finding feasible solutions. ">improve()</a></em> of an application in a derived class. </p>

</div>
</div>
<a id="acda5bc10e09170417f03b8d9835db652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda5bc10e09170417f03b8d9835db652">&#9670;&nbsp;</a></span>_initMakeFeas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::_initMakeFeas </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to add variables to restore infeasibilities detected at initialization time. </p>
<p>It returns 0 if variables could be activated which might restore feasibility, otherwise it returns 1.</p>
<p>The function should analyse the constraints stored in <a class="el" href="classabacus_1_1_lp_sub.html#af2f83983f269af3b862092041a7aa209" title="Buffer storing the infeasible constraints found be the constructor. ">LpSub::infeasCons_</a> and try to add inactive variables which could restore the infeasibility.</p>
<p>The new variables are only added to the set of active variables but not to the linear program since no linear program exists when this function is called. </p>

</div>
</div>
<a id="a9ee715441e1a048de31154f39ce8e518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee715441e1a048de31154f39ce8e518">&#9670;&nbsp;</a></span>_makeFeasible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::_makeFeasible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is called if the <em><a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a></em> is infeasible and adds inactive variables, which can make the <em><a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a></em> feasible again, to the set of active variables. </p>
<p>The function returns <em>0</em> if feasibility might have been restored and <em>1</em> if it is guaranteed that the linear program is infeasible on the complete variable set. </p>

</div>
</div>
<a id="a14c45db3df12178ac303379a1608210f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c45db3df12178ac303379a1608210f">&#9670;&nbsp;</a></span>_pricing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::_pricing </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>newValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doFixSet</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If <em>doFixSet</em> is <em>true</em>, then we try to fix and set variables, if all inactive variables price out correctly. </p>
<p>In this case <em>newValues</em> becomes <em>true</em> of a variable is set or fixed to a value different from its value in the last linear program.</p>
<p>In a pricing step the reduced costs of inactive variables are computed and variables with positive (negative) reduced costs in a maximization (minimization) problem are activated.</p>
<p>The function <em><a class="el" href="classabacus_1_1_sub.html#a14c45db3df12178ac303379a1608210f" title="If doFixSet is true, then we try to fix and set variables, if all inactive variables price out correc...">_pricing()</a></em> returns the 1 if no global optimality can be guaranteed, since variables have negative reduced costs, it returns 2 if before a pricing step can be performed, non-liftable constraints have to be removed, and 0 if the LP-solution is global dual feasible.</p>
<p>Also if there are no inactive variables, this function is called since it will also try to fix and set variables.</p>
<p><em>true</em> is the default value of <em>doFixSet</em>. No variables should be fixed or set if <em><a class="el" href="classabacus_1_1_sub.html#a14c45db3df12178ac303379a1608210f" title="If doFixSet is true, then we try to fix and set variables, if all inactive variables price out correc...">_pricing()</a></em> is called from <em><a class="el" href="classabacus_1_1_sub.html#a9ee715441e1a048de31154f39ce8e518" title="Is called if the LP is infeasible and adds inactive variables, which can make the LP feasible again...">_makeFeasible()</a></em>. </p>

</div>
</div>
<a id="a6c8ea1c1e311f7aa34f7b6324432a032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8ea1c1e311f7aa34f7b6324432a032">&#9670;&nbsp;</a></span>_removeCons()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::_removeCons </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the constraints with numbers <em>remove</em> from the set of active constraints. </p>

</div>
</div>
<a id="ac71f34af288a32498271acca731430d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71f34af288a32498271acca731430d0">&#9670;&nbsp;</a></span>_removeVars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::_removeVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the variables with numbers <em>remove</em> from the set of active variables. </p>

</div>
</div>
<a id="a3238c09e496c5de8ed786be154a4fad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3238c09e496c5de8ed786be154a4fad1">&#9670;&nbsp;</a></span>_selectCons()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::_selectCons </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_pool_slot.html">PoolSlot</a>&lt; <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a> &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>newCons</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects the <em>master_-&gt;maxConAdd()</em> best constraints from the buffered constraints and stores them in <em>newCons</em>. </p>

</div>
</div>
<a id="ae0822d126b98af48ff9ff5dd18c1ec1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0822d126b98af48ff9ff5dd18c1ec1d">&#9670;&nbsp;</a></span>_selectVars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::_selectVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_pool_slot.html">PoolSlot</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>newVars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects the <em>master_-&gt;maxVarAdd()</em> best variables from the buffered variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newVars</td><td>Holds the selected variables after the call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab95c7a0d07dcd8b4645f5c5291921809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95c7a0d07dcd8b4645f5c5291921809">&#9670;&nbsp;</a></span>_separate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::_separate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of generated cutting planes. </p>

</div>
</div>
<a id="a906f6a256eaada8039365a8a7d9951a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906f6a256eaada8039365a8a7d9951a1">&#9670;&nbsp;</a></span>_setByLogImp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::_setByLogImp </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>newValues</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to set variables according to logical implications of already set and fixed variables. </p>
<p>Since logical implications are problem specific the virtual function <em><a class="el" href="classabacus_1_1_sub.html#a29e4677db92404769c2a075702ae77ef" title="The default implementation of setByLogImp() does nothing. ">setByLogImp()</a></em> is called to find variables which can be set. If a variable is set to a new value, i.e., a value different from the one in the last solved <a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a>, <em>newValues</em> is set to <em>true</em>. If such a setting implies a contradiction, <em><a class="el" href="classabacus_1_1_sub.html#a906f6a256eaada8039365a8a7d9951a1" title="Tries to set variables according to logical implications of already set and fixed variables...">_setByLogImp()</a></em> returns 1, otherwise it returns 0. </p>

</div>
</div>
<a id="ab8b20e72f968c19fc4269836627ea427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b20e72f968c19fc4269836627ea427">&#9670;&nbsp;</a></span>_varEliminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::_varEliminate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of eliminated variables. </p>
<p>Only dynamic variables can be eliminated. </p>

</div>
</div>
<a id="a019fc4f549f7de90f503de8e8fe9d55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019fc4f549f7de90f503de8e8fe9d55c">&#9670;&nbsp;</a></span>actCon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_active.html">Active</a>&lt;<a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a>&gt;* abacus::Sub::actCon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the currently active constraints. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00213">213</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ae22a4eb3419a6665e28cbeb0b592bcba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22a4eb3419a6665e28cbeb0b592bcba">&#9670;&nbsp;</a></span>activate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::activate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be used as an entrance point for problem specific activations. </p>
<p>The default implementation does nothing. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00555">555</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a886f08388d8a23e8b7edb5e05fcc718a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886f08388d8a23e8b7edb5e05fcc718a">&#9670;&nbsp;</a></span>activateVars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::activateVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_pool_slot.html">PoolSlot</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>newVars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the variables stored in the pool slots of <em>newVars</em> to the set of active variables, but not to the linear program. </p>
<p>If the new number of variables exceeds the maximal number of variables an automatic reallocation is performed. </p>

</div>
</div>
<a id="aafe61332b73e4acdaf15fae6dfd319c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe61332b73e4acdaf15fae6dfd319c0">&#9670;&nbsp;</a></span>actVar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_active.html">Active</a>&lt;<a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>&gt;* abacus::Sub::actVar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the currently active variables. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00216">216</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="aae222662b978e24c00bb491b00f288ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae222662b978e24c00bb491b00f288ed">&#9670;&nbsp;</a></span>addBranchingConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::addBranchingConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_pool_slot.html">PoolSlot</a>&lt; <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a> &gt; *&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a branching constraint to the constraint buffer. </p>
<p>This constraint is automatically added at the beginning of the cutting plane algorithm. It should be used in definitions of the pure virtual function <em>BRANCHRULE::extract()</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>0 If the constraint could be added, 1 otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A pointer to the pool slot containing the branching constraint. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01823">1823</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a9f3ddf271847abc08dd0ab8132afb5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3ddf271847abc08dd0ab8132afb5fd">&#9670;&nbsp;</a></span>addConBufferSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::addConBufferSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be used to determine the maximal number of the constraints which still can be added to the constraint buffer. </p>
<p>A separation algorithm should stop as soon as the number of generated constraints reaches this number because further work is useless.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of constraints which still can be inserted into the constraint buffer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01828">1828</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a89ba1c129b6d87aee50dc45a36bb0db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ba1c129b6d87aee50dc45a36bb0db5">&#9670;&nbsp;</a></span>addCons() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::addCons </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_pool.html">Pool</a>&lt; <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a> &gt; *&#160;</td>
          <td class="paramname"><em>pool</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; bool &gt; *&#160;</td>
          <td class="paramname"><em>keepInPool</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>rank</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to add new constraints to the constraint buffer and a pool. </p>
<p>The memory management of added constraints is passed to ABACUS by calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraints</td><td>The new constraints. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool in which the new constraints are inserted. If the value of this argument is 0, then the cut pool of the master is selected. Its default value is 0. </td></tr>
    <tr><td class="paramname">keepInPool</td><td>If <em></em>(*keepInPool)[i] is <em>true</em>, then the constraint stays in the pool even if it is not activated. The default value is a 0-pointer. </td></tr>
    <tr><td class="paramname">rank</td><td>If this pointer to a buffer is nonzero, this buffer should store a rank for each constraint. The greater the rank, the better the variable. The default value of <em>rank</em> is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of added constraints. </dd></dl>

</div>
</div>
<a id="ab9623edf0d0714db06a39a477f55e3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9623edf0d0714db06a39a477f55e3d3">&#9670;&nbsp;</a></span>addCons() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::addCons </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_pool_slot.html">PoolSlot</a>&lt; <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a> &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>newCons</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds constraints to the active constraints and the linear program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newCons</td><td>A buffer storing the pool slots of the new constraints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of added constraints. </dd></dl>

</div>
</div>
<a id="a69f8a09630f7ad302431078abdd6962f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f8a09630f7ad302431078abdd6962f">&#9670;&nbsp;</a></span>addVarBufferSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::addVarBufferSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be used to determine the maximal number of the variables which still can be added to the variable buffer. </p>
<p>A pricing algorithm should stop as soon as the number of generated variables reaches this number because further work is useless.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of variables which still can be inserted into the variable buffer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01833">1833</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a47f2926e01b7ef45d8acbe6f478ce293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f2926e01b7ef45d8acbe6f478ce293">&#9670;&nbsp;</a></span>addVars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::addVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_pool.html">Pool</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; *&#160;</td>
          <td class="paramname"><em>pool</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; bool &gt; *&#160;</td>
          <td class="paramname"><em>keepInPool</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>rank</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to add new variables to the variable buffer and a pool. </p>
<p>The memory management of added variables is passed to ABACUS by calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>The new variables. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool in which the new variables are inserted. If the value of this argument is 0, then the default variable pool is taken. The default value is 0. </td></tr>
    <tr><td class="paramname">keepInPool</td><td>If <em></em>(*keepInPool)[i] is <em>true</em>, then the variable stays in the pool even if it is not activated. The default value is a 0-pointer. </td></tr>
    <tr><td class="paramname">rank</td><td>If this pointer to a buffer is nonzero, this buffer should store a rank for each variable. The greater the rank, the better the variable. The default value of <em>rank</em> is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of added variables. </dd></dl>

</div>
</div>
<a id="aa76c54f5d68d3137445bce5ec9675ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76c54f5d68d3137445bce5ec9675ab1">&#9670;&nbsp;</a></span>addVars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::addVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_pool_slot.html">PoolSlot</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>newVars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds both the variables in <em>newVars</em> to the set of active variables and to the linear program of the subproblem. </p>
<p>If the new number of variables exceeds the maximal number of variables an automatic reallocation is performed.</p>
<p>We require this feature in derived classes if variables of <em>newVars</em> can be discarded if they are already active.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newVars</td><td>A buffer storing the pool slots of the new variables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of added variables. </dd></dl>

</div>
</div>
<a id="a0319ff82342610ca367e6196c79bac35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0319ff82342610ca367e6196c79bac35">&#9670;&nbsp;</a></span>addVarsToLp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::addVarsToLp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_pool_slot.html">PoolSlot</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>newVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_f_s_var_stat.html">FSVarStat</a> *&gt; *&#160;</td>
          <td class="paramname"><em>localStatus</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the variables stored in the pool slots of <em>newVars</em> to the linear program. <em>localStatus</em> can specify a local status of fixing and setting. </p>
<p>If the local <a class="el" href="classabacus_1_1_f_s_var_stat.html" title="Status of fixed and set variables. ">FSVarStat</a> of the added variables differs from their global status, then this local status can be stated in <em>localStatus</em>. Per default the value of <em>localStatus</em> is 0. </p>

</div>
</div>
<a id="aa02ac5e6bb195e7ce583d1fbda047cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02ac5e6bb195e7ce583d1fbda047cf7">&#9670;&nbsp;</a></span>ancestor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool abacus::Sub::ancestor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classabacus_1_1_sub.html">Sub</a> *&#160;</td>
          <td class="paramname"><em>sub</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this subproblem is an ancestor of the subproblem <em>sub</em>, false otherwise. </p>
<p>We define that a subproblem is also an ancestor of its own.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sub</td><td>A pointer to a subproblem. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4a2e6d38295199c8faf1cdafe19bd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a2e6d38295199c8faf1cdafe19bd5a">&#9670;&nbsp;</a></span>basicConEliminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::basicConEliminate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves all dynamic constraints having basic slack variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remove</td><td>Stores the nonbinding constraints. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61092d362478ab614782ae600942762d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61092d362478ab614782ae600942762d">&#9670;&nbsp;</a></span>betterDual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abacus::Sub::betterDual </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <em>x</em> is better than the best known dual bound of the subproblem, false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01889">1889</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a3931b3ea0464ffff3b23cccc191b39a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3931b3ea0464ffff3b23cccc191b39a3">&#9670;&nbsp;</a></span>boundCrash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abacus::Sub::boundCrash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the dual bound is worse than the best known primal bound, false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01897">1897</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a63e6b365d422803e6a0f8020e53576b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e6b365d422803e6a0f8020e53576b3">&#9670;&nbsp;</a></span>branching()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classabacus_1_1_sub.html#aa9fe7d3a08b8ba4d97a8e4927178256e">PHASE</a> abacus::Sub::branching </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs branching. </p>
<p>Is called if the global lower bound of a branch-and-cut node is still strictly less than the local upper bound, but either no violated cutting planes or variables are found, or we abort the cutting phase for some other strategic reason (e.g., observation of a tailing off effect, or branch pausing).</p>
<p>Usually, two new subproblems are generated. However, our implementation of <em><a class="el" href="classabacus_1_1_sub.html#a63e6b365d422803e6a0f8020e53576b3" title="Performs branching. ">branching()</a></em> is more sophisticated that allows different branching. Moreover, we also check if this node is only paused. If this is the case the node is put back into the list of open branch-and-cut nodes without generating sons of this node.</p>
<p>Finally if none of the previous conditions is satisfied we generate new subproblems.</p>
<dl class="section return"><dt>Returns</dt><dd>Done If sons of the subproblem could be generated, </dd>
<dd>
Fathoming otherwise. </dd></dl>

</div>
</div>
<a id="a0a77f2d3be3fd16e33ee1afc309e5d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a77f2d3be3fd16e33ee1afc309e5d24">&#9670;&nbsp;</a></span>branchingOnVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::branchingOnVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>rules</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates branching rules for two new subproblems by selecting a branching variable with the function <em><a class="el" href="classabacus_1_1_sub.html#a02aacd191c773efc09d75eaa810f81fd" title="Chooses a branching variable. ">selectBranchingVariable()</a></em>. </p>
<p>If a new branching variable selection strategy should be used the function <em><a class="el" href="classabacus_1_1_sub.html#a02aacd191c773efc09d75eaa810f81fd" title="Chooses a branching variable. ">selectBranchingVariable()</a></em> should be redefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rules</td><td>If branching rules are found, then they are stored in this buffer. The length of this buffer is the number of active variables of the subproblem. If more branching rules are generated a reallocation has to be performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 If branching rules could be found, 1 otherwise </dd></dl>

</div>
</div>
<a id="a73a26e269e8af3c052b7c76ade24b1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a26e269e8af3c052b7c76ade24b1a9">&#9670;&nbsp;</a></span>branchRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a>* abacus::Sub::branchRule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the branching rule of the subproblem. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00355">355</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a889be067e2a76eead7f19a8c4a6a2ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889be067e2a76eead7f19a8c4a6a2ce2">&#9670;&nbsp;</a></span>chooseLpMethod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classabacus_1_1_l_p.html#a80d390b461dca15f5aba8068995b0063">LP::METHOD</a> abacus::Sub::chooseLpMethod </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nVarRemoved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nConRemoved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nVarAdded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nConAdded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Controls the method used to solve a linear programming relaxation. </p>
<p>The default implementation chooses the barrier method for the first linear program of the root node and for all other linear programs it tries to choose a method such that phase 1 of the simplex method is not required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nVarRemoved</td><td>The number of removed variables. </td></tr>
    <tr><td class="paramname">nConRemoved</td><td>The number of removed constraints. </td></tr>
    <tr><td class="paramname">nVarAdded</td><td>The number of added variables. </td></tr>
    <tr><td class="paramname">nConAdded</td><td>The number of added constraint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The method the next linear programming relaxation is solved with. </dd></dl>

</div>
</div>
<a id="abe81fab62b5a2254f5012db64d457358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe81fab62b5a2254f5012db64d457358">&#9670;&nbsp;</a></span>closeHalf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::closeHalf </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>branchVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499">VarType::TYPE</a>&#160;</td>
          <td class="paramname"><em>branchVarType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches a branching variable of type <em>branchVarType</em>, with fraction as close to \(0.5\) as possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">branchVar</td><td>Holds the branching variable if one is found. </td></tr>
    <tr><td class="paramname">branchVarType</td><td>The type of the branching variable can be restricted either to <a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499aca2dbae161ba1a19845778cd316c6097" title="A variable having value 0 or 1. ">VarType::Binary</a> or <a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499a266b2a3b4e89817bfa2f812154ab178a" title="A general integer variable. ">VarType::Integer</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 If a branching variable is found, 1 otherwise. </dd></dl>

</div>
</div>
<a id="a2e55fb194778da501e8c03efa631f541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e55fb194778da501e8c03efa631f541">&#9670;&nbsp;</a></span>closeHalf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::closeHalf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>branchVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499">VarType::TYPE</a>&#160;</td>
          <td class="paramname"><em>branchVarType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches searches several possible branching variable of type <em>branchVarType</em>, with fraction as close to \(0.5\) as possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">branchVar</td><td>Stores the possible branching variables. </td></tr>
    <tr><td class="paramname">branchVarType</td><td>The type of the branching variable can berestricted either to <a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499aca2dbae161ba1a19845778cd316c6097" title="A variable having value 0 or 1. ">VarType::Binary</a> or <a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499a266b2a3b4e89817bfa2f812154ab178a" title="A general integer variable. ">VarType::Integer</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 If at least one branching variable is found, 1 otherwise. </dd></dl>

</div>
</div>
<a id="abafd465c112581df369e86693195e8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafd465c112581df369e86693195e8ae">&#9670;&nbsp;</a></span>closeHalfExpensive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::closeHalfExpensive </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>branchVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499">VarType::TYPE</a>&#160;</td>
          <td class="paramname"><em>branchVarType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects a single branching variable of type <em>branchVarType</em>, with fractional part close to \(0.5\) and high absolute objective function coefficient. </p>
<p>This is the default strategy from the TSP project.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">branchVar</td><td>Holds the number of the branching variable if one is found. </td></tr>
    <tr><td class="paramname">branchVarType</td><td>The type of the branching variable can be restricted either to <a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499aca2dbae161ba1a19845778cd316c6097" title="A variable having value 0 or 1. ">VarType::Binary</a> or <a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499a266b2a3b4e89817bfa2f812154ab178a" title="A general integer variable. ">VarType::Integer</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 If a branching variable is found, 1 otherwise. </dd></dl>

</div>
</div>
<a id="ae633fe804712ea37fa83a046cd47cc40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae633fe804712ea37fa83a046cd47cc40">&#9670;&nbsp;</a></span>closeHalfExpensive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::closeHalfExpensive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499">VarType::TYPE</a>&#160;</td>
          <td class="paramname"><em>branchVarType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects several candidates for branching variables of type <em>branchVarType</em>. </p>

</div>
</div>
<a id="a5069c072c786c83e3db9ad322730e0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5069c072c786c83e3db9ad322730e0bd">&#9670;&nbsp;</a></span>compareBranchingSampleRanks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::compareBranchingSampleRanks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rank1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rank2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the ranks of two branching samples. </p>
<p>For maximimization problem that rank is better for which the maximal rank of a rule is minimal, while for minimization problem the rank is better for which the minimal rank of a rule is maximal. If this value equals for both ranks we continue with the secand greatest value, etc.</p>
<dl class="section return"><dt>Returns</dt><dd>1 If <em>rank1</em> is better. </dd>
<dd>
0 If both ranks are equal. </dd>
<dd>
-1 If <em>rank2</em> is better. </dd></dl>

</div>
</div>
<a id="a3de91731faf1ec85059209adec248125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de91731faf1ec85059209adec248125">&#9670;&nbsp;</a></span>conEliminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::conEliminate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be used as an entry point for application specific elimination of constraints. </p>
<p>The default implementation of this function calls either the function <em><a class="el" href="classabacus_1_1_sub.html#a2aa2ac08974bc4f8be27290a32fa9ee7" title="Retrieves the dynamic constraints with slack exceeding the value given by the parameter ConElimEps...">nonBindingConEliminate()</a></em> or the function <em><a class="el" href="classabacus_1_1_sub.html#ad4a2e6d38295199c8faf1cdafe19bd5a" title="Retrieves all dynamic constraints having basic slack variable. ">basicConEliminate()</a></em> depending on the constraint elimination mode of the master that is initialized via the parameter file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remove</td><td>The constraints that should be eliminated must be inserted in this buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26712852d933c7ce5e04bb07e16ad00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26712852d933c7ce5e04bb07e16ad00e">&#9670;&nbsp;</a></span>conRealloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::conRealloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reallocates memory that at most <em>newSize</em> constraints can be handled in the subproblem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>The new maximal number of constraints of the subproblem. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a2fe1cd061f8c2ba19fa518bbb481e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2fe1cd061f8c2ba19fa518bbb481e5">&#9670;&nbsp;</a></span>constraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_constraint.html">Constraint</a> * abacus::Sub::constraint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the <em>i</em>-th active constraint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The constraint being accessed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01858">1858</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ac4dd78fb330f3494b43349c10c57cd62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4dd78fb330f3494b43349c10c57cd62">&#9670;&nbsp;</a></span>constraintPoolSeparation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::constraintPoolSeparation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ranking</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_pool.html">Pool</a>&lt; <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a> &gt; *&#160;</td>
          <td class="paramname"><em>pool</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minViolation</em> = <code>0.001</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to generate inactive constraints from a pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ranking</td><td>This parameter indicates how the ranks of violated constraints should be computed (0: no ranking; 1: violation is rank, 2: absolute value of violation is rank, 3: rank determined by <a class="el" href="classabacus_1_1_con_var.html#a0fff7dcde419b3c82ef6dcd0c75e1404" title="The function should return a rank associated with the constraint/variable. ">ConVar::rank()</a>). The default value is 0. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool the constraints are generated from. If <em>pool</em> is 0, then the default constraint pool is used. The default value of <em>pool</em> is 0. </td></tr>
    <tr><td class="paramname">minViolation</td><td>A violated constraint/variable is only added if the absolute value of its violation is at least <em>minAbsViolation</em>. The default value is <em>0.001</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of generated constraints. </dd></dl>

</div>
</div>
<a id="a3c42546387f8d877a3886282baea8051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c42546387f8d877a3886282baea8051">&#9670;&nbsp;</a></span>cutting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classabacus_1_1_sub.html#aa9fe7d3a08b8ba4d97a8e4927178256e">PHASE</a> abacus::Sub::cutting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iteratively solves the LP-relaxation, generates constraints and/or variables. </p>
<p>Also generating variables can be regarded as "cutting", namely as generating cuts for the dual problem. A reader even studying these lines has been very brave! Therefore, the first reader of these lines is invited to a beer from the author.</p>
<dl class="section return"><dt>Returns</dt><dd>Fathoming If one of the conditions for fathoming the subproblem is satisfied. </dd>
<dd>
Branching If the subproblem should be splitted in further subproblems. </dd></dl>

</div>
</div>
<a id="a3738dfb4be5571ddc4bbd5b1b4afe9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3738dfb4be5571ddc4bbd5b1b4afe9f0">&#9670;&nbsp;</a></span>deactivate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::deactivate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be used as entrance point for problem specific deactivations after the subproblem optimization. </p>
<p>The default version of this function does nothing. This function is only called if the function <em><a class="el" href="classabacus_1_1_sub.html#ae22a4eb3419a6665e28cbeb0b592bcba" title="Can be used as an entrance point for problem specific activations. ">activate()</a></em> for the subproblem has been executed. This function is called from <em><a class="el" href="classabacus_1_1_sub.html#a6953ef615122bf8aee1e1d8cf06d7027" title="Deallocates the memory which is not required after the optimization of the subproblem. ">_deactivate()</a></em>. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00563">563</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a8e6b032a0f3a6ae9d87b845998ca3bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6b032a0f3a6ae9d87b845998ca3bce">&#9670;&nbsp;</a></span>dualBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double abacus::Sub::dualBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a bound which is "better" than the optimal solution of the subproblem w.r.t. the sense of the optimization. </p>
<p>I.e., it returns an upper for a maximization problem or a lower bound for a minimization problem, respectively. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00181">181</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a09d2e2f05d17dc1210460c606b0a33b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d2e2f05d17dc1210460c606b0a33b0">&#9670;&nbsp;</a></span>dualBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::Sub::dualBound </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the dual bound of the subproblem. </p>
<p>If the subproblem is the root node of the enumeration tree and the new value is better than its dual bound, also the global dual bound is updated. It is an error if the dual bound gets worse.</p>
<p>In normal applications it is not required to call this function explicitly. This is already done by ABACUS during the subproblem optimization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The new value of the dual bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af83bd3cd76a57c50870da3fbf130eb85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83bd3cd76a57c50870da3fbf130eb85">&#9670;&nbsp;</a></span>dualRound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::Sub::dualRound </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value that should be rounded if possible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If all objective function values of feasible solutions are integer the function <em><a class="el" href="classabacus_1_1_sub.html#af83bd3cd76a57c50870da3fbf130eb85">dualRound()</a></em> returns <em>x</em> rounded up to the next integer if this is a minimization problem, or <em>x</em> rounded down to the next integer if this is a maximization problem, respectively. Otherwise, the return value is <em>x</em>. </dd></dl>

</div>
</div>
<a id="a63a8853e72d40dc7177c2a775cad1669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a8853e72d40dc7177c2a775cad1669">&#9670;&nbsp;</a></span>exceptionBranch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool abacus::Sub::exceptionBranch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be used to specify a problem specific criteria for enforcing a branching step. </p>
<p>This criterium is checked before the separation or pricing. The default implementation always returns <em>false</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>true If the subproblem should be fathomed, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01424">1424</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a94768c41fb19ce07d9e6fbfcd16c4564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94768c41fb19ce07d9e6fbfcd16c4564">&#9670;&nbsp;</a></span>exceptionFathom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool abacus::Sub::exceptionFathom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be used to specify a problem specific fathoming criterium that is checked before the separation or pricing. </p>
<p>The default implementation always returns <em>false</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>true If the subproblem should be fathomed, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01415">1415</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a52d759383224a35cab360cc54b9d559a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d759383224a35cab360cc54b9d559a">&#9670;&nbsp;</a></span>father()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classabacus_1_1_sub.html">Sub</a>* abacus::Sub::father </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the father of the subproblem in the branch-and-bound tree. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00198">198</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a1da75b4e2968be2d260fef3635b4e08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da75b4e2968be2d260fef3635b4e08a">&#9670;&nbsp;</a></span>fathom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::fathom </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reoptimize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fathoms a node and recursively tries to fathom its father. </p>
<p>If the root of the remaining branch-and-cut tree is fathomed we are done since the optimization problem has been solved.</p>
<p>Otherwise, we count the number of unfathomed sons of the father of the subproblem being fathomed. If all sons of the father are fathomed it is recursively fathomed, too. If the father is the root of the remaining branch-and-cut tree and only one of its sons is unfathomed, then this unfathomed son becomes the new root of the remaining branch-and-cut tree.</p>
<p>We could stop the recursive fathoming already at the root of the remaining branch-and-cut tree. But, we proceed until the root of the complete tree was visited to be really correct.</p>
<dl class="section note"><dt>Note</dt><dd>Use the function <em>ExceptionFathom()</em> for specifying problem specific fathoming criteria.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reoptimize</td><td>If <em>reoptimize</em> is <em>true</em>, then we perform a reoptimization in the new root. This is controlled via a parameter since it might not be desirable when we find a new root during the fathoming of a complete subtree with the function <em><a class="el" href="classabacus_1_1_sub.html#adc79787a7be7c11797db7b608587da00" title="Fathoms all nodes in the subtree rooted at this subproblem. ">fathomTheSubTree()</a></em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e70257891b0fc53557bfd32a07e0649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e70257891b0fc53557bfd32a07e0649">&#9670;&nbsp;</a></span>fathoming()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classabacus_1_1_sub.html#aa9fe7d3a08b8ba4d97a8e4927178256e">PHASE</a> abacus::Sub::fathoming </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fathoms the node, and if certain conditions are satisfied, also its ancestor. </p>
<p>The third central phase of the optimization of a subproblem is the <em>Fathoming</em> of a subproblem. A subproblem is fathomed if it can be guaranteed that this subproblem cannot contain a better solution than the best known one. This is the case if the global upper bound does not exceed the local lower bound (maximization problem assumed) or the subproblem cannot contain a feasible solution either if there is a fixing/setting contradiction or the <em>LP-relaxation</em> turns out to be infeasible.</p>
<dl class="section note"><dt>Note</dt><dd>Use the function <em>ExceptionFathom()</em> for specifying problem specific fathoming criteria.</dd></dl>
<p>The called function <em><a class="el" href="classabacus_1_1_sub.html#a1da75b4e2968be2d260fef3635b4e08a" title="Fathoms a node and recursively tries to fathom its father. ">fathom()</a></em> fathoms the subproblem itself and recursively also tries to fathom its father in the enumeration tree. The argument of <em><a class="el" href="classabacus_1_1_sub.html#a1da75b4e2968be2d260fef3635b4e08a" title="Fathoms a node and recursively tries to fathom its father. ">fathom()</a></em> is <em>true</em> as a possibly detected new root should be reoptimized in order to receive better criteria for fixing variables by reduced costs.</p>
<p>In the parallel version, only the subproblem itself is fathomed. No processed unfathomed nodes are kept in memory (father_=0).</p>
<dl class="section return"><dt>Returns</dt><dd>The function always returns <em>Done</em>. </dd></dl>

</div>
</div>
<a id="adc79787a7be7c11797db7b608587da00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc79787a7be7c11797db7b608587da00">&#9670;&nbsp;</a></span>fathomTheSubTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::fathomTheSubTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fathoms all nodes in the subtree rooted at this subproblem. </p>
<p><em>Dormant</em> and <em>Unprocessed</em> nodes are also removed from the set of open subproblems.</p>
<p>If the subproblem is already <em>Fathomed</em> we do not have to proceed in this branch. Otherwise, we fathom the node and continue with all its sons. The actual fathoming starts at the unfathomed leaves of the subtree and recursively goes up through the tree. </p>

</div>
</div>
<a id="aef66b56a1aa2069cd9676c0d8ae2a3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef66b56a1aa2069cd9676c0d8ae2a3c8">&#9670;&nbsp;</a></span>feasible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool abacus::Sub::feasible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must check the feasibility of a solution of the LP-relaxation. </p>
<p>If the function returns <em>true</em> and the value of the primal bound is worse than the value of this feasible solution, the value of the primal bound is updated automatically.</p>
<dl class="section return"><dt>Returns</dt><dd>true If the LP-solution is feasible, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classogdf_1_1_min_steiner_tree_directed_cut_1_1_sub.html#a141a13d942bb53063d50e7741914dab7">ogdf::MinSteinerTreeDirectedCut&lt; T &gt;::Sub</a>, <a class="el" href="classogdf_1_1cluster__planarity_1_1_c_planarity_sub.html#ae332589faccf22f66c467be76d52e0d3">ogdf::cluster_planarity::CPlanaritySub</a>, and <a class="el" href="classogdf_1_1cluster__planarity_1_1_max_c_planar_sub.html#a779106f6fe44a9de756e69fee1a012f2">ogdf::cluster_planarity::MaxCPlanarSub</a>.</p>

</div>
</div>
<a id="a732025b90331ed19140ef4bb9b72bb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732025b90331ed19140ef4bb9b72bb7d">&#9670;&nbsp;</a></span>findNonFixedSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::findNonFixedSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>branchVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499">VarType::TYPE</a>&#160;</td>
          <td class="paramname"><em>branchVarType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects the first variables that are neither fixed nor set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">branchVar</td><td>Holds the number of the possible branching variables if one is found. </td></tr>
    <tr><td class="paramname">branchVarType</td><td>The type of the branching variable can be restricted either to <a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499aca2dbae161ba1a19845778cd316c6097" title="A variable having value 0 or 1. ">VarType::Binary</a> or <a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499a266b2a3b4e89817bfa2f812154ab178a" title="A general integer variable. ">VarType::Integer</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 If at least one variable neither fixed nor set is found, 1 otherwise. </dd></dl>

</div>
</div>
<a id="a7f7891d14913788495c2b714a56e4a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7891d14913788495c2b714a56e4a4a">&#9670;&nbsp;</a></span>findNonFixedSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::findNonFixedSet </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>branchVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499">VarType::TYPE</a>&#160;</td>
          <td class="paramname"><em>branchVarType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects the first variable that is neither fixed nor set. </p>
<dl class="section return"><dt>Returns</dt><dd>0 If a variable neither fixed nor set is found, 1 otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">branchVar</td><td>Holds the number of the branching variable if one is found. </td></tr>
    <tr><td class="paramname">branchVarType</td><td>The type of the branching have (<a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499aca2dbae161ba1a19845778cd316c6097" title="A variable having value 0 or 1. ">VarType::Binary</a> or <a class="el" href="classabacus_1_1_var_type.html#a9889dc5de3859ff3886a1fd9983e0499a266b2a3b4e89817bfa2f812154ab178a" title="A general integer variable. ">VarType::Integer</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab198d2caec6321608bc5caecf8691e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab198d2caec6321608bc5caecf8691e3">&#9670;&nbsp;</a></span>fix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::fix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_f_s_var_stat.html">FSVarStat</a> *&#160;</td>
          <td class="paramname"><em>newStat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fixes a variable. </p>
<p>If the variable which is currently fixed is already set then we must not change its bounds in the <a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a> since it might be eliminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The number of the variable being fixed. </td></tr>
    <tr><td class="paramname">newStat</td><td>A pointer to an object storing the new status of the variable. </td></tr>
    <tr><td class="paramname">newValue</td><td>If the variable is fixed to a value different from the one of the last LP-solution, the argument <em>newValue</em> is set to <em>true</em>. Otherwise, it is set to <em>false</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 If a contradiction is found, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a36040e50ff2659d8990afb0626d130b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36040e50ff2659d8990afb0626d130b7">&#9670;&nbsp;</a></span>fixAndSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::fixAndSet </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>newValues</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to fix and set variables both by logical implications and reduced cost criteria. </p>
<p>Actually, variables fixed or set to 0 could be eliminated. However, this could lead to a loss of important structural information for fixing and setting further variables later, for the computation of feasible solutions, for the separation and for detecting contradictions. Therefore, we do not eliminate these variables per default.</p>
<dl class="section return"><dt>Returns</dt><dd>1 If a contradiction is found, 0 otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newValues</td><td>If a variables is set or fixed to a value different from the last LP-solution, <em>newValues</em> is set to <em>true</em>, otherwise it is set to <em>false</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3353315f00b3bfcfa103dfe6ef93748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3353315f00b3bfcfa103dfe6ef93748">&#9670;&nbsp;</a></span>fixAndSetTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool abacus::Sub::fixAndSetTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Controls if variables should be fixed or set when all variables price out correctly. </p>
<p>The default implementation always returns <em>true</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>true If variables should be fixed and set, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01138">1138</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ae2ceae0290ba087243d4e265006a1b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ceae0290ba087243d4e265006a1b0c">&#9670;&nbsp;</a></span>fixByLogImp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::fixByLogImp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_f_s_var_stat.html">FSVarStat</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should collect the numbers of the variables to be fixed in <em>variable</em> and the respective statuses in <em>status</em>. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01056">1056</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a356eb76abe3c3eafe11267e087f81cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356eb76abe3c3eafe11267e087f81cc2">&#9670;&nbsp;</a></span>fixByRedCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::fixByRedCost </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>newValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveCand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to fix variables according to the reduced cost criterion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newValues</td><td>If variables are fixed to different values as in the last solved linear program, then <em>newValues</em> becomes true. </td></tr>
    <tr><td class="paramname">saveCand</td><td>If <em>saveCand</em> is <em>true</em>, then a new list of candidates for later calls is compiled. This is only possible when the root of the remaining branch-and-bound is processed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 If a contradiction is found, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a28743afe6f5292c150ad6b6708aca2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28743afe6f5292c150ad6b6708aca2a5">&#9670;&nbsp;</a></span>fixing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::fixing </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>newValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveCand</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to fix variables by reduced cost criteria and logical implications. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newValues</td><td>The parameter <em>newValues</em> becomes <em>true</em> if variables are fixed to other values as in the current LP-solution. </td></tr>
    <tr><td class="paramname">saveCand</td><td>If the parameter <em>saveCand</em> is <em>true</em> a new candidate list of variables for fixing is generated. The default value of <em>saveCand</em> is false. Candidates should not be saved if fixing is performed after the addition of variables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 If a contradiction is found, 0 otherwise. </dd></dl>

</div>
</div>
<a id="acb38dae6842123c906092631ca4aff5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb38dae6842123c906092631ca4aff5f">&#9670;&nbsp;</a></span>fixSetNewBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::Sub::fixSetNewBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value which the upper and lower bounds of a variable should take after it is fixed or set. </p>

</div>
</div>
<a id="a631b64bf67b97816e398feaafeb362f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631b64bf67b97816e398feaafeb362f8">&#9670;&nbsp;</a></span>forceExactSolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abacus::Sub::forceExactSolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether using the exact solver is forced. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00147">147</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a8b0539f5d44119789bc4ae9b7a9d26f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0539f5d44119789bc4ae9b7a9d26f3">&#9670;&nbsp;</a></span>fsVarStat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_f_s_var_stat.html">FSVarStat</a>* abacus::Sub::fsVarStat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the status of fixing/setting of the <em>i</em>-th variable. </p>
<p>In a branch-and-cut-and-price algorithm we also would have to refer to the global variable status. While this subproblem is processed another subproblem could change the global status.</p>
<dl class="section note"><dt>Note</dt><dd>This is the local status of fixing/setting that might differ from the global status of fixing/setting of the variable (<em>variable(i)-&gt;<a class="el" href="classabacus_1_1_sub.html#a8b0539f5d44119789bc4ae9b7a9d26f3" title="Returns a pointer to the status of fixing/setting of the i-th variable. ">fsVarStat()</a></em>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The number of the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the status of fixing/setting of the <em>i-th</em> variable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00291">291</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ae37388e582ebbc4c6f303ad9a60bcd8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37388e582ebbc4c6f303ad9a60bcd8a">&#9670;&nbsp;</a></span>generateBranchRules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::generateBranchRules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>rules</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to find rules for splitting the current subproblem in further subproblems. </p>
<p>Per default we generate rules for branching on variables (<em><a class="el" href="classabacus_1_1_sub.html#a0a77f2d3be3fd16e33ee1afc309e5d24" title="Generates branching rules for two new subproblems by selecting a branching variable with the function...">branchingOnVariable()</a></em>). But by redefining this function in a derived class any other branching strategy can be implemented.</p>
<dl class="section return"><dt>Returns</dt><dd>0 If branching rules could be found, 1 otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rules</td><td>If branching rules are found, then they are stored in this buffer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00575">575</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a7cbc981714ace71da11273cd2ab30389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cbc981714ace71da11273cd2ab30389">&#9670;&nbsp;</a></span>generateLp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classabacus_1_1_lp_sub.html">LpSub</a>* abacus::Sub::generateLp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instantiates an <em><a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a></em> for the solution of the <em>LP-relaxation</em> in this subproblem. </p>
<p>This function is redefined in a derived class for a specific <em>LP-solver</em> interface</p>
<p>This function is defined in the file <code>lpif.cpp</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an object of type <a class="el" href="classabacus_1_1_lp_sub.html" title="The linear program of a subproblem. ">LpSub</a>. </dd></dl>

</div>
</div>
<a id="aa252b9d1b9d6d0bd844fd292883bb29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa252b9d1b9d6d0bd844fd292883bb29a">&#9670;&nbsp;</a></span>generateSon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classabacus_1_1_sub.html">Sub</a>* abacus::Sub::generateSon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a> *&#160;</td>
          <td class="paramname"><em>rule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to an object of a problem specific subproblem, which is generated from the current subproblem by branching rule <em>rule</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rule</td><td>The branching rule with which the subproblem is generated. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classogdf_1_1_min_steiner_tree_directed_cut_1_1_sub.html#afc304270b06c95b75b46f5e52e76fedf">ogdf::MinSteinerTreeDirectedCut&lt; T &gt;::Sub</a>, <a class="el" href="classogdf_1_1cluster__planarity_1_1_c_planarity_sub.html#a00cd4ce24d5dc6db72113c0809d352f2">ogdf::cluster_planarity::CPlanaritySub</a>, and <a class="el" href="classogdf_1_1cluster__planarity_1_1_max_c_planar_sub.html#a70c3a023bfbc7e2a76a034fe92ee2d50">ogdf::cluster_planarity::MaxCPlanarSub</a>.</p>

</div>
</div>
<a id="a945acefc7e42bf224d4fa35103d754b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945acefc7e42bf224d4fa35103d754b3">&#9670;&nbsp;</a></span>getBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::getBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the status of the variables and the slack variables. </p>

</div>
</div>
<a id="acf90413f54f6b222b47128fb612e4f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf90413f54f6b222b47128fb612e4f6c">&#9670;&nbsp;</a></span>goodCol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool abacus::Sub::goodCol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_column.html">Column</a> &amp;&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>The column of the variable. </td></tr>
    <tr><td class="paramname">row</td><td>The row of the basis inverse associated with the infeasible variable. </td></tr>
    <tr><td class="paramname">x</td><td>The LP-value of the infeasible variable. </td></tr>
    <tr><td class="paramname">lb</td><td>The lower bound of the infeasible variable. </td></tr>
    <tr><td class="paramname">ub</td><td>The upper bound of the infeasible variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the column <em>col</em> might restore feasibiblity if the variable with value <em>x</em> turns out to be infeasible, false otherwise. </dd></dl>

</div>
</div>
<a id="ae50d9403f536bb35c92fc6542c4a5ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50d9403f536bb35c92fc6542c4a5ca2">&#9670;&nbsp;</a></span>guarantee()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double abacus::Sub::guarantee </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>May not be called if the lower bound is 0 and upper bound not equal to 0. </p>
<p>The guarantee that can be given for the subproblem. </p>

</div>
</div>
<a id="af44c6552a2cd18a343c44fcb29dbe9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44c6552a2cd18a343c44fcb29dbe9af">&#9670;&nbsp;</a></span>guaranteed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool abacus::Sub::guaranteed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true If the lower and the upper bound of the subproblem satisfies the guarantee requirements, false otherwise. </dd></dl>

</div>
</div>
<a id="a6fd6f95c28ec9d4fd820e92fe69ace53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd6f95c28ec9d4fd820e92fe69ace53">&#9670;&nbsp;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the identity number of the subproblem. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00153">153</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="abd373c0f807d36399d4db25ff5967a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd373c0f807d36399d4db25ff5967a70">&#9670;&nbsp;</a></span>ignoreInTailingOff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::Sub::ignoreInTailingOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Can be used to control better the tailing-off effect. </p>
<p>If this function is called, the next LP-solution is ignored in the tailing-off control. Calling <em><a class="el" href="classabacus_1_1_sub.html#abd373c0f807d36399d4db25ff5967a70" title="Can be used to control better the tailing-off effect. ">ignoreInTailingOff()</a></em> can e.g. be considered in the following situation: If only constraints that are required for the integer programming formulation of the optimization problem are added then the next LP-value could be ignored in the tailing-off control. Only "real" cutting planes should be considered in the tailing-off control (this is only an example strategy that might not be practical in many situations, but sometimes turned out to be efficient). </p>

</div>
</div>
<a id="a4c6b6ba861ffe427b587f43047e73420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6b6ba861ffe427b587f43047e73420">&#9670;&nbsp;</a></span>improve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::improve </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>primalValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be redefined in order to implement primal heuristics for finding feasible solutions. </p>
<p>The default implementation does nothing.</p>
<dl class="section return"><dt>Returns</dt><dd>0 If no better solution could be found, 1 otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primalValue</td><td>Should hold the value of the feasible solution, if a better one is found. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classogdf_1_1cluster__planarity_1_1_c_planarity_sub.html#a1620e312c9bedf8099370a3165fe20b7">ogdf::cluster_planarity::CPlanaritySub</a>, and <a class="el" href="classogdf_1_1cluster__planarity_1_1_max_c_planar_sub.html#a799e78a26de44c8ce8cc9405a06e72fb">ogdf::cluster_planarity::MaxCPlanarSub</a>.</p>

</div>
</div>
<a id="a0cb1bdd6273fc1ef629824c83cd046bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb1bdd6273fc1ef629824c83cd046bf">&#9670;&nbsp;</a></span>infeasible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abacus::Sub::infeasible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the subproblem does not contain a feasible solution, false otherwise. </p>

</div>
</div>
<a id="aee72919a1b3d970e8495c9ce6dc869fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee72919a1b3d970e8495c9ce6dc869fd">&#9670;&nbsp;</a></span>infeasibleSub()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::infeasibleSub </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should be called if a subproblem turns out to be infeasible. </p>
<p>It sets the dual bound of the subproblem correctly. </p>

</div>
</div>
<a id="a24b51158c54bba3fd22b5258fced69bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b51158c54bba3fd22b5258fced69bb">&#9670;&nbsp;</a></span>initializeCons()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::initializeCons </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the active constraint set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxCon</td><td>The maximal number of constraints of the subproblem. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73d1340ac33a6fd33516309aa75275d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d1340ac33a6fd33516309aa75275d1">&#9670;&nbsp;</a></span>initializeLp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::initializeLp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the linear program. </p>
<p>Since not all variables might be active we first have to try making the <em><a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a></em> feasible again by the addition of variables. If this fails, i.e., <em><a class="el" href="classabacus_1_1_sub.html#acda5bc10e09170417f03b8d9835db652" title="Tries to add variables to restore infeasibilities detected at initialization time. ">_initMakeFeas()</a></em> has a nonzero return value, we return 1 in order to indicate that the corresponding subproblem can be fathomed. Otherwise, we continue with the initialization of the <em><a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a></em>.</p>
<dl class="section return"><dt>Returns</dt><dd>0 If the linear program could be initialized successfully. </dd>
<dd>
1 If the linear program turns out to be infeasible. </dd></dl>

</div>
</div>
<a id="a8eb2af166e8ab4dfe3390da9fd296455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb2af166e8ab4dfe3390da9fd296455">&#9670;&nbsp;</a></span>initializeVars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::initializeVars </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the active variable set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxVar</td><td>The maximal number of variables of the subproblem. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2211b5377d19d6863fddfe1ad7ec558d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2211b5377d19d6863fddfe1ad7ec558d">&#9670;&nbsp;</a></span>initMakeFeas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::initMakeFeas </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_infeas_con.html">InfeasCon</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>infeasCon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>newVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_pool.html">Pool</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; **&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default implementation of the virtual <em><a class="el" href="classabacus_1_1_sub.html#a2211b5377d19d6863fddfe1ad7ec558d" title="The default implementation of the virtual initMakeFeas() does nothing. ">initMakeFeas()</a></em> does nothing. </p>
<p>A reimplementation of this function should generate inactive variables until at least one variable <em>v</em> which satisfies the function InfeasCon::goodVar(v) for each infeasible constraint is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">infeasCon</td><td>The infeasible constraints. </td></tr>
    <tr><td class="paramname">newVars</td><td>The variables that might restore feasibility should be added here. </td></tr>
    <tr><td class="paramname">pool</td><td>A pointer to the pool to which the new variables should be added. If this is a 0-pointer the variables are added to the default variable pool. The default value is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the feasibility might have been restored, 1 otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00797">797</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="aa1463bb7807f513afee25ce55593bcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1463bb7807f513afee25ce55593bcc3">&#9670;&nbsp;</a></span>integerFeasible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abacus::Sub::integerFeasible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be used to check if the solution of the LP-relaxation is primally feasible if integrality is suficinet. </p>
<p>Checks if all binary and integer variables have an integral value. This function can be called from the function <em><a class="el" href="classabacus_1_1_sub.html#aef66b56a1aa2069cd9676c0d8ae2a3c8" title="Must check the feasibility of a solution of the LP-relaxation. ">feasible()</a></em> in derived classes.</p>
<dl class="section return"><dt>Returns</dt><dd>true If the LP-value of all binary and integer variables is integral, false otherwise. </dd></dl>

</div>
</div>
<a id="a716918ee48ba0ced38c53b4660c0b789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716918ee48ba0ced38c53b4660c0b789">&#9670;&nbsp;</a></span>lBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double abacus::Sub::lBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be used to access the lower of an active variable of the subproblem. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is the lower bound of the variable within the current subproblem which can differ from its global lower bound.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The number of the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lower bound of the <em>i-th</em> variable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00245">245</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="aa6192b550ac8e271bbd354d66648c223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6192b550ac8e271bbd354d66648c223">&#9670;&nbsp;</a></span>lBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::Sub::lBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the local lower bound of variable <em>i</em> to <em>l</em>. </p>
<p>It does not change the global lower bound of the variable. The bound of a fixed or set variable should not be changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The number of the variable. </td></tr>
    <tr><td class="paramname">l</td><td>The new value of the lower bound. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01907">1907</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ada62018cc513c76d8cf584b3a31cae88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada62018cc513c76d8cf584b3a31cae88">&#9670;&nbsp;</a></span>level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the level of the subproblem in the branch-and-bound tree. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00150">150</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ac45e45488fbd3eec22dfc62e9145a9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45e45488fbd3eec22dfc62e9145a9d8">&#9670;&nbsp;</a></span>lowerBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double abacus::Sub::lowerBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a lower bound on the optimal solution of the subproblem. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01873">1873</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a65afc40098dc0d4ed9638fe366b0efae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65afc40098dc0d4ed9638fe366b0efae">&#9670;&nbsp;</a></span>lp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_lp_sub.html">LpSub</a>* abacus::Sub::lp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the linear program of the subproblem. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00201">201</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ac9a9e0f1ee671a49f0d0febb4c5a3b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a9e0f1ee671a49f0d0febb4c5a3b8d">&#9670;&nbsp;</a></span>lpRankBranchingRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double abacus::Sub::lpRankBranchingRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a> *&#160;</td>
          <td class="paramname"><em>branchRule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterLimit</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the rank of a branching rule by modifying the linear programming relaxation of the subproblem according to the branching rule and solving it. </p>
<p>This modifiction is undone after the solution of the linear program.</p>
<p>It is useless, but no error, to call this function for branching rules for which the virtual dummy functions <em>extract(LpSub*)</em> and <em>unExtract(LpSub*)</em> of the base class <a class="el" href="classabacus_1_1_branch_rule.html" title="Abstract base class for all branching rules. ">BranchRule</a> are not redefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">branchRule</td><td>A pointer to a branching rule. </td></tr>
    <tr><td class="paramname">iterLimit</td><td>The maximal number of iterations that should be performed by the simplex method. If this number is negative there is no iteration limit (besides internal limits of the LP-solver). The default value is <em>-1</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the linear programming relaxation of the subproblem modified by the branching rule. </dd></dl>

</div>
</div>
<a id="a25d51a569116411cdb082f9c8b32a26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d51a569116411cdb082f9c8b32a26b">&#9670;&nbsp;</a></span>lpVarStat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_l_p_v_a_r_s_t_a_t.html">LPVARSTAT</a>* abacus::Sub::lpVarStat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the status of the variable <em>i</em> in the last solved linear program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The number of the variable. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00297">297</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a02304f8dd7d726523507b91ad04ed306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02304f8dd7d726523507b91ad04ed306">&#9670;&nbsp;</a></span>makeFeasible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::makeFeasible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default implementation of <em><a class="el" href="classabacus_1_1_sub.html#a02304f8dd7d726523507b91ad04ed306" title="The default implementation of makeFeasible()does nothing. ">makeFeasible()</a>does</em> nothing. </p>
<p>If there is an infeasible structural variable then it is stored in <em>infeasVar_</em>, otherwise <em>infeasVar_</em> is <em>-1</em>. If there is an infeasible slack variable, it is stored in <em>infeasCon_</em>, otherwise it is <em>-1</em>. At most one of the two members <em>infeasVar_</em> and <em>infeasCon_</em> can be nonnegative. A reimplementation in a derived class should generate variables to restore feasibility or confirm that the subproblem is infeasible.</p>
<p>The strategy for the generation of inactive variables is completely problem and user specific. For testing if a variable might restore again the feasibility the functions <a class="el" href="classabacus_1_1_variable.html#a827fb45e5feee4f178754a657681562e" title="Returns whether an (inactive) discrete variable is useful. ">Variable::useful()</a> and <a class="el" href="classabacus_1_1_sub.html#acf90413f54f6b222b47128fb612e4f6c">Sub::goodCol()</a> might be helpful.</p>
<dl class="section return"><dt>Returns</dt><dd>0 If feasibility can be restored, 1 otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classogdf_1_1cluster__planarity_1_1_c_planarity_sub.html#af50dcf3e97b0ff5ceb9a291c459c9de8">ogdf::cluster_planarity::CPlanaritySub</a>, and <a class="el" href="classogdf_1_1cluster__planarity_1_1_max_c_planar_sub.html#a05db52e270cfcc014828eca50fa18ec4">ogdf::cluster_planarity::MaxCPlanarSub</a>.</p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00822">822</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="acef4a106b35486eee20ad545dcf956b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef4a106b35486eee20ad545dcf956b6">&#9670;&nbsp;</a></span>master() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_master.html">Master</a>* abacus::Sub::master </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the master of the optimization. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00320">320</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ad6143a5d18cd5446523a465a1383bd05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6143a5d18cd5446523a465a1383bd05">&#9670;&nbsp;</a></span>master() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classabacus_1_1_master.html">Master</a>* abacus::Sub::master </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the const master of the optimization. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00323">323</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="af44562162d12252db0defa7718f1336b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44562162d12252db0defa7718f1336b">&#9670;&nbsp;</a></span>maxCon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::maxCon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of constraints which can be handled without reallocation. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01853">1853</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ae7c5c15d639b7a56c8ccd950d1644df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c5c15d639b7a56c8ccd950d1644df5">&#9670;&nbsp;</a></span>maxIterations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::Sub::maxIterations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximal number of iterations in the cutting plane phase. </p>
<p>Setting this value to 1 implies that no cuts are generated in the optimization process of the subproblem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max</td><td>The maximal number of iterations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07f3c3d1aa62a9f9834c4de6df9ec7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f3c3d1aa62a9f9834c4de6df9ec7e4">&#9670;&nbsp;</a></span>maxVar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::maxVar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of variables which can be handled without reallocation. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01848">1848</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="abbc5c85feec629376510f8bc2d1585a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc5c85feec629376510f8bc2d1585a8">&#9670;&nbsp;</a></span>nCon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::nCon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of active constraints. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01843">1843</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ac0686811c13e9c8d18fa40e1664a5496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0686811c13e9c8d18fa40e1664a5496">&#9670;&nbsp;</a></span>nDormantRounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::nDormantRounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of subproblem optimization the subproblem is already dormant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00408">408</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="aa959d64f6cd7f7ac8299cd5ce8720612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa959d64f6cd7f7ac8299cd5ce8720612">&#9670;&nbsp;</a></span>newDormantRound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::newDormantRound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the counter for the number of rounds the subproblem is dormant. </p>
<p>This function is called, when the set of open subproblems is scanned for the selection of the next subproblem. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01611">1611</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="aa77f15badcdab5335a865cacf0a6d9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77f15badcdab5335a865cacf0a6d9fd">&#9670;&nbsp;</a></span>nnzReserve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double abacus::Sub::nnzReserve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the additional space for nonzero elements of the constraint matrix when it is passed to the LP-solver. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00346">346</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a2aa2ac08974bc4f8be27290a32fa9ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa2ac08974bc4f8be27290a32fa9ee7">&#9670;&nbsp;</a></span>nonBindingConEliminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::nonBindingConEliminate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the dynamic constraints with slack exceeding the value given by the parameter <code>ConElimEps</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remove</td><td>Stores the nonbinding constraints. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8c9b6ec6cc12fd1a51562f3340ee2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c9b6ec6cc12fd1a51562f3340ee2d5">&#9670;&nbsp;</a></span>nVar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::nVar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of active variables. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01838">1838</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a6c04bd3a7e82af81a0c12f8272f9bf88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c04bd3a7e82af81a0c12f8272f9bf88">&#9670;&nbsp;</a></span>objAllInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool abacus::Sub::objAllInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if all active variables and objective function coefficients are integer. </p>
<p>If all variables are <em>Binary</em> or <em>Integer</em> and all objective function coefficients are integral, then all objective function values of feasible solutions are integral. The function <em><a class="el" href="classabacus_1_1_sub.html#a6c04bd3a7e82af81a0c12f8272f9bf88" title="Tests if all active variables and objective function coefficients are integer. ">objAllInteger()</a></em> tests this condition for the current set of active variables.</p>
<dl class="section note"><dt>Note</dt><dd>The result of this function can only be used to set the global parameter if <em>actVar</em> contains all variables of the problem formulation.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true If this condition is satisfied by the currently active variable set, false otherwise. </dd></dl>

</div>
</div>
<a id="a93ccfe6cf93319aabc572867f788c642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ccfe6cf93319aabc572867f788c642">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classabacus_1_1_sub.html">Sub</a>&amp; abacus::Sub::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classabacus_1_1_sub.html">Sub</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d8256c74d20333b9f24e2808d93d76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8256c74d20333b9f24e2808d93d76d">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::optimize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the optimization of the subproblem. </p>
<p>After activating the subproblem, i.e., allocating and initializing memory, and initializing the <em><a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a></em>, the optimization process constitutes of the three phases <em>Cutting</em>, <em>Branching</em>, and <em>Fathoming</em>, which are alternately processed. The function <em><a class="el" href="classabacus_1_1_sub.html#a8e70257891b0fc53557bfd32a07e0649" title="Fathoms the node, and if certain conditions are satisfied, also its ancestor. ">fathoming()</a></em> always returns <em>Done</em>. However, we think that the code is better readable instead of taking it out of the <em>while</em> loop. The optimization stops if the <em>PHASE</em> <em>Done</em> is reached. Note, <em>Done</em> does not necessarily mean that the subproblem is solved to optimality!</p>
<p>After the node is processed we deallocate memory, which is not required for further computations or of which the corresponding data can be easily reconstructed. This is performed in <em><a class="el" href="classabacus_1_1_sub.html#a6953ef615122bf8aee1e1d8cf06d7027" title="Deallocates the memory which is not required after the optimization of the subproblem. ">_deactivate()</a></em>.</p>
<dl class="section return"><dt>Returns</dt><dd>0 If the optimization has been performed without error, 1 otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classogdf_1_1cluster__planarity_1_1_c_planarity_sub.html#ac3b2aa05ddb70dcdc132fbe9c0904b51">ogdf::cluster_planarity::CPlanaritySub</a>, and <a class="el" href="classogdf_1_1cluster__planarity_1_1_max_c_planar_sub.html#a1f497887c75db367eca4c392edec65cc">ogdf::cluster_planarity::MaxCPlanarSub</a>.</p>

</div>
</div>
<a id="a9ecb2914ee0193c6fb278973a31bbcc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ecb2914ee0193c6fb278973a31bbcc0">&#9670;&nbsp;</a></span>pausing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool abacus::Sub::pausing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sometimes it is appropriate to put a subproblem back into the list of open subproblems. </p>
<p>This is called <em>pausing</em>. In the default implementation the virtual function <em><a class="el" href="classabacus_1_1_sub.html#a9ecb2914ee0193c6fb278973a31bbcc0" title="Sometimes it is appropriate to put a subproblem back into the list of open subproblems. ">pausing()</a></em> always returns <em>false</em>.</p>
<p>It could be useful to enforce pausing a node if a tailing off effect is observed during its first optimization.</p>
<dl class="section return"><dt>Returns</dt><dd>true The function <em><a class="el" href="classabacus_1_1_sub.html#a9ecb2914ee0193c6fb278973a31bbcc0" title="Sometimes it is appropriate to put a subproblem back into the list of open subproblems. ">pausing()</a></em> should return <em>true</em> if this condition is satisfied, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00968">968</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="acdab7e4b5981335e38b9090da5d4a51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdab7e4b5981335e38b9090da5d4a51a">&#9670;&nbsp;</a></span>prepareBranching()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::prepareBranching </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>lastIteration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is called before a branching step to remove constraints. </p>
<dl class="section return"><dt>Returns</dt><dd>1 If constraints have been removed, 0 otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lastIteration</td><td>This argument is always set to <em>true</em> in the function call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d683e41039bae1b2c266ef25352fb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d683e41039bae1b2c266ef25352fb4e">&#9670;&nbsp;</a></span>pricing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::pricing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should generate inactive variables which do not price out correctly. </p>
<p>The default implementation does nothing and returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of new variables. </dd></dl>

<p>Reimplemented in <a class="el" href="classogdf_1_1cluster__planarity_1_1_c_planarity_sub.html#afe5f47c4506eb3fd3e59d24216627b66">ogdf::cluster_planarity::CPlanaritySub</a>, and <a class="el" href="classogdf_1_1cluster__planarity_1_1_max_c_planar_sub.html#afbed90906764ff9a061b87517cb31c15">ogdf::cluster_planarity::MaxCPlanarSub</a>.</p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00934">934</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a324277f9c5ea2f36682f087841726d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324277f9c5ea2f36682f087841726d22">&#9670;&nbsp;</a></span>primalSeparation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool abacus::Sub::primalSeparation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Controls if during the cutting plane phase a (primal) separation step or a pricing step (dual separation) should be performed. </p>
<p>Per default a pure cutting plane algorithm performs always a primal separation step, a pure column generation algorithm never performs a primal separation, and a hybrid algorithm generates usually cutting planes but from time to time also inactive variables are priced out depending on the <em>pricingFrequency()</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>true Then cutting planes are generated in this iteration. </dd>
<dd>
false Then columns are generated in this iteration. </dd></dl>

</div>
</div>
<a id="a3dc89a32429cf1139034e9c2489c08e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc89a32429cf1139034e9c2489c08e9">&#9670;&nbsp;</a></span>rankBranchingRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double abacus::Sub::rankBranchingRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a> *&#160;</td>
          <td class="paramname"><em>branchRule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the rank of a branching rule. </p>
<p>This default implementation computes the rank with the function <em><a class="el" href="classabacus_1_1_sub.html#ac9a9e0f1ee671a49f0d0febb4c5a3b8d" title="Computes the rank of a branching rule by modifying the linear programming relaxation of the subproble...">lpRankBranchingRule()</a></em>. By redefining this virtual function the rank for a branching rule can be computed differently.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">branchRule</td><td>A pointer to a branching rule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rank of the branching rule. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01868">1868</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a883a8df946d44494be003f73b581e3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883a8df946d44494be003f73b581e3d4">&#9670;&nbsp;</a></span>rankBranchingSample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::rankBranchingSample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes for each branching rule of a branching sample a rank with the function <em><a class="el" href="classabacus_1_1_sub.html#a3dc89a32429cf1139034e9c2489c08e9" title="Computes the rank of a branching rule. ">rankBranchingRule()</a></em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td>A branching sample. </td></tr>
    <tr><td class="paramname">rank</td><td>An array storing the rank for each branching rule in the sample after the function call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f3e6e24e11921064297c78891fc7316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3e6e24e11921064297c78891fc7316">&#9670;&nbsp;</a></span>redCostVarEliminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::Sub::redCostVarEliminate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves all variables with "wrong" reduced costs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remove</td><td>The variables with "wrong" reduced cost are stored in this buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a074666eb8fbcf5c98ad8500207a012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a074666eb8fbcf5c98ad8500207a012">&#9670;&nbsp;</a></span>relativeReserve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abacus::Sub::relativeReserve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true If the reserve space for variables, constraints, and nonzeros is given in percent of the original space, and <em>false</em> if its given as absolute value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00352">352</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a0c74b0dbce3008ebb66f9caa318cce3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c74b0dbce3008ebb66f9caa318cce3f">&#9670;&nbsp;</a></span>removeCon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::Sub::removeCon </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a single constraint to the set of constraints which are removed from the active set at the beginning of the next iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The number of the constraint being removed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01902">1902</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="abd6b883a073f846d0a15bed605251326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6b883a073f846d0a15bed605251326">&#9670;&nbsp;</a></span>removeCons()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::removeCons </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds constraints to the buffer of the removed constraints. </p>
<p>These will be removed at the beginning of the next iteration of the cutting plane algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remove</td><td>The constraints which should be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6657fd8f00ad76e44a60b9dc1a8c6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6657fd8f00ad76e44a60b9dc1a8c6d4">&#9670;&nbsp;</a></span>removeNonLiftableCons()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool abacus::Sub::removeNonLiftableCons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true If all active constraints can be lifted. </dd>
<dd>
false otherwise. In this case the non-liftable constraints are removed and <em>genNonLiftCons_</em> is set to <em>false</em> to avoid the generation of non-liftable constraints in the next cutting plane iterations. </dd></dl>

</div>
</div>
<a id="ae47c5813d504e46d2b3ab4f1c900acba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47c5813d504e46d2b3ab4f1c900acba">&#9670;&nbsp;</a></span>removeVar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::Sub::removeVar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove variable <em>i</em> from the set of active variables. </p>
<p>Like in the function <em><a class="el" href="classabacus_1_1_sub.html#ae5dde1eba98c6ad2c40c9d352a480e43" title="Removes the variables in remove from the set of active variables. ">removeVars()</a></em> the variable is buffered and removed at the beginning of the next iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The variable which should be removed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00343">343</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ae5dde1eba98c6ad2c40c9d352a480e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5dde1eba98c6ad2c40c9d352a480e43">&#9670;&nbsp;</a></span>removeVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::Sub::removeVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the variables in <em>remove</em> from the set of active variables. </p>
<p>The variables are not removed when this function is called, but are buffered and removed at the beginning of the next iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remove</td><td>The variables which should be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7dd477fadcb66cda3b11f4d4d462f516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd477fadcb66cda3b11f4d4d462f516">&#9670;&nbsp;</a></span>reoptimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::reoptimize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repeats the optimization of an already optimized subproblem. </p>
<p>This function is used to determine the reduced costs for fixing variables of a new root of the remaining branch-and-bound tree.</p>
<p>As the subproblem has been processed already earlier it is sufficient to perform the cutting plane algorithm. If the subproblem is fathomed the complete subtree rooted at this subproblem can be fathomed, too. Since this function is usually only called for the root of the remaining branch-and-bound tree, we are done in this case.</p>
<p>It is not guaranteed that all constraints and variables of this subproblem can be regenerated in <em><a class="el" href="classabacus_1_1_sub.html#a4825021bf089410d94184c9f4c3350ec" title="Allocates and initializes memory of the subproblem at the beginning of the optimization. ">_activate()</a></em>. Therefore, the result of a call to <em><a class="el" href="classabacus_1_1_sub.html#a7dd477fadcb66cda3b11f4d4d462f516" title="Repeats the optimization of an already optimized subproblem. ">reoptimize()</a></em> can differ from the result obtained by the cutting plane algorithm in <em><a class="el" href="classabacus_1_1_sub.html#a7d8256c74d20333b9f24e2808d93d76d" title="Performs the optimization of the subproblem. ">optimize()</a></em>. </p>

</div>
</div>
<a id="a521efb5513b6086312192b6e9b29c528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521efb5513b6086312192b6e9b29c528">&#9670;&nbsp;</a></span>selectBestBranchingSample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::selectBestBranchingSample </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a> *&gt; **&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates branching samples. </p>
<p>We denote a branching sample the set of rules defining all sons of a subproblem in the enumeration tree). For each sample the ranks are determined with the function <em><a class="el" href="classabacus_1_1_sub.html#a883a8df946d44494be003f73b581e3d4" title="Computes for each branching rule of a branching sample a rank with the function rankBranchingRule(). ">rankBranchingSample()</a></em>. The ranks of the various samples are compared with the function <em>compareBranchingSample()</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSamples</td><td>The number of branching samples. </td></tr>
    <tr><td class="paramname">samples</td><td>An array of pointer to buffers storing the branching rules of each sample.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of the best branching sample, or <em>-1</em> in case of an internal error. </dd></dl>

</div>
</div>
<a id="a02aacd191c773efc09d75eaa810f81fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02aacd191c773efc09d75eaa810f81fd">&#9670;&nbsp;</a></span>selectBranchingVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::selectBranchingVariable </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chooses a branching variable. </p>
<p>The function <em><a class="el" href="classabacus_1_1_sub.html#a2d04080b6f001627ecb9119a150b811c" title="Selects candidates for branching variables. ">selectBranchingVariableCandidates()</a></em> is asked to generate depending in the parameter <code>NBranchingVariableCandidates</code> of the file <code>.abacus</code> candidates for branching variables. If only one candidate is generated, this one becomes the branching variable. Otherwise, the pairs of branching rules are generated for all candidates and the "best" branching variables is determined with the function <em><a class="el" href="classabacus_1_1_sub.html#a521efb5513b6086312192b6e9b29c528" title="Evaluates branching samples. ">selectBestBranchingSample()</a></em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>Holds the branching variable if one is found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 If a branching variable is found, 1 otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classogdf_1_1cluster__planarity_1_1_c_planarity_sub.html#aac26780ded9d39969d960e7f86e2228d">ogdf::cluster_planarity::CPlanaritySub</a>, and <a class="el" href="classogdf_1_1cluster__planarity_1_1_max_c_planar_sub.html#abdee1f7cae468dee7f4cfba35a024566">ogdf::cluster_planarity::MaxCPlanarSub</a>.</p>

</div>
</div>
<a id="a2d04080b6f001627ecb9119a150b811c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d04080b6f001627ecb9119a150b811c">&#9670;&nbsp;</a></span>selectBranchingVariableCandidates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::selectBranchingVariableCandidates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects candidates for branching variables. </p>
<p>Candidates are selected depending on the branching variable strategy given by the parameter <code>BranchingStrategy</code> in the file <code>.abacus</code> candidates that for branching variables.</p>
<p>Currently two branching variable selection strategies are implemented. The first one (<em>CloseHalf</em>) first searches the binary variables with fractional part closest to \(0.5\). If there is no fractional binary variable it repeats this process with the integer variables.</p>
<p>The second strategy (<em>CloseHalfExpensive</em>) first tries to find binary variables with fraction close to \(0.5\) and high absolute objective function coefficient. If this fails, it tries to find an integer variable with fractional part close to \(0.5\) and high absolute objective function coefficient.</p>
<p>If neither a binary nor an integer variable with fractional value is found then for both strategies we try to find non-fixed and non-set binary variables. If this fails we repeat this process with the integer variables.</p>
<p>Other branching variable selection strategies can be implemented by redefining this virtual function in a derived class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">candidates</td><td>The candidates for branching variables are stored in this buffer. We try to find as many variables as fit into the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 If a candidate is found, 1 otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classogdf_1_1cluster__planarity_1_1_c_planarity_sub.html#aaa8c5c0b0cc9a21303431989b002e811">ogdf::cluster_planarity::CPlanaritySub</a>, and <a class="el" href="classogdf_1_1cluster__planarity_1_1_max_c_planar_sub.html#a22255e155f45b97fed40ac050d10510f">ogdf::cluster_planarity::MaxCPlanarSub</a>.</p>

</div>
</div>
<a id="a74f9fd4634aa0b70e3ffef3b1c0a76ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f9fd4634aa0b70e3ffef3b1c0a76ff">&#9670;&nbsp;</a></span>selectCons()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::selectCons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is called before constraint are selected from the constraint buffer. </p>
<p>It can be redefined in a derived class e.g., to remove multiply inserted constraints from the buffer. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01031">1031</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="aa54754a8f1cbb344825cfc45492114e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54754a8f1cbb344825cfc45492114e7">&#9670;&nbsp;</a></span>selectVars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::selectVars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is called before variables are selected from the variable buffer. </p>
<p>It can be redefined in a derived class e.g., to remove multiply inserted variables from the buffer. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01024">1024</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a1e8bd1dfbc1944934caeaa43ea3e43b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8bd1dfbc1944934caeaa43ea3e43b8">&#9670;&nbsp;</a></span>separate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::separate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must be redefined in derived classes for the generation of cutting planes. </p>
<p>The default implementation does nothing.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of generated cutting planes. </dd></dl>

<p>Reimplemented in <a class="el" href="classogdf_1_1_min_steiner_tree_directed_cut_1_1_sub.html#a12c82e7ace21589bce4eff42c10be0a9">ogdf::MinSteinerTreeDirectedCut&lt; T &gt;::Sub</a>, <a class="el" href="classogdf_1_1cluster__planarity_1_1_c_planarity_sub.html#a945fc4928da428216b5af044b978b55b">ogdf::cluster_planarity::CPlanaritySub</a>, and <a class="el" href="classogdf_1_1cluster__planarity_1_1_max_c_planar_sub.html#aa5e309badd03cf7c3d47f159ad551ddb">ogdf::cluster_planarity::MaxCPlanarSub</a>.</p>

</div>
</div>
<a id="acac5130d4b5374cd8b8951aa9c074d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac5130d4b5374cd8b8951aa9c074d9b">&#9670;&nbsp;</a></span>set() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_f_s_var_stat.html">FSVarStat</a> *&#160;</td>
          <td class="paramname"><em>newStat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The number of the variable being set. </td></tr>
    <tr><td class="paramname">newStat</td><td>A pointer to the object storing the new status of the the variable. </td></tr>
    <tr><td class="paramname">newValue</td><td>If the variable is set to a value different from the one of the last LP-solution, <em>newValue</em> is set to <em>true</em>. Otherwise, it is set to <em>false</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 If a contradiction is found, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a668e20f3c1ce17ca355aea69894a1edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668e20f3c1ce17ca355aea69894a1edd">&#9670;&nbsp;</a></span>set() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_f_s_var_stat.html#a0b174a15f4bfd9c3a20cbd3ccc0efbb9">FSVarStat::STATUS</a>&#160;</td>
          <td class="paramname"><em>newStat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The number of the variable being set. </td></tr>
    <tr><td class="paramname">newStat</td><td>The new status of the variable. </td></tr>
    <tr><td class="paramname">newValue</td><td>If the variable is set to a value different from the one of the last LP-solution, <em>newValue</em> is set to <em>true</em>. Otherwise, it is set to <em>false</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 If a contradiction is found, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a48db8ebb4354d6012a3a2951a1dd3c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48db8ebb4354d6012a3a2951a1dd3c8c">&#9670;&nbsp;</a></span>set() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_f_s_var_stat.html#a0b174a15f4bfd9c3a20cbd3ccc0efbb9">FSVarStat::STATUS</a>&#160;</td>
          <td class="paramname"><em>newStat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The number of the variable being set. </td></tr>
    <tr><td class="paramname">newStat</td><td>The new status of the variable. </td></tr>
    <tr><td class="paramname">value</td><td>The value the variable is set to. </td></tr>
    <tr><td class="paramname">newValue</td><td>If the variable is set to a value different from the one of the last LP-solution, <em>newValue</em> is set to <em>true</em>. Otherwise, it is set to <em>false</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 If a contradiction is found, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a29e4677db92404769c2a075702ae77ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e4677db92404769c2a075702ae77ef">&#9670;&nbsp;</a></span>setByLogImp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::setByLogImp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; <a class="el" href="classabacus_1_1_f_s_var_stat.html">FSVarStat</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default implementation of <em><a class="el" href="classabacus_1_1_sub.html#a29e4677db92404769c2a075702ae77ef" title="The default implementation of setByLogImp() does nothing. ">setByLogImp()</a></em> does nothing. </p>
<p>In derived classes this function can be reimplemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>The variables which should be set have to be inserted in this buffer. </td></tr>
    <tr><td class="paramname">status</td><td>The status of the set variables. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00845">845</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ad1f9bbab838f2ca4d36a75f5e93f1c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f9bbab838f2ca4d36a75f5e93f1c90">&#9670;&nbsp;</a></span>setByRedCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::setByRedCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to set variables according to the reduced cost criterion. </p>
<dl class="section return"><dt>Returns</dt><dd>1 If a contradiction is found, 0 otherwise. </dd></dl>

</div>
</div>
<a id="aeb506ab5dd3d08e03cef11d805a31537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb506ab5dd3d08e03cef11d805a31537">&#9670;&nbsp;</a></span>setting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::setting </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>newValues</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to set variables by reduced cost criteria and logical implications like <em><a class="el" href="classabacus_1_1_sub.html#a28743afe6f5292c150ad6b6708aca2a5" title="Tries to fix variables by reduced cost criteria and logical implications. ">fixing()</a></em>. </p>
<p>But instead of global conditions only locally valid conditions have to be satisfied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newValues</td><td>The parameter <em>newValues</em> becomes <em>true</em> if variables are fixed to other values as in the current LP-solution (<em><a class="el" href="classabacus_1_1_sub.html#ad1f9bbab838f2ca4d36a75f5e93f1c90" title="Tries to set variables according to the reduced cost criterion. ">setByRedCost()</a></em> cannot set variables to new values).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 If a contradiction has been found, 0 otherwise. </dd></dl>

</div>
</div>
<a id="acb4a1006350c86b48eb4f0f4d5acc87c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4a1006350c86b48eb4f0f4d5acc87c">&#9670;&nbsp;</a></span>slackStat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_slack_stat.html">SlackStat</a>* abacus::Sub::slackStat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the status of the slack variable <em>i</em> in the last solved linear program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The number of the slack variable. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00228">228</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ad1c56c94f842adef22f52e150c337c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c56c94f842adef22f52e150c337c50">&#9670;&nbsp;</a></span>solveApproxNow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool abacus::Sub::solveApproxNow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default implementation always returns false. </p>
<dl class="section return"><dt>Returns</dt><dd>True, if the approximative solver should be used to solve the next linear program, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01432">1432</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="aba415669914df13a57b5c10477672e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba415669914df13a57b5c10477672e0d">&#9670;&nbsp;</a></span>solveLp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::solveLp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves the LP-relaxation of the subproblem. </p>
<p>As soon as the <em>LP-relaxation</em> becomes infeasible in a static branch and cut algorithm the respective subproblem can be fathomed. Otherwise, we memorize the value of the LP-solution to control the tailing off effect.</p>
<p>We assume that the <em><a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a></em> is never primal unbounded.</p>
<dl class="section return"><dt>Returns</dt><dd>0 The linear program has an optimimal solution. </dd>
<dd>
1 If the linear program is infeasible. </dd>
<dd>
2 If the linear program is infeasible for the current variable set, but non-liftable constraints have to be removed before a pricing step can be performed. </dd></dl>

<p>Reimplemented in <a class="el" href="classogdf_1_1cluster__planarity_1_1_c_planarity_sub.html#a3f34ad3acd9f2ed1eb8177a8936ccdeb">ogdf::cluster_planarity::CPlanaritySub</a>, and <a class="el" href="classogdf_1_1cluster__planarity_1_1_max_c_planar_sub.html#a57087c312e696a97f27fb874ab763288">ogdf::cluster_planarity::MaxCPlanarSub</a>.</p>

</div>
</div>
<a id="ab4d98d1ebca0564df200ada33c8d1f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d98d1ebca0564df200ada33c8d1f2c">&#9670;&nbsp;</a></span>status()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_sub.html#a49aa228f17967fc8ac589b5fb7bc3297">STATUS</a> abacus::Sub::status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the status of the subproblem optimization. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00156">156</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a0e2f9a7f911e7f65369770320c59c2a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2f9a7f911e7f65369770320c59c2a3">&#9670;&nbsp;</a></span>tailingOff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool abacus::Sub::tailingOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a tailing off effect according to the parameters <code>TailOffPercent</code> and <code>TailOffNLps</code> is observed. </p>
<p>This function can be redefined in derived classes in order to perform actions to resolve the tailing off (e.g., switching on an enhanced separation strategy).</p>
<dl class="section return"><dt>Returns</dt><dd>true If a branching step should be enforced. But before branching a pricing operation is perfored. The branching step is only performed if no variables are added. Otherwise, the cutting plane algorithm is continued. </dd>
<dd>
false If the cutting plane algorithm should be continued. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01014">1014</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a071c193c10af908b7643dea5afee67f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071c193c10af908b7643dea5afee67f1">&#9670;&nbsp;</a></span>uBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double abacus::Sub::uBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be used to access the upper of an active variable of the subproblem. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is the upper bound of the variable within the current subproblem which can differ from its global upper bound.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The number of the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The upper bound of the <em>i-th</em> variable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00266">266</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="acb89c42e0413c8f11c9707d40b7e6df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb89c42e0413c8f11c9707d40b7e6df2">&#9670;&nbsp;</a></span>uBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abacus::Sub::uBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the local upper bound of variable <em>i</em> to <em>u</em>. </p>
<p>This does not change the global lower bound of the variable. The bound of a fixed or set variable should not be changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The number of the variable. </td></tr>
    <tr><td class="paramname">u</td><td>The new value of the upper bound. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01914">1914</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a58402e7a567fc3c0a1ce51e7e58b1cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58402e7a567fc3c0a1ce51e7e58b1cf8">&#9670;&nbsp;</a></span>updateBoundInLp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::updateBoundInLp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adapts the bound of a fixed or set variable <em>i</em> also in the linear program. </p>
<p>This can be only done if a linear program is available and the variable is not eliminated. </p>

</div>
</div>
<a id="aa461990f43ce14c6b2027e0b7aa819ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa461990f43ce14c6b2027e0b7aa819ae">&#9670;&nbsp;</a></span>upperBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double abacus::Sub::upperBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an upper bound on the optimal solution of the subproblem. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01881">1881</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a591534e443fdba749329af01b468cf70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591534e443fdba749329af01b468cf70">&#9670;&nbsp;</a></span>varEliminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::varEliminate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point for application specific variable elimination. </p>
<p>The default implementation selects the variables with the function <em><a class="el" href="classabacus_1_1_sub.html#a6f3e6e24e11921064297c78891fc7316" title="Retrieves all variables with &quot;wrong&quot; reduced costs. ">redCostVarEliminate()</a></em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remove</td><td>The variables that should be removed have to be stored in this buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7939f6fcf325cb0b5bb96cf0cea54773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7939f6fcf325cb0b5bb96cf0cea54773">&#9670;&nbsp;</a></span>variable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_variable.html">Variable</a> * abacus::Sub::variable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the <em>i-th</em> active variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The number of the variable being accessed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01863">1863</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="abdff593017388db94d300c5240fd3186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdff593017388db94d300c5240fd3186">&#9670;&nbsp;</a></span>variablePoolSeparation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int abacus::Sub::variablePoolSeparation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ranking</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabacus_1_1_pool.html">Pool</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt; *&#160;</td>
          <td class="paramname"><em>pool</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minViolation</em> = <code>0.001</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to generate inactive variables from a pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ranking</td><td>This parameter indicates how the ranks of geneated variables should be computed (0: no ranking; 1: violation is rank, 2: absolute value of violation is rank 3: rank determined by <a class="el" href="classabacus_1_1_con_var.html#a0fff7dcde419b3c82ef6dcd0c75e1404" title="The function should return a rank associated with the constraint/variable. ">ConVar::rank()</a>). The default value is 0. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool the variables are generated from. If <em>pool</em> is 0, then the default variable pool is used. The default value of <em>pool</em> is 0. </td></tr>
    <tr><td class="paramname">minViolation</td><td>A violated constraint/variable is only added if the absolute value of its violation is at least <em>minAbsViolation</em>. The default value is 0.001.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of generated variables. </dd></dl>

</div>
</div>
<a id="acdfc781df11fed36a633a551e394e6e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfc781df11fed36a633a551e394e6e9">&#9670;&nbsp;</a></span>varRealloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void abacus::Sub::varRealloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reallocates memory that at most <em>newSize</em> variables can be handled in the subproblem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>The new maximal number of variables in the subproblem. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae924b80497818945f96f8658d1394b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae924b80497818945f96f8658d1394b45">&#9670;&nbsp;</a></span>xVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double abacus::Sub::xVal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the <em>i-th</em> variable in the last solved linear program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The number of the variable under consideration. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00303">303</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a28ba9bc95672b5e054cdbc68f0af0c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ba9bc95672b5e054cdbc68f0af0c95">&#9670;&nbsp;</a></span>yVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double abacus::Sub::yVal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the <em>i-th</em> dual variable in the last solved linear program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The number of the variable under consideration. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00309">309</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a2dcfa64745ea8a05bd13f95821de3c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dcfa64745ea8a05bd13f95821de3c37">&#9670;&nbsp;</a></span>BoundBranchRule</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classabacus_1_1_bound_branch_rule.html">BoundBranchRule</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00071">71</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ae4fc97a80de99c3272c02c78c6b69774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fc97a80de99c3272c02c78c6b69774">&#9670;&nbsp;</a></span>LpSolution< Constraint, Variable ></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classabacus_1_1_lp_solution.html">LpSolution</a>&lt; <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00073">73</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ac11ca7e42e9ab3ff4effadd18907942d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11ca7e42e9ab3ff4effadd18907942d">&#9670;&nbsp;</a></span>LpSolution< Variable, Constraint ></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classabacus_1_1_lp_solution.html">LpSolution</a>&lt; <a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00074">74</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a34b85c36cc2386b553fcff72fc15a596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b85c36cc2386b553fcff72fc15a596">&#9670;&nbsp;</a></span>Master</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classabacus_1_1_master.html">Master</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00070">70</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a5523bb2d3bd300638fc44f4cb0cc17a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5523bb2d3bd300638fc44f4cb0cc17a4">&#9670;&nbsp;</a></span>OpenSub</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classabacus_1_1_open_sub.html">OpenSub</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l00072">72</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad5468340a0cf0c2bf8c21f2b165576e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5468340a0cf0c2bf8c21f2b165576e0">&#9670;&nbsp;</a></span>actCon_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_active.html">Active</a>&lt;<a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a>&gt;* abacus::Sub::actCon_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The active constraints of the subproblem. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01439">1439</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a4780a09b3b06efd1c2683dbb5a259c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4780a09b3b06efd1c2683dbb5a259c74">&#9670;&nbsp;</a></span>activated_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abacus::Sub::activated_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The variable is <em>true</em> if the function <em><a class="el" href="classabacus_1_1_sub.html#ae22a4eb3419a6665e28cbeb0b592bcba" title="Can be used as an entrance point for problem specific activations. ">activate()</a></em> has been called from the function <em><a class="el" href="classabacus_1_1_sub.html#a4825021bf089410d94184c9f4c3350ec" title="Allocates and initializes memory of the subproblem at the beginning of the optimization. ">_activate()</a></em>. </p>
<p>This memorization is required such that a <em><a class="el" href="classabacus_1_1_sub.html#a3738dfb4be5571ddc4bbd5b1b4afe9f0" title="Can be used as entrance point for problem specific deactivations after the subproblem optimization...">deactivate()</a></em> is only called when <em><a class="el" href="classabacus_1_1_sub.html#ae22a4eb3419a6665e28cbeb0b592bcba" title="Can be used as an entrance point for problem specific activations. ">activate()</a></em> has been called. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01790">1790</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="aadc2faec4d94cb5e02443fc6e0181b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc2faec4d94cb5e02443fc6e0181b57">&#9670;&nbsp;</a></span>actVar_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_active.html">Active</a>&lt;<a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>&gt;* abacus::Sub::actVar_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The active variables of the subproblem. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01442">1442</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="aba078252265efe4627589816f97a79cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba078252265efe4627589816f97a79cf">&#9670;&nbsp;</a></span>addConBuffer_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_cut_buffer.html">CutBuffer</a>&lt;<a class="el" href="classabacus_1_1_constraint.html">Constraint</a>, <a class="el" href="classabacus_1_1_variable.html">Variable</a>&gt;* abacus::Sub::addConBuffer_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The buffer of the newly generated constraints. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01503">1503</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a7a6bd55440ef8cbbbfcf47ea5ef49214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6bd55440ef8cbbbfcf47ea5ef49214">&#9670;&nbsp;</a></span>addVarBuffer_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_cut_buffer.html">CutBuffer</a>&lt;<a class="el" href="classabacus_1_1_variable.html">Variable</a>, <a class="el" href="classabacus_1_1_constraint.html">Constraint</a>&gt;* abacus::Sub::addVarBuffer_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The buffer of the newly generated variables. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01500">1500</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a6cbf51d85ba335dc187ad1091cc01753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cbf51d85ba335dc187ad1091cc01753">&#9670;&nbsp;</a></span>allBranchOnSetVars_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abacus::Sub::allBranchOnSetVars_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If <em>true</em>, then the branching rule of the subproblem and of all ancestor on the path to the root node are branching on a binary variable. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01494">1494</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a7256d650a1b4aee831f10307af839f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7256d650a1b4aee831f10307af839f4b">&#9670;&nbsp;</a></span>bInvRow_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double* abacus::Sub::bInvRow_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A row of the basis inverse associated with the infeasible variable <em>infeasVar_</em> or slack variable <em>infeasCon_</em>. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01518">1518</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a28ec2cdf25ad585ece88a6a8082a2b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ec2cdf25ad585ece88a6a8082a2b5f">&#9670;&nbsp;</a></span>branchRule_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_branch_rule.html">BranchRule</a>* abacus::Sub::branchRule_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The branching rule for the subproblem. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01488">1488</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ae24b81e53fed6385ba07d7c5d6b02d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24b81e53fed6385ba07d7c5d6b02d69">&#9670;&nbsp;</a></span>conReserve_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double abacus::Sub::conReserve_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The additional space for constraints. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01777">1777</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a65685ce21f0fa98c2c5009d0c9932bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65685ce21f0fa98c2c5009d0c9932bbf">&#9670;&nbsp;</a></span>dualBound_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double abacus::Sub::dualBound_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The dual bound of the subproblem. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01476">1476</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ab6b53451afbd864a53e832ae8a3ea98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b53451afbd864a53e832ae8a3ea98b">&#9670;&nbsp;</a></span>father_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_sub.html">Sub</a>* abacus::Sub::father_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to the father in the branch-and-cut tree. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01445">1445</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a9a23b352fe66ec04e79ba29aa2894203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a23b352fe66ec04e79ba29aa2894203">&#9670;&nbsp;</a></span>forceExactSolver_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abacus::Sub::forceExactSolver_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether to force the use of an exact solver to prepare branching etc. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01805">1805</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ab03823561636c5e96f282c2291a87612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03823561636c5e96f282c2291a87612">&#9670;&nbsp;</a></span>fsVarStat_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt;<a class="el" href="classabacus_1_1_f_s_var_stat.html">FSVarStat</a>*&gt;* abacus::Sub::fsVarStat_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to an array storing the status of fixing and setting of the active variables. </p>
<p>Although fixed and set variables are already kept at their value by the adaption of the lower and upper bounds, we store this information, since, e.g., a fixed or set variable should not be removed, but a variable with an upper bound equal to the lower bound can be removed. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01458">1458</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="aa35b65e53b38f697bf162f053ac403f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35b65e53b38f697bf162f053ac403f8">&#9670;&nbsp;</a></span>genNonLiftCons_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abacus::Sub::genNonLiftCons_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If <em>true</em>, then the management of non-liftable constraints is performed. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01527">1527</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a8dc76c79c409c68eb4f6d00719d5f31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc76c79c409c68eb4f6d00719d5f31e">&#9670;&nbsp;</a></span>id_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::id_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of the subproblem. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01749">1749</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="aed53999c8aa472004caa1469656ccdca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed53999c8aa472004caa1469656ccdca">&#9670;&nbsp;</a></span>ignoreInTailingOff_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abacus::Sub::ignoreInTailingOff_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this flag is set to <em>true</em> then the next LP-solution is ignored in the tailing-off control. </p>
<p>The default value of the variable is <em>false</em>. It can be set to <em>true</em> by the function <em><a class="el" href="classabacus_1_1_sub.html#abd373c0f807d36399d4db25ff5967a70" title="Can be used to control better the tailing-off effect. ">ignoreInTailingOff()</a></em>. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01797">1797</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ac6aca20e9610687f972379fba19b5123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6aca20e9610687f972379fba19b5123">&#9670;&nbsp;</a></span>infeasCon_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::infeasCon_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of an infeasible constraint. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01521">1521</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a1ab884230dec22075a51a393708dff82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab884230dec22075a51a393708dff82">&#9670;&nbsp;</a></span>infeasVar_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::infeasVar_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of an infeasible variable. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01524">1524</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a14667d0a59ebe4858f60250b7faca617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14667d0a59ebe4858f60250b7faca617">&#9670;&nbsp;</a></span>lastIterConAdd_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::lastIterConAdd_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The last iteration in which constraints have been added. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01482">1482</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a7a35f82c83ebecf0c9aecd2bca051add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a35f82c83ebecf0c9aecd2bca051add">&#9670;&nbsp;</a></span>lastIterVarAdd_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::lastIterVarAdd_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The last iteration in which variables have been added. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01485">1485</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="acaa446e79a69adc949422028a81db23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa446e79a69adc949422028a81db23e">&#9670;&nbsp;</a></span>lastLP_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_l_p.html#a80d390b461dca15f5aba8068995b0063">LP::METHOD</a> abacus::Sub::lastLP_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The method that was used to solve the last <a class="el" href="classabacus_1_1_l_p.html" title="Linear programs. ">LP</a>. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01800">1800</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ac7a6aa61019e8476ebf4545969da651a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a6aa61019e8476ebf4545969da651a">&#9670;&nbsp;</a></span>lBound_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt;double&gt;* abacus::Sub::lBound_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to an array with the local lower bound of the active variables. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01464">1464</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a4308fc252ddcf2b4adbf3e0d9e146fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4308fc252ddcf2b4adbf3e0d9e146fc5">&#9670;&nbsp;</a></span>level_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::level_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The level of the subproblem in the enumeration tree. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01746">1746</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="aad53c79fae7d51cd31e5e2167741165a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad53c79fae7d51cd31e5e2167741165a">&#9670;&nbsp;</a></span>localTimer_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_stopwatch_c_p_u.html">ogdf::StopwatchCPU</a> abacus::Sub::localTimer_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01802">1802</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a721065f2cdc9c75a7c2fdc30e14987db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721065f2cdc9c75a7c2fdc30e14987db">&#9670;&nbsp;</a></span>lp_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_lp_sub.html">LpSub</a>* abacus::Sub::lp_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to the corresponding linear program. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01448">1448</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a0e2907985939af27d06eb78959fade1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2907985939af27d06eb78959fade1c">&#9670;&nbsp;</a></span>lpMethod_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_l_p.html#a80d390b461dca15f5aba8068995b0063">LP::METHOD</a> abacus::Sub::lpMethod_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The solution method for the next linear program. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01497">1497</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a7dc1b0772e8e0190032e7c3d46b8c711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc1b0772e8e0190032e7c3d46b8c711">&#9670;&nbsp;</a></span>lpVarStat_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt;<a class="el" href="classabacus_1_1_l_p_v_a_r_s_t_a_t.html">LPVARSTAT</a>*&gt;* abacus::Sub::lpVarStat_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to an array storing the status of each active variable in the linear program. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01461">1461</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ad37af4a37e334552fa3179f3f9229663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37af4a37e334552fa3179f3f9229663">&#9670;&nbsp;</a></span>master_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_master.html">Master</a>* abacus::Sub::master_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to the corresponding master of the optimization. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01436">1436</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="acee3d66704b45c2ef04b6fabb15b752e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee3d66704b45c2ef04b6fabb15b752e">&#9670;&nbsp;</a></span>maxIterations_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::maxIterations_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum number of iterations in the cutting plane phase. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01758">1758</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="aeb4ef28c3d7424d848b5dee7667b70dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4ef28c3d7424d848b5dee7667b70dd">&#9670;&nbsp;</a></span>nDormantRounds_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::nDormantRounds_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of subproblem optimizations the subproblem has already the status <em>Dormant</em>. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01783">1783</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a7278521411cf0104edbf3fa62d4075c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7278521411cf0104edbf3fa62d4075c6">&#9670;&nbsp;</a></span>nIter_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::nIter_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of iterations in the cutting plane phase. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01479">1479</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="adb6a0f9e88a7d3ce34bb8a25bf5d1b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6a0f9e88a7d3ce34bb8a25bf5d1b63">&#9670;&nbsp;</a></span>nnzReserve_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double abacus::Sub::nnzReserve_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The additional space for nonzeros. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01780">1780</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a7e11b2b659ba658d803e2fc4f7ed8a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e11b2b659ba658d803e2fc4f7ed8a00">&#9670;&nbsp;</a></span>nOpt_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int abacus::Sub::nOpt_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of optimizations of the subproblem. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01761">1761</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a824244b4ef5f23606508e64662f1b397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824244b4ef5f23606508e64662f1b397">&#9670;&nbsp;</a></span>relativeReserve_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abacus::Sub::relativeReserve_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this member is <em>true</em> then the space reserve of the following three members <em>varReserve_</em>, <em>conReserve_</em>, and <em>nnzReserve_</em> is relative to the initial numbers of constraints, variables, and nonzeros, respectively. </p>
<p>Otherwise, the values are casted to integers and regarded as absolute values. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01771">1771</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a6db882b9bb022036456e6fb575104db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db882b9bb022036456e6fb575104db0">&#9670;&nbsp;</a></span>removeConBuffer_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt;int&gt;* abacus::Sub::removeConBuffer_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The buffer of the constraints which are removed at the beginning of the next iteration. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01509">1509</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a077e405efdfa53cebbca96851df163dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077e405efdfa53cebbca96851df163dc">&#9670;&nbsp;</a></span>removeVarBuffer_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt;int&gt;* abacus::Sub::removeVarBuffer_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The buffer of the variables which are removed at the beginning of the next iteration. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01506">1506</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="acc296377f537c233ee5ee1893dca5a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc296377f537c233ee5ee1893dca5a86">&#9670;&nbsp;</a></span>slackStat_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt;<a class="el" href="classabacus_1_1_slack_stat.html">SlackStat</a>*&gt;* abacus::Sub::slackStat_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to an array storing the statuses of the slack variables of the last solved linear program. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01470">1470</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="aa0b4ca87a0b6cad408b371820dae4cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b4ca87a0b6cad408b371820dae4cee">&#9670;&nbsp;</a></span>sons_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_array_buffer.html">ArrayBuffer</a>&lt;<a class="el" href="classabacus_1_1_sub.html">Sub</a>*&gt;* abacus::Sub::sons_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The sons of the node in the branch-and-cut tree. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01755">1755</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a4f00b594075dc21be76b2e2988f0f702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f00b594075dc21be76b2e2988f0f702">&#9670;&nbsp;</a></span>status_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_sub.html#a49aa228f17967fc8ac589b5fb7bc3297">STATUS</a> abacus::Sub::status_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The status of the subproblem. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01752">1752</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a894b35a30a8be59719014ee7afcd2704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894b35a30a8be59719014ee7afcd2704">&#9670;&nbsp;</a></span>tailOff_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classabacus_1_1_tail_off.html">TailOff</a>* abacus::Sub::tailOff_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to the tailing off manager. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01473">1473</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="a221a27d9555e4349ccb010374c003ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221a27d9555e4349ccb010374c003ec1">&#9670;&nbsp;</a></span>uBound_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt;double&gt;* abacus::Sub::uBound_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to an array with the local upper bounds of the active variables. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01467">1467</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="adaf8c65703b53568b30b3131560c58ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf8c65703b53568b30b3131560c58ff">&#9670;&nbsp;</a></span>varReserve_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double abacus::Sub::varReserve_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The additional space for variables. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01774">1774</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ab6e1176f96f27168f1831c2a94e727a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e1176f96f27168f1831c2a94e727a1">&#9670;&nbsp;</a></span>xVal_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double* abacus::Sub::xVal_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The last LP-solution. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01512">1512</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<a id="ae1542533318ef9f52bd59e3db06e4ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1542533318ef9f52bd59e3db06e4ba5">&#9670;&nbsp;</a></span>yVal_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double* abacus::Sub::yVal_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The dual variables of the last linear program. </p>

<p class="definition">Definition at line <a class="el" href="sub_8h_source.html#l01515">1515</a> of file <a class="el" href="sub_8h_source.html">sub.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ogdf/lib/abacus/<a class="el" href="sub_8h_source.html">sub.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceabacus.html">abacus</a></li><li class="navelem"><a class="el" href="classabacus_1_1_sub.html">Sub</a></li>
    <li class="footer">&copy; 1999&ndash;2017 <a href="http://ogdf.net/doku.php/team:about">The OGDF Team</a></li>
  </ul>
</div>
</body>
</html>
