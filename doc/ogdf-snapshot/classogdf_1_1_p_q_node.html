<!-- HTML header for doxygen 1.8.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>ogdf: ogdf::PQNode&lt; T, X, Y &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="govisual.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogdf-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
  <td align="center">
   <table border="0" cellspacing="0" cellpadding="0">
    <tr>
     <td width="264"><a href="http://www.ogdf.net" title="Go to www.ogdf.net" target="blank"><img  style="border-width: 0px" src="http://www.ogdf.net/lib/images/logoA.png"/></a></td>
     <td align="left"><h1 class="ogdftitle">Open<br>Graph Drawing<br>Framework</h1></td>
        <td align="left" valign="bottom" >
      <span style="font-size:110%; color:rgb(56,95,118)">&nbsp;v. snapshot-2015-12-04</span><br>&nbsp;
        </td>
    </tr>
   </table>
  </td>
 </tr>
 <tr>
  <td valign="bottom">
   <div class="menubox">
    <table border="0" cellpadding="0" cellspacing="0" class="menutable">
     <tr>
      <td><a class="menu" href="index.html" title="Start page with overview">Overview</a></td>
      <td><a class="menu" href="hierarchy.html" title="Inheritance hierarchies">Class&nbsp;Hierarchy</a></td>
      <td><a class="menu" href="classes.html" title="Alphabetical list of classes">Class&nbsp;Index</a></td>
      <td><a class="menu" href="annotated.html" title="Classes with brief descriptions">Class&nbsp;List</a></td>
      <td><a class="menu" href="functions.html" title="Complete list of member functions, enumerations, and variables">Members</a></td>
      <td><a class="menu" href="namespaces.html" title="Namespaces with brief descriptions">Namespaces</a></td>
      <td><a class="menu" href="files.html" title="Complete list of files with brief descriptions">Source&nbsp;Files</a></td>
          <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
     </tr>
    </table>
   </div><br>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classogdf_1_1_p_q_node.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classogdf_1_1_p_q_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ogdf::PQNode&lt; T, X, Y &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The class template <a class="el" href="classogdf_1_1_p_q_basic_key.html">PQBasicKey</a> is an abstract base class.  
 <a href="classogdf_1_1_p_q_node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_p_q_basic_key_8h_source.html">ogdf/internal/planarity/PQBasicKey.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for ogdf::PQNode&lt; T, X, Y &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classogdf_1_1_p_q_node.png" usemap="#ogdf::PQNode_3C_20T_2C_20X_2C_20Y_20_3E_map" alt=""/>
  <map id="ogdf::PQNode_3C_20T_2C_20X_2C_20Y_20_3E_map" name="ogdf::PQNode&lt; T, X, Y &gt;_map">
<area href="classogdf_1_1_p_q_node_root.html" title="The class PQNodeRoot is used as a base class of the class PQNode. " alt="ogdf::PQNodeRoot" shape="rect" coords="105,0,305,24"/>
<area href="classogdf_1_1_p_q_internal_node.html" title="The class template PQInternalNode is used to present P-nodes and Q-nodes in the PQ-Tree. " alt="ogdf::PQInternalNode&lt; T, X, Y &gt;" shape="rect" coords="0,112,200,136"/>
<area href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen..." alt="ogdf::PQLeaf&lt; T, X, Y &gt;" shape="rect" coords="210,112,410,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a39cbddba87ff42153e84d9a5d4a9d980"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a39cbddba87ff42153e84d9a5d4a9d980">PQNode</a> (int count, <a class="el" href="classogdf_1_1_p_q_node_key.html">PQNodeKey</a>&lt; T, X, Y &gt; *infoPtr)</td></tr>
<tr class="memdesc:a39cbddba87ff42153e84d9a5d4a9d980"><td class="mdescLeft">&#160;</td><td class="mdescRight">The (first) constructor combines the node with its information and will automatically set the <em>m_nodePointer</em> (see basicKey) of the element of type <a class="el" href="classogdf_1_1_p_q_node_key.html" title="The class template PQNodeKey is a derived class of class template PQBasicKey. ">PQNodeKey</a>.  <a href="#a39cbddba87ff42153e84d9a5d4a9d980">More...</a><br /></td></tr>
<tr class="separator:a39cbddba87ff42153e84d9a5d4a9d980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fa986b046f7b21d9c41021f0975505"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a29fa986b046f7b21d9c41021f0975505">PQNode</a> (int count)</td></tr>
<tr class="memdesc:a29fa986b046f7b21d9c41021f0975505"><td class="mdescLeft">&#160;</td><td class="mdescRight">The (second) constructor is called, if no information is available or neccessary.  <a href="#a29fa986b046f7b21d9c41021f0975505">More...</a><br /></td></tr>
<tr class="separator:a29fa986b046f7b21d9c41021f0975505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c18693d22239feefa072dfcba5282f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a72c18693d22239feefa072dfcba5282f">~PQNode</a> ()</td></tr>
<tr class="memdesc:a72c18693d22239feefa072dfcba5282f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor does not delete any accompanying information class as <a class="el" href="classogdf_1_1_p_q_leaf_key.html" title="The class template PQLeafKey is a derived class of class template PQBasicKey. ">PQLeafKey</a>, <a class="el" href="classogdf_1_1_p_q_node_key.html" title="The class template PQNodeKey is a derived class of class template PQBasicKey. ">PQNodeKey</a> and <a class="el" href="classogdf_1_1_p_q_internal_key.html" title="The class template PQInternalKey is a derived class of class template PQBasicKey. ...">PQInternalKey</a>.  <a href="#a72c18693d22239feefa072dfcba5282f">More...</a><br /></td></tr>
<tr class="separator:a72c18693d22239feefa072dfcba5282f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d9009ddaf0cb5c2b871a5d6a012b17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a76d9009ddaf0cb5c2b871a5d6a012b17">changeEndmost</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *oldEnd, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *newEnd)</td></tr>
<tr class="memdesc:a76d9009ddaf0cb5c2b871a5d6a012b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function <a class="el" href="classogdf_1_1_p_q_node.html#a76d9009ddaf0cb5c2b871a5d6a012b17" title="The function changeEndmost() replaces the old endmost child oldEnd of the node by a new child newEnd...">changeEndmost()</a> replaces the old endmost child <em>oldEnd</em> of the node by a new child <em>newEnd</em>.  <a href="#a76d9009ddaf0cb5c2b871a5d6a012b17">More...</a><br /></td></tr>
<tr class="separator:a76d9009ddaf0cb5c2b871a5d6a012b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f5498d3d3d785afb03c08f2f560763"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a22f5498d3d3d785afb03c08f2f560763">changeSiblings</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *oldSib, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *newSib)</td></tr>
<tr class="memdesc:a22f5498d3d3d785afb03c08f2f560763"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function <a class="el" href="classogdf_1_1_p_q_node.html#a22f5498d3d3d785afb03c08f2f560763" title="The function changeSiblings() replaces the old sibling oldSib of the node by a new sibling newSib...">changeSiblings()</a> replaces the old sibling <em>oldSib</em> of the node by a new sibling <em>newSib</em>.  <a href="#a22f5498d3d3d785afb03c08f2f560763">More...</a><br /></td></tr>
<tr class="separator:a22f5498d3d3d785afb03c08f2f560763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d45970a8a390bf0e153c2a12e11d57"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a67d45970a8a390bf0e153c2a12e11d57">childCount</a> () const</td></tr>
<tr class="memdesc:a67d45970a8a390bf0e153c2a12e11d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of children of a node.  <a href="#a67d45970a8a390bf0e153c2a12e11d57">More...</a><br /></td></tr>
<tr class="separator:a67d45970a8a390bf0e153c2a12e11d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363dc83e6011b6118bc09eeeaed9d94b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a363dc83e6011b6118bc09eeeaed9d94b">childCount</a> (int count)</td></tr>
<tr class="memdesc:a363dc83e6011b6118bc09eeeaed9d94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of children of a node.  <a href="#a363dc83e6011b6118bc09eeeaed9d94b">More...</a><br /></td></tr>
<tr class="separator:a363dc83e6011b6118bc09eeeaed9d94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f45a5c3c9a70e40d69907db86b78a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#ab4f45a5c3c9a70e40d69907db86b78a0">endmostChild</a> ()</td></tr>
<tr class="memdesc:ab4f45a5c3c9a70e40d69907db86b78a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function <a class="el" href="classogdf_1_1_p_q_node.html#ab4f45a5c3c9a70e40d69907db86b78a0" title="The function endmostChild() checks if a node is endmost child of a Q-node. ">endmostChild()</a> checks if a node is endmost child of a Q-node.  <a href="#ab4f45a5c3c9a70e40d69907db86b78a0">More...</a><br /></td></tr>
<tr class="separator:ab4f45a5c3c9a70e40d69907db86b78a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029c3c7d21ec08b1eba4eff266c61c45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a029c3c7d21ec08b1eba4eff266c61c45">getEndmost</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *other) const</td></tr>
<tr class="memdesc:a029c3c7d21ec08b1eba4eff266c61c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of the endmost children of node, if node is a Q-node.  <a href="#a029c3c7d21ec08b1eba4eff266c61c45">More...</a><br /></td></tr>
<tr class="separator:a029c3c7d21ec08b1eba4eff266c61c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af547eecd69ce65d0f04e96cefd27a5c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#af547eecd69ce65d0f04e96cefd27a5c7">getEndmost</a> (int side) const</td></tr>
<tr class="memdesc:af547eecd69ce65d0f04e96cefd27a5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of the endmost children of node, if node is a Q-node.  <a href="#af547eecd69ce65d0f04e96cefd27a5c7">More...</a><br /></td></tr>
<tr class="separator:af547eecd69ce65d0f04e96cefd27a5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f3b3ec9e44ae199f92731e1a2e974f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classogdf_1_1_p_q_internal_key.html">PQInternalKey</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#ae4f3b3ec9e44ae199f92731e1a2e974f">getInternal</a> () const =0</td></tr>
<tr class="memdesc:ae4f3b3ec9e44ae199f92731e1a2e974f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classogdf_1_1_p_q_node.html#ae4f3b3ec9e44ae199f92731e1a2e974f" title="getInternal() returns a pointer to the PQInternalKey information of a node, in case that the node is ...">getInternal()</a> returns a pointer to the <a class="el" href="classogdf_1_1_p_q_internal_key.html" title="The class template PQInternalKey is a derived class of class template PQBasicKey. ...">PQInternalKey</a> information of a node, in case that the node is supposed to have <a class="el" href="classogdf_1_1_p_q_internal_key.html" title="The class template PQInternalKey is a derived class of class template PQBasicKey. ...">PQInternalKey</a> information, such as elements of the derived class template <a class="el" href="classogdf_1_1_p_q_internal_node.html" title="The class template PQInternalNode is used to present P-nodes and Q-nodes in the PQ-Tree. ">PQInternalNode</a>.  <a href="#ae4f3b3ec9e44ae199f92731e1a2e974f">More...</a><br /></td></tr>
<tr class="separator:ae4f3b3ec9e44ae199f92731e1a2e974f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc12c8f7a8f0f6946d8b76e283cadb7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#acdc12c8f7a8f0f6946d8b76e283cadb7">getKey</a> () const =0</td></tr>
<tr class="memdesc:acdc12c8f7a8f0f6946d8b76e283cadb7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classogdf_1_1_p_q_node.html#acdc12c8f7a8f0f6946d8b76e283cadb7" title="getKey() returns a pointer to the PQLeafKeyof a node, in case that the node is supposed to have a key...">getKey()</a> returns a pointer to the PQLeafKeyof a node, in case that the node is supposed to have a key, such as elements of the derived class template <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a>.  <a href="#acdc12c8f7a8f0f6946d8b76e283cadb7">More...</a><br /></td></tr>
<tr class="separator:acdc12c8f7a8f0f6946d8b76e283cadb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88f64449f1fa6800b680c204b7dcc72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#af88f64449f1fa6800b680c204b7dcc72">getNextSib</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *other) const</td></tr>
<tr class="memdesc:af88f64449f1fa6800b680c204b7dcc72"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function <a class="el" href="classogdf_1_1_p_q_node.html#af88f64449f1fa6800b680c204b7dcc72" title="The function getNextSib() returns one of the siblings of the node. ">getNextSib()</a> returns one of the siblings of the node.  <a href="#af88f64449f1fa6800b680c204b7dcc72">More...</a><br /></td></tr>
<tr class="separator:af88f64449f1fa6800b680c204b7dcc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af975df47fae28f8e8997286662517e86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node_key.html">PQNodeKey</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#af975df47fae28f8e8997286662517e86">getNodeInfo</a> () const</td></tr>
<tr class="memdesc:af975df47fae28f8e8997286662517e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the identification number of a node.  <a href="#af975df47fae28f8e8997286662517e86">More...</a><br /></td></tr>
<tr class="separator:af975df47fae28f8e8997286662517e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f4876e6c8011bcafd37894f8210040"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#af0f4876e6c8011bcafd37894f8210040">getSib</a> (int side) const</td></tr>
<tr class="memdesc:af0f4876e6c8011bcafd37894f8210040"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function <a class="el" href="classogdf_1_1_p_q_node.html#af0f4876e6c8011bcafd37894f8210040" title="The function getSib() returns one of the siblings of the node. ">getSib()</a> returns one of the siblings of the node.  <a href="#af0f4876e6c8011bcafd37894f8210040">More...</a><br /></td></tr>
<tr class="separator:af0f4876e6c8011bcafd37894f8210040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b1c94cc9eb5657cf21cdcef7b9abe6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a74b1c94cc9eb5657cf21cdcef7b9abe6">identificationNumber</a> () const</td></tr>
<tr class="memdesc:a74b1c94cc9eb5657cf21cdcef7b9abe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the identification number of a node.  <a href="#a74b1c94cc9eb5657cf21cdcef7b9abe6">More...</a><br /></td></tr>
<tr class="separator:a74b1c94cc9eb5657cf21cdcef7b9abe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c96574f7d72280ef71cf300b349a00b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classogdf_1_1_p_q_node_root.html#a3f6cca0e865c4aedb9f96ec14a53f7ce">PQNodeMark</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a8c96574f7d72280ef71cf300b349a00b">mark</a> () const =0</td></tr>
<tr class="memdesc:a8c96574f7d72280ef71cf300b349a00b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classogdf_1_1_p_q_node.html#a8c96574f7d72280ef71cf300b349a00b" title="mark() returns the variable m_mark in the derived class PQLeaf and PQInternalNode. ">mark()</a> returns the variable <em>m_mark</em> in the derived class <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a> and <a class="el" href="classogdf_1_1_p_q_internal_node.html" title="The class template PQInternalNode is used to present P-nodes and Q-nodes in the PQ-Tree. ">PQInternalNode</a>.  <a href="#a8c96574f7d72280ef71cf300b349a00b">More...</a><br /></td></tr>
<tr class="separator:a8c96574f7d72280ef71cf300b349a00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c36b8ac0b6e186efd3f50d2afe0ed7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a00c36b8ac0b6e186efd3f50d2afe0ed7">mark</a> (<a class="el" href="classogdf_1_1_p_q_node_root.html#a3f6cca0e865c4aedb9f96ec14a53f7ce">PQNodeMark</a>)=0</td></tr>
<tr class="memdesc:a00c36b8ac0b6e186efd3f50d2afe0ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classogdf_1_1_p_q_node.html#a8c96574f7d72280ef71cf300b349a00b" title="mark() returns the variable m_mark in the derived class PQLeaf and PQInternalNode. ">mark()</a> sets the variable <em>m_mark</em> in the derived class <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a> and <a class="el" href="classogdf_1_1_p_q_internal_node.html" title="The class template PQInternalNode is used to present P-nodes and Q-nodes in the PQ-Tree. ">PQInternalNode</a>.  <a href="#a00c36b8ac0b6e186efd3f50d2afe0ed7">More...</a><br /></td></tr>
<tr class="separator:a00c36b8ac0b6e186efd3f50d2afe0ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99a57d8d29e7e44d58fc33a95bd53f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#ab99a57d8d29e7e44d58fc33a95bd53f6">parent</a> () const</td></tr>
<tr class="memdesc:ab99a57d8d29e7e44d58fc33a95bd53f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function <a class="el" href="classogdf_1_1_p_q_node.html#ab99a57d8d29e7e44d58fc33a95bd53f6" title="The function parent() returns a pointer to the parent of a node. ">parent()</a> returns a pointer to the parent of a node.  <a href="#ab99a57d8d29e7e44d58fc33a95bd53f6">More...</a><br /></td></tr>
<tr class="separator:ab99a57d8d29e7e44d58fc33a95bd53f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f130805d04651906535716125ac02a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a19f130805d04651906535716125ac02a">parent</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *newParent)</td></tr>
<tr class="memdesc:a19f130805d04651906535716125ac02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the parent pointer of a node.  <a href="#a19f130805d04651906535716125ac02a">More...</a><br /></td></tr>
<tr class="separator:a19f130805d04651906535716125ac02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3b11a4fea3164715a133f32b85c21c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a2d3b11a4fea3164715a133f32b85c21c">parentType</a> () const</td></tr>
<tr class="memdesc:a2d3b11a4fea3164715a133f32b85c21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the parent of a node.  <a href="#a2d3b11a4fea3164715a133f32b85c21c">More...</a><br /></td></tr>
<tr class="separator:a2d3b11a4fea3164715a133f32b85c21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dbec4671deec32cece75a0ca183b19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a03dbec4671deec32cece75a0ca183b19">parentType</a> (int newParentType)</td></tr>
<tr class="memdesc:a03dbec4671deec32cece75a0ca183b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type of the parent of a node.  <a href="#a03dbec4671deec32cece75a0ca183b19">More...</a><br /></td></tr>
<tr class="separator:a03dbec4671deec32cece75a0ca183b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35f5fc8193afda9148e5b07d86ad251"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#ae35f5fc8193afda9148e5b07d86ad251">pertChildCount</a> () const</td></tr>
<tr class="memdesc:ae35f5fc8193afda9148e5b07d86ad251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returs the number of pertinent children of a node.  <a href="#ae35f5fc8193afda9148e5b07d86ad251">More...</a><br /></td></tr>
<tr class="separator:ae35f5fc8193afda9148e5b07d86ad251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4609b5c8acb0188b6e6db27c120ec7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a3b4609b5c8acb0188b6e6db27c120ec7">pertChildCount</a> (int count)</td></tr>
<tr class="memdesc:a3b4609b5c8acb0188b6e6db27c120ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of pertinent children of a node.  <a href="#a3b4609b5c8acb0188b6e6db27c120ec7">More...</a><br /></td></tr>
<tr class="separator:a3b4609b5c8acb0188b6e6db27c120ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fa00837a810be41f4df3e8497c60f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node_root.html#ad94cac0dfeca07ad5ad05f6e4fa3683f">SibDirection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a47fa00837a810be41f4df3e8497c60f4">putSibling</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *newSib)</td></tr>
<tr class="memdesc:a47fa00837a810be41f4df3e8497c60f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default function <a class="el" href="classogdf_1_1_p_q_node.html#a47fa00837a810be41f4df3e8497c60f4" title="The default function putSibling() stores a new sibling at a free sibling pointer of the node...">putSibling()</a> stores a new sibling at a free sibling pointer of the node.  <a href="#a47fa00837a810be41f4df3e8497c60f4">More...</a><br /></td></tr>
<tr class="separator:a47fa00837a810be41f4df3e8497c60f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44cc9afe7ecd1ed6fbcb9013db44d15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node_root.html#ad94cac0dfeca07ad5ad05f6e4fa3683f">SibDirection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#ae44cc9afe7ecd1ed6fbcb9013db44d15">putSibling</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *newSib, int preference)</td></tr>
<tr class="memdesc:ae44cc9afe7ecd1ed6fbcb9013db44d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function <a class="el" href="classogdf_1_1_p_q_node.html#a47fa00837a810be41f4df3e8497c60f4" title="The default function putSibling() stores a new sibling at a free sibling pointer of the node...">putSibling()</a> with preference stores a new sibling at a free sibling pointer of the node.  <a href="#ae44cc9afe7ecd1ed6fbcb9013db44d15">More...</a><br /></td></tr>
<tr class="separator:ae44cc9afe7ecd1ed6fbcb9013db44d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dba1a623cdfa3a8febd437da965b578"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a5dba1a623cdfa3a8febd437da965b578">referenceChild</a> () const</td></tr>
<tr class="memdesc:a5dba1a623cdfa3a8febd437da965b578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the reference child if node is a P-node.  <a href="#a5dba1a623cdfa3a8febd437da965b578">More...</a><br /></td></tr>
<tr class="separator:a5dba1a623cdfa3a8febd437da965b578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395da524ee8e126f04942ec9ca160acb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a395da524ee8e126f04942ec9ca160acb">referenceParent</a> () const</td></tr>
<tr class="memdesc:a395da524ee8e126f04942ec9ca160acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer to the parent if node is a reference child.  <a href="#a395da524ee8e126f04942ec9ca160acb">More...</a><br /></td></tr>
<tr class="separator:a395da524ee8e126f04942ec9ca160acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1260e5695ab1d215f2a4728357c306"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a7a1260e5695ab1d215f2a4728357c306">setInternal</a> (<a class="el" href="classogdf_1_1_p_q_internal_key.html">PQInternalKey</a>&lt; T, X, Y &gt; *pointerToInternal)=0</td></tr>
<tr class="separator:a7a1260e5695ab1d215f2a4728357c306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5497f243a46c2f9614cb857c7db1c721"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a5497f243a46c2f9614cb857c7db1c721">setKey</a> (<a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; *pointerToKey)=0</td></tr>
<tr class="memdesc:a5497f243a46c2f9614cb857c7db1c721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a specified pointer variable in a derived class to the specified adress of <em>pointerToKey</em> that is of type <a class="el" href="classogdf_1_1_p_q_leaf_key.html" title="The class template PQLeafKey is a derived class of class template PQBasicKey. ">PQLeafKey</a>.  <a href="#a5497f243a46c2f9614cb857c7db1c721">More...</a><br /></td></tr>
<tr class="separator:a5497f243a46c2f9614cb857c7db1c721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4b0aebe0be47ad0e6cfa799813b907"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a0d4b0aebe0be47ad0e6cfa799813b907">setNodeInfo</a> (<a class="el" href="classogdf_1_1_p_q_node_key.html">PQNodeKey</a>&lt; T, X, Y &gt; *pointerToInfo)</td></tr>
<tr class="memdesc:a0d4b0aebe0be47ad0e6cfa799813b907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pointer <em>m_pointerToInfo</em> to the specified adress of <em>pointerToInfo</em>.  <a href="#a0d4b0aebe0be47ad0e6cfa799813b907">More...</a><br /></td></tr>
<tr class="separator:a0d4b0aebe0be47ad0e6cfa799813b907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2b4162be77cd338344bd0506eef00b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1b">PQNodeStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a2f2b4162be77cd338344bd0506eef00b">status</a> () const =0</td></tr>
<tr class="memdesc:a2f2b4162be77cd338344bd0506eef00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variable <em>m_status</em> in the derived class <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a> and <a class="el" href="classogdf_1_1_p_q_internal_node.html" title="The class template PQInternalNode is used to present P-nodes and Q-nodes in the PQ-Tree. ">PQInternalNode</a>.  <a href="#a2f2b4162be77cd338344bd0506eef00b">More...</a><br /></td></tr>
<tr class="separator:a2f2b4162be77cd338344bd0506eef00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce14e4c77a6190f8ff29653c9ae6370"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a8ce14e4c77a6190f8ff29653c9ae6370">status</a> (<a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1b">PQNodeStatus</a>)=0</td></tr>
<tr class="memdesc:a8ce14e4c77a6190f8ff29653c9ae6370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the variable <em>m_status</em> in the derived class <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a> and <a class="el" href="classogdf_1_1_p_q_internal_node.html" title="The class template PQInternalNode is used to present P-nodes and Q-nodes in the PQ-Tree. ">PQInternalNode</a>.  <a href="#a8ce14e4c77a6190f8ff29653c9ae6370">More...</a><br /></td></tr>
<tr class="separator:a8ce14e4c77a6190f8ff29653c9ae6370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a36506d7789520a22f393a978e53a8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classogdf_1_1_p_q_node_root.html#a9e38dfed883dd0f643b1674e0dd25001">PQNodeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a01a36506d7789520a22f393a978e53a8">type</a> () const =0</td></tr>
<tr class="memdesc:a01a36506d7789520a22f393a978e53a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variable <em>m_type</em> in the derived class <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a> and <a class="el" href="classogdf_1_1_p_q_internal_node.html" title="The class template PQInternalNode is used to present P-nodes and Q-nodes in the PQ-Tree. ">PQInternalNode</a>.  <a href="#a01a36506d7789520a22f393a978e53a8">More...</a><br /></td></tr>
<tr class="separator:a01a36506d7789520a22f393a978e53a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d8e4b08ca02b7e468bc14dd5c206b3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#af2d8e4b08ca02b7e468bc14dd5c206b3">type</a> (<a class="el" href="classogdf_1_1_p_q_node_root.html#a9e38dfed883dd0f643b1674e0dd25001">PQNodeType</a>)=0</td></tr>
<tr class="memdesc:af2d8e4b08ca02b7e468bc14dd5c206b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the variable <em>m_type</em> in the derived class <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a> and <a class="el" href="classogdf_1_1_p_q_internal_node.html" title="The class template PQInternalNode is used to present P-nodes and Q-nodes in the PQ-Tree. ">PQInternalNode</a>.  <a href="#af2d8e4b08ca02b7e468bc14dd5c206b3">More...</a><br /></td></tr>
<tr class="separator:af2d8e4b08ca02b7e468bc14dd5c206b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classogdf_1_1_p_q_node_root"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classogdf_1_1_p_q_node_root')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classogdf_1_1_p_q_node_root.html">ogdf::PQNodeRoot</a></td></tr>
<tr class="memitem:a7a129893b75f4efffefb20dbbb2cfd35 inherit pub_methods_classogdf_1_1_p_q_node_root"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node_root.html#a7a129893b75f4efffefb20dbbb2cfd35">PQNodeRoot</a> ()</td></tr>
<tr class="separator:a7a129893b75f4efffefb20dbbb2cfd35 inherit pub_methods_classogdf_1_1_p_q_node_root"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6270aaf7aa82d553e15b31d7c56c155a inherit pub_methods_classogdf_1_1_p_q_node_root"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node_root.html#a6270aaf7aa82d553e15b31d7c56c155a">~PQNodeRoot</a> ()</td></tr>
<tr class="separator:a6270aaf7aa82d553e15b31d7c56c155a inherit pub_methods_classogdf_1_1_p_q_node_root"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4a0687a8595f0b2448fb67280a5a42ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_list.html">List</a>&lt; <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a4a0687a8595f0b2448fb67280a5a42ed">fullChildren</a></td></tr>
<tr class="memdesc:a4a0687a8595f0b2448fb67280a5a42ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores all full children of a node during a reduction.  <a href="#a4a0687a8595f0b2448fb67280a5a42ed">More...</a><br /></td></tr>
<tr class="separator:a4a0687a8595f0b2448fb67280a5a42ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e1bcbb0204589af448f527717c48bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#ae0e1bcbb0204589af448f527717c48bf">m_childCount</a></td></tr>
<tr class="separator:ae0e1bcbb0204589af448f527717c48bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf45e0f730d58607ee852398fd7f72cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#adf45e0f730d58607ee852398fd7f72cb">m_debugTreeNumber</a></td></tr>
<tr class="memdesc:adf45e0f730d58607ee852398fd7f72cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Needed for debuging purposes.  <a href="#adf45e0f730d58607ee852398fd7f72cb">More...</a><br /></td></tr>
<tr class="separator:adf45e0f730d58607ee852398fd7f72cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af017da96d4c263c58def1edd8c93525c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#af017da96d4c263c58def1edd8c93525c">m_firstFull</a></td></tr>
<tr class="memdesc:af017da96d4c263c58def1edd8c93525c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a pointer to the first full child of a Q-node.  <a href="#af017da96d4c263c58def1edd8c93525c">More...</a><br /></td></tr>
<tr class="separator:af017da96d4c263c58def1edd8c93525c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c296ee3ca6e82dea4830074d3f75f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a56c296ee3ca6e82dea4830074d3f75f7">m_identificationNumber</a></td></tr>
<tr class="memdesc:a56c296ee3ca6e82dea4830074d3f75f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each node that has been introduced once into the tree gets a unique number.  <a href="#a56c296ee3ca6e82dea4830074d3f75f7">More...</a><br /></td></tr>
<tr class="separator:a56c296ee3ca6e82dea4830074d3f75f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3ff35b814d92631b7b1a5daa8bced2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a3c3ff35b814d92631b7b1a5daa8bced2">m_leftEndmost</a></td></tr>
<tr class="separator:a3c3ff35b814d92631b7b1a5daa8bced2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7e212917f68c4cf3eef1a527ba3a25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#acb7e212917f68c4cf3eef1a527ba3a25">m_parent</a></td></tr>
<tr class="memdesc:acb7e212917f68c4cf3eef1a527ba3a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a pointer to the parent.  <a href="#acb7e212917f68c4cf3eef1a527ba3a25">More...</a><br /></td></tr>
<tr class="separator:acb7e212917f68c4cf3eef1a527ba3a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3cabd03f116b2c69494ec5cbd43823"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a7a3cabd03f116b2c69494ec5cbd43823">m_parentType</a></td></tr>
<tr class="memdesc:a7a3cabd03f116b2c69494ec5cbd43823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the type of the parent which can be either a P- or Q-node.  <a href="#a7a3cabd03f116b2c69494ec5cbd43823">More...</a><br /></td></tr>
<tr class="separator:a7a3cabd03f116b2c69494ec5cbd43823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0670ff54dcd643dc826952472424d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#adc0670ff54dcd643dc826952472424d8">m_pertChildCount</a></td></tr>
<tr class="memdesc:adc0670ff54dcd643dc826952472424d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the number of pertinent children of the node.  <a href="#adc0670ff54dcd643dc826952472424d8">More...</a><br /></td></tr>
<tr class="separator:adc0670ff54dcd643dc826952472424d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974523bca1e8be35e1e8888605f3d414"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a974523bca1e8be35e1e8888605f3d414">m_pertLeafCount</a></td></tr>
<tr class="memdesc:a974523bca1e8be35e1e8888605f3d414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the number of pertinent leaves in the frontier of the node.  <a href="#a974523bca1e8be35e1e8888605f3d414">More...</a><br /></td></tr>
<tr class="separator:a974523bca1e8be35e1e8888605f3d414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4de340841f0ecf711c2426d5368b5b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node_key.html">PQNodeKey</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#ad4de340841f0ecf711c2426d5368b5b1">m_pointerToInfo</a></td></tr>
<tr class="memdesc:ad4de340841f0ecf711c2426d5368b5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a pointer to the corresponding information of the node.  <a href="#ad4de340841f0ecf711c2426d5368b5b1">More...</a><br /></td></tr>
<tr class="separator:ad4de340841f0ecf711c2426d5368b5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab247e890ed429c16f89d2c77dea562ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#ab247e890ed429c16f89d2c77dea562ee">m_referenceChild</a></td></tr>
<tr class="memdesc:ab247e890ed429c16f89d2c77dea562ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a pointer to one child, the <b>reference child</b> of the doubly linked cirkular list of children of a P-node.  <a href="#ab247e890ed429c16f89d2c77dea562ee">More...</a><br /></td></tr>
<tr class="separator:ab247e890ed429c16f89d2c77dea562ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e90eb25ef0429cbc6ea6329da24f19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a10e90eb25ef0429cbc6ea6329da24f19">m_referenceParent</a></td></tr>
<tr class="memdesc:a10e90eb25ef0429cbc6ea6329da24f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a pointer to the parent, in case that the parent is a P-node and the node itself is its reference child.  <a href="#a10e90eb25ef0429cbc6ea6329da24f19">More...</a><br /></td></tr>
<tr class="separator:a10e90eb25ef0429cbc6ea6329da24f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848ce9c9f081b9d176d9236c95655eee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a848ce9c9f081b9d176d9236c95655eee">m_rightEndmost</a></td></tr>
<tr class="memdesc:a848ce9c9f081b9d176d9236c95655eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the right endmost child of a Q-node.  <a href="#a848ce9c9f081b9d176d9236c95655eee">More...</a><br /></td></tr>
<tr class="separator:a848ce9c9f081b9d176d9236c95655eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13313d82be207c516c7c785271cf20a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a13313d82be207c516c7c785271cf20a9">m_sibLeft</a></td></tr>
<tr class="memdesc:a13313d82be207c516c7c785271cf20a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a pointer ot the left sibling of <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class. ">PQNode</a>.  <a href="#a13313d82be207c516c7c785271cf20a9">More...</a><br /></td></tr>
<tr class="separator:a13313d82be207c516c7c785271cf20a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315449d038a4d9560a8c7431b87237e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a315449d038a4d9560a8c7431b87237e6">m_sibRight</a></td></tr>
<tr class="memdesc:a315449d038a4d9560a8c7431b87237e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a pointer ot the right sibling of <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class. ">PQNode</a>.  <a href="#a315449d038a4d9560a8c7431b87237e6">More...</a><br /></td></tr>
<tr class="separator:a315449d038a4d9560a8c7431b87237e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596ba8dfb7d7f070518b3daaaa1202d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_list.html">List</a>&lt; <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#a596ba8dfb7d7f070518b3daaaa1202d7">partialChildren</a></td></tr>
<tr class="memdesc:a596ba8dfb7d7f070518b3daaaa1202d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores all partial children of a node during a reduction.  <a href="#a596ba8dfb7d7f070518b3daaaa1202d7">More...</a><br /></td></tr>
<tr class="separator:a596ba8dfb7d7f070518b3daaaa1202d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac28a1590a36def6225276a4ead9f31ac"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node.html#ac28a1590a36def6225276a4ead9f31ac">PQTree&lt; T, X, Y &gt;</a></td></tr>
<tr class="memdesc:ac28a1590a36def6225276a4ead9f31ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">All members and member function of <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class. ">PQNode</a> are needed by the class template <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a>.  <a href="#ac28a1590a36def6225276a4ead9f31ac">More...</a><br /></td></tr>
<tr class="separator:ac28a1590a36def6225276a4ead9f31ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classogdf_1_1_p_q_node_root"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classogdf_1_1_p_q_node_root')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classogdf_1_1_p_q_node_root.html">ogdf::PQNodeRoot</a></td></tr>
<tr class="memitem:a3f6cca0e865c4aedb9f96ec14a53f7ce inherit pub_types_classogdf_1_1_p_q_node_root"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node_root.html#a3f6cca0e865c4aedb9f96ec14a53f7ce">PQNodeMark</a> { <a class="el" href="classogdf_1_1_p_q_node_root.html#a3f6cca0e865c4aedb9f96ec14a53f7ceabbe771a73fb5649f37f8c83c77f47645">UNMARKED</a> = 0, 
<a class="el" href="classogdf_1_1_p_q_node_root.html#a3f6cca0e865c4aedb9f96ec14a53f7cea6c639823084c43930acb5c9c17842f6e">QUEUED</a> = 1, 
<a class="el" href="classogdf_1_1_p_q_node_root.html#a3f6cca0e865c4aedb9f96ec14a53f7ceae5b526efbb62bbca3e27f47c7d4705ee">BLOCKED</a> = 2, 
<a class="el" href="classogdf_1_1_p_q_node_root.html#a3f6cca0e865c4aedb9f96ec14a53f7cea816ce594180672e1dc99bcafa8c1d5d8">UNBLOCKED</a> = 3
 }</td></tr>
<tr class="separator:a3f6cca0e865c4aedb9f96ec14a53f7ce inherit pub_types_classogdf_1_1_p_q_node_root"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7729cc8321784a24f8a9391c11396e1b inherit pub_types_classogdf_1_1_p_q_node_root"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1b">PQNodeStatus</a> { <a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1bacb5244a10649a54fd10ea71db2b9b0f1">EMPTY</a> = 1, 
<a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1ba05d39cf401c6532837e0062b62f3c43f">PARTIAL</a> = 2, 
<a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1baa2f7997fb7a07827c9dd27006a1aa8a1">FULL</a> = 3, 
<a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1bae4c31d48a6d07e686e4ca6b88481a9b7">PERTINENT</a> = 4, 
<a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1ba1556b72a64e7b0d280a0aadee2abcf49">TO_BE_DELETED</a> = 5, 
<a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1ba141ca5f3feafd019d552b7439c8d0073">INDICATOR</a> = 6, 
<a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1ba48e2a6b83694ce62a3497846b3954c48">ELIMINATED</a> = 6, 
<a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1baae2b756e0a8122f4283c0baf2c929373">WHA_DELETE</a> = 7, 
<a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1bafd1ed4ae5b558d7e4ea11aea345e2337">PERTROOT</a> = 8
 }</td></tr>
<tr class="separator:a7729cc8321784a24f8a9391c11396e1b inherit pub_types_classogdf_1_1_p_q_node_root"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e38dfed883dd0f643b1674e0dd25001 inherit pub_types_classogdf_1_1_p_q_node_root"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node_root.html#a9e38dfed883dd0f643b1674e0dd25001">PQNodeType</a> { <a class="el" href="classogdf_1_1_p_q_node_root.html#a9e38dfed883dd0f643b1674e0dd25001a6372b8bd589c51711ab3e3dd4967b90a">PNode</a> = 1, 
<a class="el" href="classogdf_1_1_p_q_node_root.html#a9e38dfed883dd0f643b1674e0dd25001adc14a074c8c8170ead1cf4a648673c05">QNode</a> = 2, 
<a class="el" href="classogdf_1_1_p_q_node_root.html#a9e38dfed883dd0f643b1674e0dd25001a720e5f2fd23d9985f1cfd60ebb0f2425">leaf</a> = 3
 }</td></tr>
<tr class="separator:a9e38dfed883dd0f643b1674e0dd25001 inherit pub_types_classogdf_1_1_p_q_node_root"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94cac0dfeca07ad5ad05f6e4fa3683f inherit pub_types_classogdf_1_1_p_q_node_root"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_node_root.html#ad94cac0dfeca07ad5ad05f6e4fa3683f">SibDirection</a> { <a class="el" href="classogdf_1_1_p_q_node_root.html#ad94cac0dfeca07ad5ad05f6e4fa3683fa2b5f1ed86b2b12752cc7f3b211c04e34">NODIR</a>, 
<a class="el" href="classogdf_1_1_p_q_node_root.html#ad94cac0dfeca07ad5ad05f6e4fa3683fa67c1e4f626e32e68e01dbe04861adf54">LEFT</a>, 
<a class="el" href="classogdf_1_1_p_q_node_root.html#ad94cac0dfeca07ad5ad05f6e4fa3683fa0971613ceb4134386674cb230441c20e">RIGHT</a>
 }</td></tr>
<tr class="separator:ad94cac0dfeca07ad5ad05f6e4fa3683f inherit pub_types_classogdf_1_1_p_q_node_root"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class X, class Y&gt;<br />
class ogdf::PQNode&lt; T, X, Y &gt;</h3>

<p>The class template <a class="el" href="classogdf_1_1_p_q_basic_key.html">PQBasicKey</a> is an abstract base class. </p>
<p>It enables the user of the PQ-tree to store different informations at every node of the tree.</p>
<p>The implementation of the PQ-tree provides the storage of three different types of information.</p><ul>
<li>General information that is stored at P- and Q-nodes and leaves likewise (see also <a class="el" href="classogdf_1_1_p_q_node_key.html" title="The class template PQNodeKey is a derived class of class template PQBasicKey. ">PQNodeKey</a>).</li>
<li>Information that is only supported for internal nodes (see also internalKey).</li>
<li>The keys of the leaves (see also leafKey). The keys are constructed to carry the elements of a user defined set of any type, where permissible permutations have to be found. In order to use the datastructure PQ-tree as class template <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a>, the user has to specify a set of arbitrary elements that form the leaves of the PQ-tree. The keys function as storage class of the elements of the set.</li>
</ul>
<p>All three storage classes are derived class templates of <a class="el" href="classogdf_1_1_p_q_basic_key.html">PQBasicKey</a>. The class <a class="el" href="classogdf_1_1_p_q_basic_key.html">PQBasicKey</a> has a pointer <em>m_nodePointer</em> to a <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class. ">PQNode</a>, beeing either a leaf or an internal <a class="el" href="classogdf_1_1_p_q_internal_node.html" title="The class template PQInternalNode is used to present P-nodes and Q-nodes in the PQ-Tree. ">PQInternalNode</a>. The base class itself does not provide any storage of the informations, it is hidden in the derived classes. <a class="el" href="classogdf_1_1_p_q_basic_key.html">PQBasicKey</a> only declares a few pure virtual functions that are overloaded in the derived classes and which give access to the information stored in the derived classes.</p>
<p>The information stored in an element of a derived class of <a class="el" href="classogdf_1_1_p_q_basic_key.html">PQBasicKey</a> is assigned to a unique node in the PQ-tree. This unique node can be identified with the <em>m_nodePointer</em>. The maintenance of this pointer is left to the user in the derived concrete classes <a class="el" href="classogdf_1_1_p_q_node_key.html" title="The class template PQNodeKey is a derived class of class template PQBasicKey. ">PQNodeKey</a> and internalKey. By keeping the responsibillity for these classes by the client, nodes with certain informations can be accessed by the client in constant time. This makes the adaption of algorithms fast and easy.</p>
<p>Only the derived concrete class template leafKey is treated in a different way by the class template <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a>. When initializing the <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> with a set of elements of type leafKey, the class template <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> sets the pointer <em>m_nodePointer</em> of every element. This is due to the fact that a PQ-tree is always defined over some set, whose elements are stored in the leaves. Hence the class PQtree expects such a set and supports its maintainance. Storing extra information at every node may be omitted and makes the PQtree easy applicable.</p>
<p>We now give a short overview of the class template declaration <a class="el" href="classogdf_1_1_p_q_basic_key.html">PQBasicKey</a>. The class template <a class="el" href="classogdf_1_1_p_q_basic_key.html">PQBasicKey</a> is used as a base class template that specifies three different types of information. The type of information used at a node is depending on the type of the node. These informations have to be specified by the user.</p>
<p>The formal type parameters of the class template <a class="el" href="classogdf_1_1_p_q_basic_key.html">PQBasicKey</a> are categorized as follows.</p><ul>
<li><em>T</em> is a formal type parameter for the information stored in leafKey.</li>
<li><em>X</em> is a formal type parameter for the information stored in <a class="el" href="classogdf_1_1_p_q_node_key.html" title="The class template PQNodeKey is a derived class of class template PQBasicKey. ">PQNodeKey</a>.</li>
<li><em>Y</em> is a formal type parameter for the information stored in internalKey.</li>
</ul>
<p>The class template <a class="el" href="classogdf_1_1_p_q_basic_key.html">PQBasicKey</a> contains a few pure virtual member functions that are overloaded in the derived class leafKey, <a class="el" href="classogdf_1_1_p_q_node_key.html" title="The class template PQNodeKey is a derived class of class template PQBasicKey. ">PQNodeKey</a> and internalKey. These functions enable the client to access the information stored at a node. </p>

<p>Definition at line <a class="el" href="_p_q_basic_key_8h_source.html#l00113">113</a> of file <a class="el" href="_p_q_basic_key_8h_source.html">PQBasicKey.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a39cbddba87ff42153e84d9a5d4a9d980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39cbddba87ff42153e84d9a5d4a9d980">&sect;&nbsp;</a></span>PQNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node_key.html">PQNodeKey</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>infoPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The (first) constructor combines the node with its information and will automatically set the <em>m_nodePointer</em> (see basicKey) of the element of type <a class="el" href="classogdf_1_1_p_q_node_key.html" title="The class template PQNodeKey is a derived class of class template PQBasicKey. ">PQNodeKey</a>. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00577">577</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a29fa986b046f7b21d9c41021f0975505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29fa986b046f7b21d9c41021f0975505">&sect;&nbsp;</a></span>PQNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The (second) constructor is called, if no information is available or neccessary. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00608">608</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a72c18693d22239feefa072dfcba5282f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c18693d22239feefa072dfcba5282f">&sect;&nbsp;</a></span>~PQNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::~<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The destructor does not delete any accompanying information class as <a class="el" href="classogdf_1_1_p_q_leaf_key.html" title="The class template PQLeafKey is a derived class of class template PQBasicKey. ">PQLeafKey</a>, <a class="el" href="classogdf_1_1_p_q_node_key.html" title="The class template PQNodeKey is a derived class of class template PQBasicKey. ">PQNodeKey</a> and <a class="el" href="classogdf_1_1_p_q_internal_key.html" title="The class template PQInternalKey is a derived class of class template PQBasicKey. ...">PQInternalKey</a>. </p>
<p>This has been avoided, since applications may need the existence of these information classes after the corresponding node has been deleted. If the deletion of an accompanying information class should be performed with the deletion of a node, either derive a new class with an appropriate destructor, or make use of the function CleanNode() of the class template <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a>. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00091">91</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a76d9009ddaf0cb5c2b871a5d6a012b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d9009ddaf0cb5c2b871a5d6a012b17">&sect;&nbsp;</a></span>changeEndmost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::changeEndmost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>oldEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>newEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function <a class="el" href="classogdf_1_1_p_q_node.html#a76d9009ddaf0cb5c2b871a5d6a012b17" title="The function changeEndmost() replaces the old endmost child oldEnd of the node by a new child newEnd...">changeEndmost()</a> replaces the old endmost child <em>oldEnd</em> of the node by a new child <em>newEnd</em>. </p>
<p>If the node is a Q-node, then it must have two valid pointers to its endmost children. If one of the endmost children is <em>oldEnd</em>, it is replaced by <em>newEnd</em>. The function <a class="el" href="classogdf_1_1_p_q_node.html#a76d9009ddaf0cb5c2b871a5d6a012b17" title="The function changeEndmost() replaces the old endmost child oldEnd of the node by a new child newEnd...">changeEndmost()</a> returns 1 if it succeeded in replacing <em>oldEnd</em> by <em>newEnd</em>. Otherwise the function returns 0, leaving with an error message. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00527">527</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a22f5498d3d3d785afb03c08f2f560763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f5498d3d3d785afb03c08f2f560763">&sect;&nbsp;</a></span>changeSiblings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::changeSiblings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>oldSib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>newSib</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function <a class="el" href="classogdf_1_1_p_q_node.html#a22f5498d3d3d785afb03c08f2f560763" title="The function changeSiblings() replaces the old sibling oldSib of the node by a new sibling newSib...">changeSiblings()</a> replaces the old sibling <em>oldSib</em> of the node by a new sibling <em>newSib</em>. </p>
<p>If the node has <em>oldSib</em> as sibling, then it changes the sibling pointer that references to <em>oldSib</em> and places <em>newSib</em> at its position. The function <a class="el" href="classogdf_1_1_p_q_node.html#a22f5498d3d3d785afb03c08f2f560763" title="The function changeSiblings() replaces the old sibling oldSib of the node by a new sibling newSib...">changeSiblings()</a> returns 1 if it succeeded in replacing <em>oldSib</em> by <em>newSib</em>. Otherwise the function returns 0, leaving with an error message. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00555">555</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a67d45970a8a390bf0e153c2a12e11d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d45970a8a390bf0e153c2a12e11d57">&sect;&nbsp;</a></span>childCount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::childCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of children of a node. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00203">203</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a363dc83e6011b6118bc09eeeaed9d94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363dc83e6011b6118bc09eeeaed9d94b">&sect;&nbsp;</a></span>childCount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::childCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of children of a node. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00206">206</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="ab4f45a5c3c9a70e40d69907db86b78a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f45a5c3c9a70e40d69907db86b78a0">&sect;&nbsp;</a></span>endmostChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::endmostChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function <a class="el" href="classogdf_1_1_p_q_node.html#ab4f45a5c3c9a70e40d69907db86b78a0" title="The function endmostChild() checks if a node is endmost child of a Q-node. ">endmostChild()</a> checks if a node is endmost child of a Q-node. </p>
<p>This is 1 if one of the sibling pointers <em>m_sibLeft</em> or <em>m_sibRight</em> is 0. If the node is endmost child of a Q-node, then it has a valid parent pointer. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00127">127</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a029c3c7d21ec08b1eba4eff266c61c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029c3c7d21ec08b1eba4eff266c61c45">&sect;&nbsp;</a></span>getEndmost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::getEndmost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns one of the endmost children of node, if node is a Q-node. </p>
<p>The function <a class="el" href="classogdf_1_1_p_q_node.html#a029c3c7d21ec08b1eba4eff266c61c45" title="Returns one of the endmost children of node, if node is a Q-node. ">getEndmost()</a> accepts as input a pointer to a <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class. ">PQNode</a> stored in <em>other</em>. The returned endmost child is unequal to the one specified in <em>other</em>. In case that an arbitrary endmost child should be looked up, set <em>other</em> = 0. This makes the function <a class="el" href="classogdf_1_1_p_q_node.html#a029c3c7d21ec08b1eba4eff266c61c45" title="Returns one of the endmost children of node, if node is a Q-node. ">getEndmost()</a> return an arbitrary endmost child (it returns the left endmost child). </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00140">140</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="af547eecd69ce65d0f04e96cefd27a5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af547eecd69ce65d0f04e96cefd27a5c7">&sect;&nbsp;</a></span>getEndmost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::getEndmost </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>side</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns one of the endmost children of node, if node is a Q-node. </p>
<p>The function accepts an integer denoting a direction causing the function to return either the left or the endmost child. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00154">154</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="ae4f3b3ec9e44ae199f92731e1a2e974f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f3b3ec9e44ae199f92731e1a2e974f">&sect;&nbsp;</a></span>getInternal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classogdf_1_1_p_q_internal_key.html">PQInternalKey</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::getInternal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classogdf_1_1_p_q_node.html#ae4f3b3ec9e44ae199f92731e1a2e974f" title="getInternal() returns a pointer to the PQInternalKey information of a node, in case that the node is ...">getInternal()</a> returns a pointer to the <a class="el" href="classogdf_1_1_p_q_internal_key.html" title="The class template PQInternalKey is a derived class of class template PQBasicKey. ...">PQInternalKey</a> information of a node, in case that the node is supposed to have <a class="el" href="classogdf_1_1_p_q_internal_key.html" title="The class template PQInternalKey is a derived class of class template PQBasicKey. ...">PQInternalKey</a> information, such as elements of the derived class template <a class="el" href="classogdf_1_1_p_q_internal_node.html" title="The class template PQInternalNode is used to present P-nodes and Q-nodes in the PQ-Tree. ">PQInternalNode</a>. </p>
<p>The internal information is of type <a class="el" href="classogdf_1_1_p_q_internal_key.html" title="The class template PQInternalKey is a derived class of class template PQBasicKey. ...">PQInternalKey</a>. </p>

<p>Implemented in <a class="el" href="classogdf_1_1_p_q_internal_node.html#ac51348db6d4b1dbc15a3005b0e6ff3de">ogdf::PQInternalNode&lt; T, X, Y &gt;</a>, <a class="el" href="classogdf_1_1_p_q_leaf.html#abc3a892f19c7b6710cfe6c013b482f55">ogdf::PQLeaf&lt; T, X, Y &gt;</a>, and <a class="el" href="classogdf_1_1_embed_indicator.html#a49ed8de038460f32030beabf28813df5">ogdf::EmbedIndicator</a>.</p>

</div>
</div>
<a id="acdc12c8f7a8f0f6946d8b76e283cadb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc12c8f7a8f0f6946d8b76e283cadb7">&sect;&nbsp;</a></span>getKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::getKey </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classogdf_1_1_p_q_node.html#acdc12c8f7a8f0f6946d8b76e283cadb7" title="getKey() returns a pointer to the PQLeafKeyof a node, in case that the node is supposed to have a key...">getKey()</a> returns a pointer to the PQLeafKeyof a node, in case that the node is supposed to have a key, such as elements of the derived class template <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a>. </p>
<p>The key contains information and is of type <a class="el" href="classogdf_1_1_p_q_leaf_key.html" title="The class template PQLeafKey is a derived class of class template PQBasicKey. ">PQLeafKey</a>. </p>

<p>Implemented in <a class="el" href="classogdf_1_1_p_q_internal_node.html#ab50d7f769e2ec44230ed43d32d1165c8">ogdf::PQInternalNode&lt; T, X, Y &gt;</a>, <a class="el" href="classogdf_1_1_p_q_leaf.html#a3f69098f72e21f7026b7521b178d5423">ogdf::PQLeaf&lt; T, X, Y &gt;</a>, and <a class="el" href="classogdf_1_1_embed_indicator.html#ab6df8ae5326151d3983f1ff38d462500">ogdf::EmbedIndicator</a>.</p>

</div>
</div>
<a id="af88f64449f1fa6800b680c204b7dcc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88f64449f1fa6800b680c204b7dcc72">&sect;&nbsp;</a></span>getNextSib()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::getNextSib </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function <a class="el" href="classogdf_1_1_p_q_node.html#af88f64449f1fa6800b680c204b7dcc72" title="The function getNextSib() returns one of the siblings of the node. ">getNextSib()</a> returns one of the siblings of the node. </p>
<p>The function <a class="el" href="classogdf_1_1_p_q_node.html#af88f64449f1fa6800b680c204b7dcc72" title="The function getNextSib() returns one of the siblings of the node. ">getNextSib()</a> accepts as input a pointer to a <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class. ">PQNode</a> stored in <em>other</em>. The returned sibling is unequal to the one specified in <em>other</em>. In case that no sibling has been looked up before, set <em>other</em> = 0. This makes the function <a class="el" href="classogdf_1_1_p_q_node.html#af88f64449f1fa6800b680c204b7dcc72" title="The function getNextSib() returns one of the siblings of the node. ">getNextSib()</a> return an arbitrary sibling (it returns the left sibling). </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00189">189</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="af975df47fae28f8e8997286662517e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af975df47fae28f8e8997286662517e86">&sect;&nbsp;</a></span>getNodeInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node_key.html">PQNodeKey</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::getNodeInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the identification number of a node. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00164">164</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="af0f4876e6c8011bcafd37894f8210040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f4876e6c8011bcafd37894f8210040">&sect;&nbsp;</a></span>getSib()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::getSib </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>side</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function <a class="el" href="classogdf_1_1_p_q_node.html#af0f4876e6c8011bcafd37894f8210040" title="The function getSib() returns one of the siblings of the node. ">getSib()</a> returns one of the siblings of the node. </p>
<p>It accepts an integer denoting a dircetion causing the function to return either the left or the right sibling. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00171">171</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a74b1c94cc9eb5657cf21cdcef7b9abe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b1c94cc9eb5657cf21cdcef7b9abe6">&sect;&nbsp;</a></span>identificationNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::identificationNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the identification number of a node. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00200">200</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a8c96574f7d72280ef71cf300b349a00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c96574f7d72280ef71cf300b349a00b">&sect;&nbsp;</a></span>mark() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classogdf_1_1_p_q_node_root.html#a3f6cca0e865c4aedb9f96ec14a53f7ce">PQNodeMark</a> <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::mark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classogdf_1_1_p_q_node.html#a8c96574f7d72280ef71cf300b349a00b" title="mark() returns the variable m_mark in the derived class PQLeaf and PQInternalNode. ">mark()</a> returns the variable <em>m_mark</em> in the derived class <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a> and <a class="el" href="classogdf_1_1_p_q_internal_node.html" title="The class template PQInternalNode is used to present P-nodes and Q-nodes in the PQ-Tree. ">PQInternalNode</a>. </p>
<p>In a derived class this function has to return the designation used in the first pass of Booth and Luekers algorithm called Bubble(). A node then is either marked <em>BLOCKED</em>, <em>UNBLOCKED</em> or <em>QUEUED</em> (see <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class. ">PQNode</a>). </p>

<p>Implemented in <a class="el" href="classogdf_1_1_p_q_internal_node.html#a968ec34aecb5d73ab86de43ca2346847">ogdf::PQInternalNode&lt; T, X, Y &gt;</a>, <a class="el" href="classogdf_1_1_p_q_leaf.html#a9f27f9ed941dedc679a029f9babe6722">ogdf::PQLeaf&lt; T, X, Y &gt;</a>, and <a class="el" href="classogdf_1_1_embed_indicator.html#ab57360ab72628286efa0fbbbde9de1e5">ogdf::EmbedIndicator</a>.</p>

</div>
</div>
<a id="a00c36b8ac0b6e186efd3f50d2afe0ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c36b8ac0b6e186efd3f50d2afe0ed7">&sect;&nbsp;</a></span>mark() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node_root.html#a3f6cca0e865c4aedb9f96ec14a53f7ce">PQNodeMark</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classogdf_1_1_p_q_node.html#a8c96574f7d72280ef71cf300b349a00b" title="mark() returns the variable m_mark in the derived class PQLeaf and PQInternalNode. ">mark()</a> sets the variable <em>m_mark</em> in the derived class <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a> and <a class="el" href="classogdf_1_1_p_q_internal_node.html" title="The class template PQInternalNode is used to present P-nodes and Q-nodes in the PQ-Tree. ">PQInternalNode</a>. </p>

<p>Implemented in <a class="el" href="classogdf_1_1_p_q_internal_node.html#a079a07a02c25927852e084a4741db589">ogdf::PQInternalNode&lt; T, X, Y &gt;</a>, <a class="el" href="classogdf_1_1_p_q_leaf.html#a838d72ea52624f098aac398c1a2b2759">ogdf::PQLeaf&lt; T, X, Y &gt;</a>, and <a class="el" href="classogdf_1_1_embed_indicator.html#a80195b930b08b8ec6e16fc5af8bcea16">ogdf::EmbedIndicator</a>.</p>

</div>
</div>
<a id="ab99a57d8d29e7e44d58fc33a95bd53f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99a57d8d29e7e44d58fc33a95bd53f6">&sect;&nbsp;</a></span>parent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function <a class="el" href="classogdf_1_1_p_q_node.html#ab99a57d8d29e7e44d58fc33a95bd53f6" title="The function parent() returns a pointer to the parent of a node. ">parent()</a> returns a pointer to the parent of a node. </p>
<dl class="section warning"><dt>Warning</dt><dd>After reducing the PQ-tree, some nodes may not have valid parent pointers anymore. This is no fault, the datastructur was designed this way. See also Booth and Lueker. </dd></dl>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00215">215</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a19f130805d04651906535716125ac02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f130805d04651906535716125ac02a">&sect;&nbsp;</a></span>parent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::parent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>newParent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the parent pointer of a node. </p>
<p>This function is needed in more ellaborated algorithms implemented as derivation of the class template <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a>. Here, the parent pointer probably is always needed and therefore has to be set within special functions, used in a pre-run before applying the bubble Phase of the <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a>. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00224">224</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a2d3b11a4fea3164715a133f32b85c21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3b11a4fea3164715a133f32b85c21c">&sect;&nbsp;</a></span>parentType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::parentType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of the parent of a node. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00230">230</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a03dbec4671deec32cece75a0ca183b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03dbec4671deec32cece75a0ca183b19">&sect;&nbsp;</a></span>parentType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::parentType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newParentType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the type of the parent of a node. </p>
<p>This does not change the type of the parent! </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00236">236</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="ae35f5fc8193afda9148e5b07d86ad251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35f5fc8193afda9148e5b07d86ad251">&sect;&nbsp;</a></span>pertChildCount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::pertChildCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returs the number of pertinent children of a node. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00239">239</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a3b4609b5c8acb0188b6e6db27c120ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4609b5c8acb0188b6e6db27c120ec7">&sect;&nbsp;</a></span>pertChildCount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::pertChildCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of pertinent children of a node. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00242">242</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a47fa00837a810be41f4df3e8497c60f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fa00837a810be41f4df3e8497c60f4">&sect;&nbsp;</a></span>putSibling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node_root.html#ad94cac0dfeca07ad5ad05f6e4fa3683f">SibDirection</a> <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::putSibling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>newSib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default function <a class="el" href="classogdf_1_1_p_q_node.html#a47fa00837a810be41f4df3e8497c60f4" title="The default function putSibling() stores a new sibling at a free sibling pointer of the node...">putSibling()</a> stores a new sibling at a free sibling pointer of the node. </p>
<p>This is only possible, if the node has at most one sibling. The function then detects a non used sibling pointer and places <em>newSib</em> onto it. <a class="el" href="classogdf_1_1_p_q_node.html#a47fa00837a810be41f4df3e8497c60f4" title="The default function putSibling() stores a new sibling at a free sibling pointer of the node...">putSibling()</a> returns 0 if there have been two siblings detected, occupying the two possible pointers. In this case the new sibling <em>newSib</em> cannot be stored. If there was at a maximum one sibling stored, the function will place <em>newSib</em> on the free pointer and return either <em>LEFT</em> or <em>RIGHT</em>, depending wich pointer has been used.</p>
<p>This function will always scan the pointer to the left brother first. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00257">257</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="ae44cc9afe7ecd1ed6fbcb9013db44d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44cc9afe7ecd1ed6fbcb9013db44d15">&sect;&nbsp;</a></span>putSibling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node_root.html#ad94cac0dfeca07ad5ad05f6e4fa3683f">SibDirection</a> <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::putSibling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>newSib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>preference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function <a class="el" href="classogdf_1_1_p_q_node.html#a47fa00837a810be41f4df3e8497c60f4" title="The default function putSibling() stores a new sibling at a free sibling pointer of the node...">putSibling()</a> with preference stores a new sibling at a free sibling pointer of the node. </p>
<p>This is only possible, if the node has at most one sibling. The function then detects a non used sibling pointer and places <em>newSib</em> onto it. <a class="el" href="classogdf_1_1_p_q_node.html#a47fa00837a810be41f4df3e8497c60f4" title="The default function putSibling() stores a new sibling at a free sibling pointer of the node...">putSibling()</a> returns 0 if there have been two siblings detected, occupying the two possible pointers. In this case the new sibling <em>newSib</em> could not be stored. If there was at a maximum one sibling stored, the function will place <em>newSib</em> on the free pointer and return either <em>LEFT</em> or <em>RIGHT</em>, depending wich pointer has been used.</p>
<p>This function scans the brother first, which has been specified in the preference. If the preference has value <em>LEFT</em>, it scans the pointer to the left brother first. If the value is <em>RIGHT</em>, it scans the pointer to the right brother first. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00285">285</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a5dba1a623cdfa3a8febd437da965b578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dba1a623cdfa3a8febd437da965b578">&sect;&nbsp;</a></span>referenceChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::referenceChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the reference child if node is a P-node. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00304">304</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a395da524ee8e126f04942ec9ca160acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395da524ee8e126f04942ec9ca160acb">&sect;&nbsp;</a></span>referenceParent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::referenceParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pointer to the parent if node is a reference child. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00307">307</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a7a1260e5695ab1d215f2a4728357c306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1260e5695ab1d215f2a4728357c306">&sect;&nbsp;</a></span>setInternal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::setInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_internal_key.html">PQInternalKey</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>pointerToInternal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classogdf_1_1_p_q_internal_node.html#ae4be9435c38247cc56c4e7166c308cfb">ogdf::PQInternalNode&lt; T, X, Y &gt;</a>, <a class="el" href="classogdf_1_1_p_q_leaf.html#a80dbde79ad342a10f9899b15c99bb5b7">ogdf::PQLeaf&lt; T, X, Y &gt;</a>, and <a class="el" href="classogdf_1_1_embed_indicator.html#a7abaefae6cf7a515eb9b4032936233b7">ogdf::EmbedIndicator</a>.</p>

</div>
</div>
<a id="a5497f243a46c2f9614cb857c7db1c721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5497f243a46c2f9614cb857c7db1c721">&sect;&nbsp;</a></span>setKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::setKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>pointerToKey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a specified pointer variable in a derived class to the specified adress of <em>pointerToKey</em> that is of type <a class="el" href="classogdf_1_1_p_q_leaf_key.html" title="The class template PQLeafKey is a derived class of class template PQBasicKey. ">PQLeafKey</a>. </p>
<p>If a derived class, such as <a class="el" href="classogdf_1_1_p_q_internal_node.html" title="The class template PQInternalNode is used to present P-nodes and Q-nodes in the PQ-Tree. ">PQInternalNode</a>, is not supposed to store informations of type <a class="el" href="classogdf_1_1_p_q_leaf_key.html" title="The class template PQLeafKey is a derived class of class template PQBasicKey. ">PQLeafKey</a>, <a class="el" href="classogdf_1_1_p_q_node.html#a5497f243a46c2f9614cb857c7db1c721" title="Sets a specified pointer variable in a derived class to the specified adress of pointerToKey that is ...">setKey()</a> ignores the informations as long as <em>pointerToKey</em> = 0. The return value then is 1. In case that <em>pointerToKey</em> != 0, the return value is 0.</p>
<p>If a derived class, such as <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a> is supposed to store informations of type <a class="el" href="classogdf_1_1_p_q_leaf_key.html" title="The class template PQLeafKey is a derived class of class template PQBasicKey. ">PQLeafKey</a>, <em>pointerToKey</em> has to be instantiated by the client. The function <a class="el" href="classogdf_1_1_p_q_node.html#a5497f243a46c2f9614cb857c7db1c721" title="Sets a specified pointer variable in a derived class to the specified adress of pointerToKey that is ...">setKey()</a> does not instantiate the corresponding variable in the derived class. The return value is always 1 unless <em>pointerKey</em> was equal to 0. </p>

<p>Implemented in <a class="el" href="classogdf_1_1_p_q_internal_node.html#a6c130b79f5f051230fa7c36a33aa3187">ogdf::PQInternalNode&lt; T, X, Y &gt;</a>, <a class="el" href="classogdf_1_1_p_q_leaf.html#a8ca3fb461bf7a583b7c9d2a367ee993c">ogdf::PQLeaf&lt; T, X, Y &gt;</a>, and <a class="el" href="classogdf_1_1_embed_indicator.html#a176bab4a4a323e8f9b4159d30b95df2d">ogdf::EmbedIndicator</a>.</p>

</div>
</div>
<a id="a0d4b0aebe0be47ad0e6cfa799813b907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4b0aebe0be47ad0e6cfa799813b907">&sect;&nbsp;</a></span>setNodeInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::setNodeInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node_key.html">PQNodeKey</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>pointerToInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the pointer <em>m_pointerToInfo</em> to the specified adress of <em>pointerToInfo</em>. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00310">310</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a2f2b4162be77cd338344bd0506eef00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2b4162be77cd338344bd0506eef00b">&sect;&nbsp;</a></span>status() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1b">PQNodeStatus</a> <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the variable <em>m_status</em> in the derived class <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a> and <a class="el" href="classogdf_1_1_p_q_internal_node.html" title="The class template PQInternalNode is used to present P-nodes and Q-nodes in the PQ-Tree. ">PQInternalNode</a>. </p>
<p>Its objective is to manage status of a node in the PQ-tree. A status is any kind of information of the current situation in the frontier of a node (the frontier of a node are all descendant leaves of the node). A status is anything such as <em>EMPTY</em>, <em>FULL</em> or <em>PARTIAL</em> (see <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class. ">PQNode</a>). Since there might be more than those three possibilities, (e.g. in computing planar subgraphs this function probably has to be overloaded by the client. </p>

<p>Implemented in <a class="el" href="classogdf_1_1_p_q_internal_node.html#aebb284dbeedfd15699d4bcafcf27b2ad">ogdf::PQInternalNode&lt; T, X, Y &gt;</a>, <a class="el" href="classogdf_1_1_p_q_leaf.html#a4311a704a28963f74cdeb0b07701309b">ogdf::PQLeaf&lt; T, X, Y &gt;</a>, and <a class="el" href="classogdf_1_1_embed_indicator.html#a4319b549cb83efdf6442be9ed1f0e3c8">ogdf::EmbedIndicator</a>.</p>

</div>
</div>
<a id="a8ce14e4c77a6190f8ff29653c9ae6370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce14e4c77a6190f8ff29653c9ae6370">&sect;&nbsp;</a></span>status() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1b">PQNodeStatus</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the variable <em>m_status</em> in the derived class <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a> and <a class="el" href="classogdf_1_1_p_q_internal_node.html" title="The class template PQInternalNode is used to present P-nodes and Q-nodes in the PQ-Tree. ">PQInternalNode</a>. </p>

<p>Implemented in <a class="el" href="classogdf_1_1_p_q_internal_node.html#ac707e7bca53ab14772385513a89cbdf0">ogdf::PQInternalNode&lt; T, X, Y &gt;</a>, <a class="el" href="classogdf_1_1_p_q_leaf.html#a530fdfc21e1a69ac1a72dd56062b211d">ogdf::PQLeaf&lt; T, X, Y &gt;</a>, and <a class="el" href="classogdf_1_1_embed_indicator.html#ad05309723c4cdbdc4d1a0525068b6a43">ogdf::EmbedIndicator</a>.</p>

</div>
</div>
<a id="a01a36506d7789520a22f393a978e53a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a36506d7789520a22f393a978e53a8">&sect;&nbsp;</a></span>type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classogdf_1_1_p_q_node_root.html#a9e38dfed883dd0f643b1674e0dd25001">PQNodeType</a> <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the variable <em>m_type</em> in the derived class <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a> and <a class="el" href="classogdf_1_1_p_q_internal_node.html" title="The class template PQInternalNode is used to present P-nodes and Q-nodes in the PQ-Tree. ">PQInternalNode</a>. </p>
<p>Its objective it to manage the type of a node. node the current node is. The type of a node in the class template <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> is either <em>PNode</em>, <em>QNode</em> or <em>leaf</em> (see <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class. ">PQNode</a>). There may be of course more types such as <em>sequence indicators</em>.</p>
<p>Observe that the derived class template <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a> does not have a variable <em>m_type</em>, since it obviously is of type <em>leaf</em>. </p>

<p>Implemented in <a class="el" href="classogdf_1_1_p_q_internal_node.html#a8000b3b76feddd0e5fcddd967acf945c">ogdf::PQInternalNode&lt; T, X, Y &gt;</a>, <a class="el" href="classogdf_1_1_p_q_leaf.html#a14a47eb39a06073dfd1936b0303cf258">ogdf::PQLeaf&lt; T, X, Y &gt;</a>, and <a class="el" href="classogdf_1_1_embed_indicator.html#a748548f9c298d3b5af983042ac0538fb">ogdf::EmbedIndicator</a>.</p>

</div>
</div>
<a id="af2d8e4b08ca02b7e468bc14dd5c206b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d8e4b08ca02b7e468bc14dd5c206b3">&sect;&nbsp;</a></span>type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node_root.html#a9e38dfed883dd0f643b1674e0dd25001">PQNodeType</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the variable <em>m_type</em> in the derived class <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a> and <a class="el" href="classogdf_1_1_p_q_internal_node.html" title="The class template PQInternalNode is used to present P-nodes and Q-nodes in the PQ-Tree. ">PQInternalNode</a>. </p>

<p>Implemented in <a class="el" href="classogdf_1_1_p_q_internal_node.html#a62804a1138b487d1dd80c217f3ecaeb6">ogdf::PQInternalNode&lt; T, X, Y &gt;</a>, <a class="el" href="classogdf_1_1_p_q_leaf.html#ac7e4d69e00423f2403f961fb643d5a47">ogdf::PQLeaf&lt; T, X, Y &gt;</a>, and <a class="el" href="classogdf_1_1_embed_indicator.html#a733f2ec236b2880324014d1888a0346a">ogdf::EmbedIndicator</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac28a1590a36def6225276a4ead9f31ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28a1590a36def6225276a4ead9f31ac">&sect;&nbsp;</a></span>PQTree< T, X, Y ></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a>&lt; T, X, Y &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All members and member function of <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class. ">PQNode</a> are needed by the class template <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a>. </p>
<p>Therefore the class <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> was made friendof <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class. ">PQNode</a>, since this prevents the use of a large amount of extra public functions. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00064">64</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4a0687a8595f0b2448fb67280a5a42ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0687a8595f0b2448fb67280a5a42ed">&sect;&nbsp;</a></span>fullChildren</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_list.html">List</a>&lt;<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;*&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::fullChildren</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores all full children of a node during a reduction. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00508">508</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="ae0e1bcbb0204589af448f527717c48bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e1bcbb0204589af448f527717c48bf">&sect;&nbsp;</a></span>m_childCount</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::m_childCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00422">422</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="adf45e0f730d58607ee852398fd7f72cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf45e0f730d58607ee852398fd7f72cb">&sect;&nbsp;</a></span>m_debugTreeNumber</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::m_debugTreeNumber</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Needed for debuging purposes. </p>
<p>The PQ-trees can be visualized with the help of the <em>Tree Interface</em> and the <em>m_debugTreeNumber</em> is needed to print out the tree in the correct file format. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00430">430</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="af017da96d4c263c58def1edd8c93525c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af017da96d4c263c58def1edd8c93525c">&sect;&nbsp;</a></span>m_firstFull</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::m_firstFull</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a pointer to the first full child of a Q-node. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00455">455</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a56c296ee3ca6e82dea4830074d3f75f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c296ee3ca6e82dea4830074d3f75f7">&sect;&nbsp;</a></span>m_identificationNumber</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::m_identificationNumber</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Each node that has been introduced once into the tree gets a unique number. </p>
<p>If the node is removed from the tree during a reduction or with the help of one of the functions that is provided by the class template PQtree, its number <b>is not reused</b>. This always allows exact identification of nodes during any process that is envoked on the PQ-tree. We strongly recommend users who construct the tree with the help of the construction functions and who instantiate the nodes by them selves to do the same. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00443">443</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a3c3ff35b814d92631b7b1a5daa8bced2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3ff35b814d92631b7b1a5daa8bced2">&sect;&nbsp;</a></span>m_leftEndmost</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::m_leftEndmost</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00457">457</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="acb7e212917f68c4cf3eef1a527ba3a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7e212917f68c4cf3eef1a527ba3a25">&sect;&nbsp;</a></span>m_parent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::m_parent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a pointer to the parent. </p>
<p>Observe that this pointer may not be up to date after a few applications of the reduction. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00464">464</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a7a3cabd03f116b2c69494ec5cbd43823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3cabd03f116b2c69494ec5cbd43823">&sect;&nbsp;</a></span>m_parentType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::m_parentType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the type of the parent which can be either a P- or Q-node. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00446">446</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="adc0670ff54dcd643dc826952472424d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0670ff54dcd643dc826952472424d8">&sect;&nbsp;</a></span>m_pertChildCount</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::m_pertChildCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the number of pertinent children of the node. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00449">449</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a974523bca1e8be35e1e8888605f3d414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974523bca1e8be35e1e8888605f3d414">&sect;&nbsp;</a></span>m_pertLeafCount</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::m_pertLeafCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the number of pertinent leaves in the frontier of the node. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00452">452</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="ad4de340841f0ecf711c2426d5368b5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4de340841f0ecf711c2426d5368b5b1">&sect;&nbsp;</a></span>m_pointerToInfo</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node_key.html">PQNodeKey</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::m_pointerToInfo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a pointer to the corresponding information of the node. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00504">504</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="ab247e890ed429c16f89d2c77dea562ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab247e890ed429c16f89d2c77dea562ee">&sect;&nbsp;</a></span>m_referenceChild</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::m_referenceChild</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a pointer to one child, the <b>reference child</b> of the doubly linked cirkular list of children of a P-node. </p>
<p>With the help of this pointer, it is possible to access the children of the P-node </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00472">472</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a10e90eb25ef0429cbc6ea6329da24f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e90eb25ef0429cbc6ea6329da24f19">&sect;&nbsp;</a></span>m_referenceParent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::m_referenceParent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a pointer to the parent, in case that the parent is a P-node and the node itself is its reference child. </p>
<p>The pointer is needed in order to identify the reference child among all children of a P-node. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00480">480</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a848ce9c9f081b9d176d9236c95655eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848ce9c9f081b9d176d9236c95655eee">&sect;&nbsp;</a></span>m_rightEndmost</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::m_rightEndmost</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the right endmost child of a Q-node. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00483">483</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a13313d82be207c516c7c785271cf20a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13313d82be207c516c7c785271cf20a9">&sect;&nbsp;</a></span>m_sibLeft</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::m_sibLeft</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a pointer ot the left sibling of <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class. ">PQNode</a>. </p>
<p>If <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class. ">PQNode</a> is child of a Q-node and has no left sibling, <em>m_sibLeft</em> is set to 0. If <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class. ">PQNode</a> is child of a P-node, all children of the P-node are linked in a cirkular list. In the latter case, <em>m_sibLeft</em> is never 0. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00492">492</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a315449d038a4d9560a8c7431b87237e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315449d038a4d9560a8c7431b87237e6">&sect;&nbsp;</a></span>m_sibRight</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::m_sibRight</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a pointer ot the right sibling of <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class. ">PQNode</a>. </p>
<p>If <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class. ">PQNode</a> is child of a Q-node and has no right sibling, \ m_sibRight is set to 0. If <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class. ">PQNode</a> is child of a P-node, all children of the P-node are linked in a cirkular list. In the latter case, <em>m_sibRight</em> is never 0. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00501">501</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<a id="a596ba8dfb7d7f070518b3daaaa1202d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596ba8dfb7d7f070518b3daaaa1202d7">&sect;&nbsp;</a></span>partialChildren</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_list.html">List</a>&lt;<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;*&gt;* <a class="el" href="classogdf_1_1_p_q_node.html">ogdf::PQNode</a>&lt; T, X, Y &gt;::partialChildren</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores all partial children of a node during a reduction. </p>

<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00511">511</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/ogdf/internal/planarity/<a class="el" href="_p_q_basic_key_8h_source.html">PQBasicKey.h</a></li>
<li>include/ogdf/internal/planarity/<a class="el" href="_p_q_node_8h_source.html">PQNode.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceogdf.html">ogdf</a></li><li class="navelem"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a></li>
    <li class="footer">&copy; 1999&ndash;2015 <a href="http://ogdf.net/doku.php/team:about">The OGDF Team</a></li>
  </ul>
</div>
</body>
</html>
