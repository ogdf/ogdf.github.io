<!-- HTML header for doxygen 1.8.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>ogdf: ogdf::PQTree&lt; T, X, Y &gt; Class Template Reference</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogdf-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
  <td>
   <table border="0" cellspacing="0" cellpadding="0">
    <tr>
     <td width="90"><a href="http://www.ogdf.net/" title="Go to www.ogdf.net"><img style="padding: 0 .5em; border-width: 0px" src="ogdf-logo.png"/></a></td>
     <td align="left"><h1 class="ogdftitle">Open<br>Graph Drawing<br>Framework</h1></td>
     <td align="left" valign="bottom" >
      <span style="font-size:110%; color:rgb(56,95,118)">&nbsp;v. 2022.02 (Dogwood)</span><br>&nbsp;
     </td>
    </tr>
   </table>
  </td>
 </tr>
 <tr>
  <td valign="bottom">
   <div class="menubox">
    <table border="0" cellpadding="0" cellspacing="0" class="menutable">
     <tr>
      <td><a class="menu" href="index.html" title="Start page with overview">Overview</a></td>
      <td><a class="menu" href="hierarchy.html" title="Inheritance hierarchies">Class&nbsp;Hierarchy</a></td>
      <td><a class="menu" href="classes.html" title="Alphabetical list of classes">Class&nbsp;Index</a></td>
      <td><a class="menu" href="annotated.html" title="Classes with brief descriptions">Class&nbsp;List</a></td>
      <td><a class="menu" href="functions.html" title="Complete list of member functions, enumerations, and variables">Members</a></td>
      <td><a class="menu" href="namespaces.html" title="Namespaces with brief descriptions">Namespaces</a></td>
      <td><a class="menu" href="files.html" title="Complete list of files with brief descriptions">Source&nbsp;Files</a></td>
      <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
     </tr>
    </table>
   </div><br>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classogdf_1_1_p_q_tree.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classogdf_1_1_p_q_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ogdf::PQTree&lt; T, X, Y &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_p_q_node_8h_source.html">ogdf/basic/pqtree/PQNode.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a06a066a75771df90f15ce2e0158bc031"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a06a066a75771df90f15ce2e0158bc031">PQTree</a> ()</td></tr>
<tr class="separator:a06a066a75771df90f15ce2e0158bc031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3800a1ed72a5297db2ab308e17c825a9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a3800a1ed72a5297db2ab308e17c825a9">~PQTree</a> ()</td></tr>
<tr class="memdesc:a3800a1ed72a5297db2ab308e17c825a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classogdf_1_1_p_q_tree.html#a3800a1ed72a5297db2ab308e17c825a9">More...</a><br /></td></tr>
<tr class="separator:a3800a1ed72a5297db2ab308e17c825a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6ceec35587bfc0b421a9984538b373"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#ade6ceec35587bfc0b421a9984538b373">addNewLeavesToTree</a> (<a class="el" href="classogdf_1_1_p_q_internal_node.html">PQInternalNode</a>&lt; T, X, Y &gt; *father, <a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; * &gt; &amp;leafKeys)</td></tr>
<tr class="memdesc:ade6ceec35587bfc0b421a9984538b373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a set of elements to the already existing set of elements of a PQ-tree.  <a href="classogdf_1_1_p_q_tree.html#ade6ceec35587bfc0b421a9984538b373">More...</a><br /></td></tr>
<tr class="separator:ade6ceec35587bfc0b421a9984538b373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52db9d9ca5b62ec0a3edbe171624d6e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#ab52db9d9ca5b62ec0a3edbe171624d6e">CleanNode</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *)</td></tr>
<tr class="separator:ab52db9d9ca5b62ec0a3edbe171624d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f30510581fac9c24be3fce6b0b4b82d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a4f30510581fac9c24be3fce6b0b4b82d">Cleanup</a> ()</td></tr>
<tr class="memdesc:a4f30510581fac9c24be3fce6b0b4b82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the entire PQ-tree.  <a href="classogdf_1_1_p_q_tree.html#a4f30510581fac9c24be3fce6b0b4b82d">More...</a><br /></td></tr>
<tr class="separator:a4f30510581fac9c24be3fce6b0b4b82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3622dd2eb4a98178f63f13a6d452fb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#aad3622dd2eb4a98178f63f13a6d452fb">clientDefinedEmptyNode</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="memdesc:aad3622dd2eb4a98178f63f13a6d452fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the user wishes to use different flags in a derived class of <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> that are not available in this implementation, he can overload this function to make a valid cleanup of the nodes.  <a href="classogdf_1_1_p_q_tree.html#aad3622dd2eb4a98178f63f13a6d452fb">More...</a><br /></td></tr>
<tr class="separator:aad3622dd2eb4a98178f63f13a6d452fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cca4fcb55736c826a9ddd5802302c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a88cca4fcb55736c826a9ddd5802302c8">emptyAllPertinentNodes</a> ()</td></tr>
<tr class="memdesc:a88cca4fcb55736c826a9ddd5802302c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up all flags that have been set in the pertinent nodes during the reduction process.  <a href="classogdf_1_1_p_q_tree.html#a88cca4fcb55736c826a9ddd5802302c8">More...</a><br /></td></tr>
<tr class="separator:a88cca4fcb55736c826a9ddd5802302c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76af348fc7bc262e6f229f06d936cfaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a76af348fc7bc262e6f229f06d936cfaf">emptyNode</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="memdesc:a76af348fc7bc262e6f229f06d936cfaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up all stacks, flags and pointers of a pertinent node that has been visited during the reduction process.  <a href="classogdf_1_1_p_q_tree.html#a76af348fc7bc262e6f229f06d936cfaf">More...</a><br /></td></tr>
<tr class="separator:a76af348fc7bc262e6f229f06d936cfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace84522b54600068c37a1df5d542f34a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#ace84522b54600068c37a1df5d542f34a">front</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr, <a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; * &gt; &amp;leafKeys)</td></tr>
<tr class="memdesc:ace84522b54600068c37a1df5d542f34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the keys stored in the leaves of the front of <code>nodePtr</code>.  <a href="classogdf_1_1_p_q_tree.html#ace84522b54600068c37a1df5d542f34a">More...</a><br /></td></tr>
<tr class="separator:ace84522b54600068c37a1df5d542f34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0962923f0af759f5c4552a67b2927b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#acb0962923f0af759f5c4552a67b2927b">Initialize</a> (<a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; * &gt; &amp;leafKeys)</td></tr>
<tr class="memdesc:acb0962923f0af759f5c4552a67b2927b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the PQ-tree with a set of elements.  <a href="classogdf_1_1_p_q_tree.html#acb0962923f0af759f5c4552a67b2927b">More...</a><br /></td></tr>
<tr class="separator:acb0962923f0af759f5c4552a67b2927b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39ae8ac138b95635a4db2f57898b94d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#ac39ae8ac138b95635a4db2f57898b94d">Reduction</a> (<a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; * &gt; &amp;leafKeys)</td></tr>
<tr class="memdesc:ac39ae8ac138b95635a4db2f57898b94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether permissible permutations of the elements of U exist such that the elements of a subset S of U, stored in <code>leafKeys</code>, form a consecutive sequence.  <a href="classogdf_1_1_p_q_tree.html#ac39ae8ac138b95635a4db2f57898b94d">More...</a><br /></td></tr>
<tr class="separator:ac39ae8ac138b95635a4db2f57898b94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e347a727d31d264246a0a51e2a82af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a03e347a727d31d264246a0a51e2a82af">root</a> () const</td></tr>
<tr class="memdesc:a03e347a727d31d264246a0a51e2a82af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer of the root node of the <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a>.  <a href="classogdf_1_1_p_q_tree.html#a03e347a727d31d264246a0a51e2a82af">More...</a><br /></td></tr>
<tr class="separator:a03e347a727d31d264246a0a51e2a82af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5b7764739dfcfc6d7c956870ccdf0230"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a5b7764739dfcfc6d7c956870ccdf0230">writeGML</a> (const char *fileName)</td></tr>
<tr class="memdesc:a5b7764739dfcfc6d7c956870ccdf0230"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function <a class="el" href="classogdf_1_1_p_q_tree.html#a5b7764739dfcfc6d7c956870ccdf0230" title="The function writeGML() prints the PQ-tree in the GML fileformat.">writeGML()</a> prints the PQ-tree in the GML fileformat.  <a href="classogdf_1_1_p_q_tree.html#a5b7764739dfcfc6d7c956870ccdf0230">More...</a><br /></td></tr>
<tr class="separator:a5b7764739dfcfc6d7c956870ccdf0230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98046ca03115c5b2241564f02bf2c257"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a98046ca03115c5b2241564f02bf2c257">writeGML</a> (std::ostream &amp;os)</td></tr>
<tr class="separator:a98046ca03115c5b2241564f02bf2c257"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a78fa49ce4ad7cb1f0d5d31919d34a4bc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a78fa49ce4ad7cb1f0d5d31919d34a4bc">addNodeToNewParent</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *parent, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *child)</td></tr>
<tr class="memdesc:a78fa49ce4ad7cb1f0d5d31919d34a4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node <code>child</code> as a child to another node specified in <code>parent</code>.  <a href="classogdf_1_1_p_q_tree.html#a78fa49ce4ad7cb1f0d5d31919d34a4bc">More...</a><br /></td></tr>
<tr class="separator:a78fa49ce4ad7cb1f0d5d31919d34a4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bf5f7e4ecfd0d7a1a28557c0b5d328"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a46bf5f7e4ecfd0d7a1a28557c0b5d328">addNodeToNewParent</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *parent, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *child, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *leftBrother, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *rightBrother)</td></tr>
<tr class="memdesc:a46bf5f7e4ecfd0d7a1a28557c0b5d328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node <code>child</code> to the children of another node specified in <code>parent</code>.  <a href="classogdf_1_1_p_q_tree.html#a46bf5f7e4ecfd0d7a1a28557c0b5d328">More...</a><br /></td></tr>
<tr class="separator:a46bf5f7e4ecfd0d7a1a28557c0b5d328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe0fa141e29868c08b60250ad53788e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#aebe0fa141e29868c08b60250ad53788e">Bubble</a> (<a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; * &gt; &amp;leafKeys)</td></tr>
<tr class="memdesc:aebe0fa141e29868c08b60250ad53788e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Realizes a function described in [Booth].  <a href="classogdf_1_1_p_q_tree.html#aebe0fa141e29868c08b60250ad53788e">More...</a><br /></td></tr>
<tr class="separator:aebe0fa141e29868c08b60250ad53788e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a0040240c4da107e76844e86fe5954"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a70a0040240c4da107e76844e86fe5954">checkIfOnlyChild</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *child, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *parent)</td></tr>
<tr class="memdesc:a70a0040240c4da107e76844e86fe5954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>child</code> is the only child of <code>parent</code>.  <a href="classogdf_1_1_p_q_tree.html#a70a0040240c4da107e76844e86fe5954">More...</a><br /></td></tr>
<tr class="separator:a70a0040240c4da107e76844e86fe5954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4692a762c6c42cac7c1f026954c348"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a2d4692a762c6c42cac7c1f026954c348">clientLeftEndmost</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr) const</td></tr>
<tr class="separator:a2d4692a762c6c42cac7c1f026954c348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea906aa316225fa43a62408393ed718"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a7ea906aa316225fa43a62408393ed718">clientNextSib</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *other) const</td></tr>
<tr class="separator:a7ea906aa316225fa43a62408393ed718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab9b850b03485163d66e9ead0b8e70a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a9ab9b850b03485163d66e9ead0b8e70a">clientPrintNodeCategorie</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="memdesc:a9ab9b850b03485163d66e9ead0b8e70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the user wishes to use different flags in a derived class of <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> that are not available in this implementation, he can overload this function.  <a href="classogdf_1_1_p_q_tree.html#a9ab9b850b03485163d66e9ead0b8e70a">More...</a><br /></td></tr>
<tr class="separator:a9ab9b850b03485163d66e9ead0b8e70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110ddd73ab4993d6fb59404126a93711"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a110ddd73ab4993d6fb59404126a93711">clientPrintStatus</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="memdesc:a110ddd73ab4993d6fb59404126a93711"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the user wishes to use different status in a derived class of <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> that are not available in this implementation, he can overload this function.  <a href="classogdf_1_1_p_q_tree.html#a110ddd73ab4993d6fb59404126a93711">More...</a><br /></td></tr>
<tr class="separator:a110ddd73ab4993d6fb59404126a93711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8083c97003857dabab2acd6b5fbab8"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a0e8083c97003857dabab2acd6b5fbab8">clientPrintType</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="memdesc:a0e8083c97003857dabab2acd6b5fbab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the user wishes to use different types in a derived class of <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> that are not available in this implementation, he can overload this function.  <a href="classogdf_1_1_p_q_tree.html#a0e8083c97003857dabab2acd6b5fbab8">More...</a><br /></td></tr>
<tr class="separator:a0e8083c97003857dabab2acd6b5fbab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da1c0609a58a901350bd4c8f847ee47"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a3da1c0609a58a901350bd4c8f847ee47">clientRightEndmost</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr) const</td></tr>
<tr class="separator:a3da1c0609a58a901350bd4c8f847ee47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a83bf0154c5bb150834ad8a60bc2719"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a8a83bf0154c5bb150834ad8a60bc2719">clientSibLeft</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr) const</td></tr>
<tr class="separator:a8a83bf0154c5bb150834ad8a60bc2719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef18d897994c45d983280421467ccef"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a0ef18d897994c45d983280421467ccef">clientSibRight</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr) const</td></tr>
<tr class="separator:a0ef18d897994c45d983280421467ccef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162069c126ebf888585fb39fa833c65c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a162069c126ebf888585fb39fa833c65c">destroyNode</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="memdesc:a162069c126ebf888585fb39fa833c65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a node as <a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1bac6a36c1a9004ff0b1a6033b19d2c131d">PQNodeRoot::PQNodeStatus::ToBeDeleted</a>.  <a href="classogdf_1_1_p_q_tree.html#a162069c126ebf888585fb39fa833c65c">More...</a><br /></td></tr>
<tr class="separator:a162069c126ebf888585fb39fa833c65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cce16d012eb159eb8dc191d17e9aa6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a59cce16d012eb159eb8dc191d17e9aa6">exchangeNodes</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *oldNode, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *newNode)</td></tr>
<tr class="memdesc:a59cce16d012eb159eb8dc191d17e9aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the <code>oldNode</code> by the <code>newNode</code> in the tree.  <a href="classogdf_1_1_p_q_tree.html#a59cce16d012eb159eb8dc191d17e9aa6">More...</a><br /></td></tr>
<tr class="separator:a59cce16d012eb159eb8dc191d17e9aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1920edd68529b710da2775359803d54a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_list.html">List</a>&lt; <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a1920edd68529b710da2775359803d54a">fullChildren</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="separator:a1920edd68529b710da2775359803d54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af746642d3e338f1fa13198dd58c68158"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#af746642d3e338f1fa13198dd58c68158">linkChildrenOfQnode</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *installed, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *newChild)</td></tr>
<tr class="memdesc:af746642d3e338f1fa13198dd58c68158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links the two endmost children of two <b>different</b> Q-nodes via their sibling pointers together.  <a href="classogdf_1_1_p_q_tree.html#af746642d3e338f1fa13198dd58c68158">More...</a><br /></td></tr>
<tr class="separator:af746642d3e338f1fa13198dd58c68158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111287c97892d05b1a31f9fa4b5e2ec4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_list.html">List</a>&lt; <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a111287c97892d05b1a31f9fa4b5e2ec4">partialChildren</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="separator:a111287c97892d05b1a31f9fa4b5e2ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3235c9bd712835664f1dc8373f27276f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a3235c9bd712835664f1dc8373f27276f">Reduce</a> (<a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; * &gt; &amp;leafKeys)</td></tr>
<tr class="memdesc:a3235c9bd712835664f1dc8373f27276f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the reduction of the pertinent leaves with the help of the template matchings, designed by Booth and Lueker.  <a href="classogdf_1_1_p_q_tree.html#a3235c9bd712835664f1dc8373f27276f">More...</a><br /></td></tr>
<tr class="separator:a3235c9bd712835664f1dc8373f27276f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9eb0c1fe76d998f4b2906b4af3a1c9f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#ab9eb0c1fe76d998f4b2906b4af3a1c9f">removeChildFromSiblings</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="memdesc:ab9eb0c1fe76d998f4b2906b4af3a1c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the node <code>nodePtr</code> from the doubly linked list of its parent.  <a href="classogdf_1_1_p_q_tree.html#ab9eb0c1fe76d998f4b2906b4af3a1c9f">More...</a><br /></td></tr>
<tr class="separator:ab9eb0c1fe76d998f4b2906b4af3a1c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e55e4addaa7de1ffb6e6332fd087892"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a9e55e4addaa7de1ffb6e6332fd087892">removeNodeFromTree</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *parent, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *child)</td></tr>
<tr class="memdesc:a9e55e4addaa7de1ffb6e6332fd087892"><td class="mdescLeft">&#160;</td><td class="mdescRight">The objective is to remove a node <code>child</code> from the PQ-tree.  <a href="classogdf_1_1_p_q_tree.html#a9e55e4addaa7de1ffb6e6332fd087892">More...</a><br /></td></tr>
<tr class="separator:a9e55e4addaa7de1ffb6e6332fd087892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230967681d50f958a8f1318f15e70638"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a230967681d50f958a8f1318f15e70638">templateL1</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr, bool isRoot)</td></tr>
<tr class="memdesc:a230967681d50f958a8f1318f15e70638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template matching for leaves.  <a href="classogdf_1_1_p_q_tree.html#a230967681d50f958a8f1318f15e70638">More...</a><br /></td></tr>
<tr class="separator:a230967681d50f958a8f1318f15e70638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1d21d208da1a620292ff92a101dcf8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a2a1d21d208da1a620292ff92a101dcf8">templateP1</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr, bool isRoot)</td></tr>
<tr class="memdesc:a2a1d21d208da1a620292ff92a101dcf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template matching for P-nodes with only full children.  <a href="classogdf_1_1_p_q_tree.html#a2a1d21d208da1a620292ff92a101dcf8">More...</a><br /></td></tr>
<tr class="separator:a2a1d21d208da1a620292ff92a101dcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4660c9511e753585cc5f77106de61e7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#ac4660c9511e753585cc5f77106de61e7">templateP2</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **nodePtr)</td></tr>
<tr class="memdesc:ac4660c9511e753585cc5f77106de61e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template matching for a P-node with full <b>and</b> empty children that is the root of the pertinent subtree.  <a href="classogdf_1_1_p_q_tree.html#ac4660c9511e753585cc5f77106de61e7">More...</a><br /></td></tr>
<tr class="separator:ac4660c9511e753585cc5f77106de61e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9b472f8e7c6bd35d2741850c7bcaac"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a9b9b472f8e7c6bd35d2741850c7bcaac">templateP3</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="memdesc:a9b9b472f8e7c6bd35d2741850c7bcaac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template matching for a P-node with full <b>and</b> empty children that is <b>not</b> the root of the pertinent subtree.  <a href="classogdf_1_1_p_q_tree.html#a9b9b472f8e7c6bd35d2741850c7bcaac">More...</a><br /></td></tr>
<tr class="separator:a9b9b472f8e7c6bd35d2741850c7bcaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ac709fa37043f44cbd15386d85b520"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a08ac709fa37043f44cbd15386d85b520">templateP4</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **nodePtr)</td></tr>
<tr class="memdesc:a08ac709fa37043f44cbd15386d85b520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template matching for a P-node with full, empty and exactly one partial children.  <a href="classogdf_1_1_p_q_tree.html#a08ac709fa37043f44cbd15386d85b520">More...</a><br /></td></tr>
<tr class="separator:a08ac709fa37043f44cbd15386d85b520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dc0201fbefa391f83c3d7d28414530"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a59dc0201fbefa391f83c3d7d28414530">templateP5</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="memdesc:a59dc0201fbefa391f83c3d7d28414530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template matching for a P-node with full, empty children and exactly one partial child.  <a href="classogdf_1_1_p_q_tree.html#a59dc0201fbefa391f83c3d7d28414530">More...</a><br /></td></tr>
<tr class="separator:a59dc0201fbefa391f83c3d7d28414530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c29c90e12637a2c1a91a59f67c9c74"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a21c29c90e12637a2c1a91a59f67c9c74">templateP6</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **nodePtr)</td></tr>
<tr class="memdesc:a21c29c90e12637a2c1a91a59f67c9c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template matching for a P-node with full, empty and exactly two partial children.  <a href="classogdf_1_1_p_q_tree.html#a21c29c90e12637a2c1a91a59f67c9c74">More...</a><br /></td></tr>
<tr class="separator:a21c29c90e12637a2c1a91a59f67c9c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206e9453307cee62d87b915b3f33c036"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a206e9453307cee62d87b915b3f33c036">templateQ1</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr, bool isRoot)</td></tr>
<tr class="memdesc:a206e9453307cee62d87b915b3f33c036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template matching for Q-nodes with only full children.  <a href="classogdf_1_1_p_q_tree.html#a206e9453307cee62d87b915b3f33c036">More...</a><br /></td></tr>
<tr class="separator:a206e9453307cee62d87b915b3f33c036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6839d25d0a5e27cd24f2f3da604b7169"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169">templateQ2</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr, bool isRoot)</td></tr>
<tr class="memdesc:a6839d25d0a5e27cd24f2f3da604b7169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template matching for Q-nodes with a pertinent sequence of children on one side of the Q-node.  <a href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169">More...</a><br /></td></tr>
<tr class="separator:a6839d25d0a5e27cd24f2f3da604b7169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd5607fec9aaf74d58fb53ddb9883a7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#aefd5607fec9aaf74d58fb53ddb9883a7">templateQ3</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="separator:aefd5607fec9aaf74d58fb53ddb9883a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a75ed08b07f23d14328a91a7ba8bacc7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a75ed08b07f23d14328a91a7ba8bacc7a">m_identificationNumber</a></td></tr>
<tr class="memdesc:a75ed08b07f23d14328a91a7ba8bacc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the total number of nodes that have been allocated.  <a href="classogdf_1_1_p_q_tree.html#a75ed08b07f23d14328a91a7ba8bacc7a">More...</a><br /></td></tr>
<tr class="separator:a75ed08b07f23d14328a91a7ba8bacc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f6f339ca2536e8dd9ebc15a5af8a2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#aa1f6f339ca2536e8dd9ebc15a5af8a2c">m_numberOfLeaves</a></td></tr>
<tr class="memdesc:aa1f6f339ca2536e8dd9ebc15a5af8a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the number of leaves.  <a href="classogdf_1_1_p_q_tree.html#aa1f6f339ca2536e8dd9ebc15a5af8a2c">More...</a><br /></td></tr>
<tr class="separator:aa1f6f339ca2536e8dd9ebc15a5af8a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1a39850b4f51707c6b4609dd45f106"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_list.html">List</a>&lt; <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a0a1a39850b4f51707c6b4609dd45f106">m_pertinentNodes</a></td></tr>
<tr class="memdesc:a0a1a39850b4f51707c6b4609dd45f106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores all nodes that have been marked <a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1babbd47109890259c0127154db1af26c75">PQNodeRoot::PQNodeStatus::Full</a> or <a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1ba44ffd38a6dea695cbe2b34efdcc6cf27">PQNodeRoot::PQNodeStatus::Partial</a> during a reduction.  <a href="classogdf_1_1_p_q_tree.html#a0a1a39850b4f51707c6b4609dd45f106">More...</a><br /></td></tr>
<tr class="separator:a0a1a39850b4f51707c6b4609dd45f106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f7382c2c6fcd97da74fa246206375b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a52f7382c2c6fcd97da74fa246206375b">m_pertinentRoot</a></td></tr>
<tr class="memdesc:a52f7382c2c6fcd97da74fa246206375b"><td class="mdescLeft">&#160;</td><td class="mdescRight">a pointer to the root of the pertinent subtree.  <a href="classogdf_1_1_p_q_tree.html#a52f7382c2c6fcd97da74fa246206375b">More...</a><br /></td></tr>
<tr class="separator:a52f7382c2c6fcd97da74fa246206375b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf037b32f2e61ee0056fb25fd91e536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#afaf037b32f2e61ee0056fb25fd91e536">m_pseudoRoot</a></td></tr>
<tr class="memdesc:afaf037b32f2e61ee0056fb25fd91e536"><td class="mdescLeft">&#160;</td><td class="mdescRight">a pointer to the virtual root of the pertinent subtree, in case that the pertinent root cannot be detected.  <a href="classogdf_1_1_p_q_tree.html#afaf037b32f2e61ee0056fb25fd91e536">More...</a><br /></td></tr>
<tr class="separator:afaf037b32f2e61ee0056fb25fd91e536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e0236df8adf9458353c304405a62a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a02e0236df8adf9458353c304405a62a5">m_root</a></td></tr>
<tr class="memdesc:a02e0236df8adf9458353c304405a62a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">a pointer to the root of the $PQ$-tree.  <a href="classogdf_1_1_p_q_tree.html#a02e0236df8adf9458353c304405a62a5">More...</a><br /></td></tr>
<tr class="separator:a02e0236df8adf9458353c304405a62a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a058fd295de75a48d2c0f948f6495cd55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a058fd295de75a48d2c0f948f6495cd55">checkChain</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *firstFull, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **seqStart, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **seqEnd)</td></tr>
<tr class="memdesc:a058fd295de75a48d2c0f948f6495cd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether all full children of a Q-node <code>nodePtr</code> form a consecutive sequence.  <a href="classogdf_1_1_p_q_tree.html#a058fd295de75a48d2c0f948f6495cd55">More...</a><br /></td></tr>
<tr class="separator:a058fd295de75a48d2c0f948f6495cd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75513a32b835a71780a48b3c09f90ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#af75513a32b835a71780a48b3c09f90ec">copyFullChildrenToPartial</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *partialChild)</td></tr>
<tr class="memdesc:af75513a32b835a71780a48b3c09f90ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all full children of <code>nodePtr</code> to a new P-node The node <code>nodePtr</code> has to be a P-node.  <a href="classogdf_1_1_p_q_tree.html#af75513a32b835a71780a48b3c09f90ec">More...</a><br /></td></tr>
<tr class="separator:af75513a32b835a71780a48b3c09f90ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002a875a65df565df7e74d4e3df9aa3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a002a875a65df565df7e74d4e3df9aa3f">createNodeAndCopyFullChildren</a> (<a class="el" href="classogdf_1_1_list.html">List</a>&lt; <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; * &gt; *fullNodes)</td></tr>
<tr class="memdesc:a002a875a65df565df7e74d4e3df9aa3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the full children of a P-node that are stored in the stack <code>fullNodes</code> to a new P-node.  <a href="classogdf_1_1_p_q_tree.html#a002a875a65df565df7e74d4e3df9aa3f">More...</a><br /></td></tr>
<tr class="separator:a002a875a65df565df7e74d4e3df9aa3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34044dcf871fafe0f85241d0398a9dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a34044dcf871fafe0f85241d0398a9dcb">removeBlock</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr, bool isRoot)</td></tr>
<tr class="memdesc:a34044dcf871fafe0f85241d0398a9dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Of every partial node that is found in the sequence of children of <code>nodePtr</code>, all children are removed from that partial node and included as children of <code>nodePtr</code>, occupying the place of the partial node in the sequence of children of <code>nodePtr</code>.  <a href="classogdf_1_1_p_q_tree.html#a34044dcf871fafe0f85241d0398a9dcb">More...</a><br /></td></tr>
<tr class="separator:a34044dcf871fafe0f85241d0398a9dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0185a60cfe33d6be6e59316695d39f8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a0185a60cfe33d6be6e59316695d39f8a">sortExceptions</a> (int Exceptions[], int arraySize)</td></tr>
<tr class="memdesc:a0185a60cfe33d6be6e59316695d39f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the exceptions before frontExcept() scans the frontier.  <a href="classogdf_1_1_p_q_tree.html#a0185a60cfe33d6be6e59316695d39f8a">More...</a><br /></td></tr>
<tr class="separator:a0185a60cfe33d6be6e59316695d39f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class X, class Y&gt;<br />
class ogdf::PQTree&lt; T, X, Y &gt;</h3>


<p class="definition">Definition at line <a class="el" href="_p_q_node_8h_source.html#l00045">45</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a06a066a75771df90f15ce2e0158bc031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a066a75771df90f15ce2e0158bc031">&#9670;&nbsp;</a></span>PQTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::<a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01701">1701</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a3800a1ed72a5297db2ab308e17c825a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3800a1ed72a5297db2ab308e17c825a9">&#9670;&nbsp;</a></span>~PQTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::~<a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>In order to free allocated memory, all nodes of the tree have to be deleted, hence their destructors have to be called. This is done in the function <a class="el" href="classogdf_1_1_p_q_tree.html#a4f30510581fac9c24be3fce6b0b4b82d" title="Removes the entire PQ-tree.">Cleanup()</a>. Furthermore all other initialized memory has to be freed which is done as well in the function <a class="el" href="classogdf_1_1_p_q_tree.html#a4f30510581fac9c24be3fce6b0b4b82d" title="Removes the entire PQ-tree.">Cleanup()</a>. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00061">61</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ade6ceec35587bfc0b421a9984538b373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6ceec35587bfc0b421a9984538b373">&#9670;&nbsp;</a></span>addNewLeavesToTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::addNewLeavesToTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_internal_node.html">PQInternalNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>father</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>leafKeys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a set of elements to the already existing set of elements of a PQ-tree. </p>
<p>These elements have to be of type <a class="el" href="classogdf_1_1_p_q_leaf_key.html" title="The class template PQLeafKey is a derived class of class template PQBasicKey.">PQLeafKey</a> and are handed to the function in an array leafKeys. The father of the new elements that has to be an existing P- or Q-node, has to be specified and is not allowed to have children.</p>
<p>The above mentioned facts are checked by the function <a class="el" href="classogdf_1_1_p_q_tree.html#a78fa49ce4ad7cb1f0d5d31919d34a4bc" title="Adds a node child as a child to another node specified in parent.">addNodeToNewParent()</a> and the process of adding a child to parent is interrupted with an error message returning 0 as soon none of the facts is fullfilled.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if it succeeded in adding the leaves to parent. </dd></dl>
<p>Enter the first element as <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a> to the [[parent]].</p>
<p>Enter all other elements as leaves to [[parent]].</p>
<p>Set the reference pointers if [[parent]] is a $P$-node.</p>
<p>Set the endmost children if [[parent is a $Q$-node.</p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00817">817</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a78fa49ce4ad7cb1f0d5d31919d34a4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fa49ce4ad7cb1f0d5d31919d34a4bc">&#9670;&nbsp;</a></span>addNodeToNewParent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::addNodeToNewParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a node <code>child</code> as a child to another node specified in <code>parent</code>. </p>
<p>The <code>parent</code> of the new node has to be an existing P- or Q-node and is <b>not</b> allowed to have children. In the case, that <code>parent</code> has children, addNewNodeToParent() returns 0 printing an error-message. In this case, use the overloaded function specifying the future siblings of <code>child</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>1 after successfully inserting <code>child</code> to <code>parent</code>, otherwise 0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00870">870</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a46bf5f7e4ecfd0d7a1a28557c0b5d328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46bf5f7e4ecfd0d7a1a28557c0b5d328">&#9670;&nbsp;</a></span>addNodeToNewParent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::addNodeToNewParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>leftBrother</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>rightBrother</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a node <code>child</code> to the children of another node specified in <code>parent</code>. </p>
<p>The <code>parent</code> of the new node has to be an existing P- or Q-node and is allowed to have children. In case that <code>parent</code> has children, the siblings of the new introduced child <b> must be specified</b>. If no siblings are specified, the function <a class="el" href="classogdf_1_1_p_q_tree.html#a78fa49ce4ad7cb1f0d5d31919d34a4bc" title="Adds a node child as a child to another node specified in parent.">addNodeToNewParent(PQNode&lt;T,X,Y&gt;*,PQNode&lt;T,X,Y&gt;*)</a> is called by default. If the <code>parent</code> is not specified, the function assumes that <code>child</code> is added as interior child to a Q-node.</p>
<p>The client of this function should observe the following facts:</p><ul>
<li>If <code>parent</code> is a P-node, than only one sibling is needed in order to enter the <code>child</code>. If the client specifies two siblings in <code>leftBrother</code> and <code>rightBrother</code>, then an arbitrary one is choosen to be a sibling.</li>
<li>If <code>parent</code> is a Q-node, two siblings <b>must be specified</b> if <code>child</code> has to become an interior child of the Q-node. If just one sibling is specified, this implies that <code>child</code> is about to become a new endmost child of <code>parent</code>. So either <code>leftBrother</code> or <code>rightBrother</code> must store an existing endmost child of <code>parent</code>.</li>
<li>If <code>parent</code> is a zero pointer, addNodeToNewParents() assumes that <code>child</code> is added as interior child to a Q-node. In this case <b>both</b> siblings of <code>child</code> <b>have to be specified</b>. Observe however, that it is also legal to specify the parent in this case.</li>
</ul>
<p>The above mentioned facts are checked and the process of adding a child to <code>parent</code> is interrupted with an error message returning 0 as soon none of the facts is fulfilled.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if it succeeded in adding the <code>child</code> to <code>parent</code>, otherwise 0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00912">912</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="aebe0fa141e29868c08b60250ad53788e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe0fa141e29868c08b60250ad53788e">&#9670;&nbsp;</a></span>Bubble()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::Bubble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>leafKeys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Realizes a function described in [Booth]. </p>
<p>It <em>bubbles</em> up from the pertinent leaves to the pertinent root in order to make sure that every pertinent node in the pertinent subtree has a valid pointer to its parent. If <a class="el" href="classogdf_1_1_p_q_tree.html#aebe0fa141e29868c08b60250ad53788e" title="Realizes a function described in [Booth].">Bubble()</a> does not succed in doing so, then the set of elements, stored in the <code>leafKeys</code> cannot form a consecutive sequence. </p>

<p>Reimplemented in <a class="el" href="classogdf_1_1_max_sequence_p_q_tree.html#a9d42308a01cfd58c7d14b21d3399fc4a">ogdf::MaxSequencePQTree&lt; T, Y &gt;</a>, and <a class="el" href="classogdf_1_1_max_sequence_p_q_tree.html#a9d42308a01cfd58c7d14b21d3399fc4a">ogdf::MaxSequencePQTree&lt; edge, bool &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01098">1098</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a058fd295de75a48d2c0f948f6495cd55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058fd295de75a48d2c0f948f6495cd55">&#9670;&nbsp;</a></span>checkChain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::checkChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>firstFull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **&#160;</td>
          <td class="paramname"><em>seqStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **&#160;</td>
          <td class="paramname"><em>seqEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether all full children of a Q-node <code>nodePtr</code> form a consecutive sequence. </p>
<p>If the full nodes do so, the procedure returns 1 as a result, otherwise 0.</p>
<p>The pointer <code>firstFull</code> denotes just an arbirtary full child. Starting from this position, checkChain sweeps through the consecutive sequence, halting as soon as a nonfull child is detected. The two pointers <code>seqStart</code> and <code>seqEnd</code> are set within this function. They denote the first and last node of the consecutive sequence.</p>
<p>The client should observe that it is not possible to avoid the use of such a function. According to the procedure <a class="el" href="classogdf_1_1_p_q_tree.html#aebe0fa141e29868c08b60250ad53788e" title="Realizes a function described in [Booth].">Bubble()</a> children of Q-nodes get unblocked as soon as they are adjacent to any pertinent sibling. This includes that chains of more than two partial children are regarded as unblocked as well. Such chains are of course not reducible and therefore have to be detected by the function <a class="el" href="classogdf_1_1_p_q_tree.html#a058fd295de75a48d2c0f948f6495cd55" title="Checks whether all full children of a Q-node nodePtr form a consecutive sequence.">checkChain()</a>.</p>
<p>The function is used by the function <a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169" title="Template matching for Q-nodes with a pertinent sequence of children on one side of the Q-node.">templateQ2()</a> and <a class="el" href="classogdf_1_1_p_q_tree.html#aefd5607fec9aaf74d58fb53ddb9883a7">templateQ3()</a>. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01384">1384</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a70a0040240c4da107e76844e86fe5954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a0040240c4da107e76844e86fe5954">&#9670;&nbsp;</a></span>checkIfOnlyChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::checkIfOnlyChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>child</code> is the only child of <code>parent</code>. </p>
<p>If so, <code>child</code> is connected to its grandparent, as long as parent is not the root of the tree. In case that <code>parent</code> is the root of the tree and <code>child</code> is its only child, the node <code>child</code> becomes the new root of the tree. The parent then is completely removed from the tree and destroyed.</p>
<p>Before applying the function <a class="el" href="classogdf_1_1_p_q_tree.html#a59cce16d012eb159eb8dc191d17e9aa6" title="Replaces the oldNode by the newNode in the tree.">exchangeNodes()</a>, the function <a class="el" href="classogdf_1_1_p_q_tree.html#ab9eb0c1fe76d998f4b2906b4af3a1c9f" title="Removes the node nodePtr from the doubly linked list of its parent.">removeChildFromSiblings()</a> is applied. This is useful in case the node <code>parent</code> has some ignored children and has to be reused within some extra algorithmic context.</p>
<dl class="section return"><dt>Returns</dt><dd>1, if <code>child</code> was the only child of <code>parent</code>, otherwise 0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01518">1518</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="ab52db9d9ca5b62ec0a3edbe171624d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52db9d9ca5b62ec0a3edbe171624d6e">&#9670;&nbsp;</a></span>CleanNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::CleanNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classogdf_1_1_max_sequence_p_q_tree.html#a8c1cf0cb9bf8641f599532a19d0c2ff8">ogdf::MaxSequencePQTree&lt; T, Y &gt;</a>, and <a class="el" href="classogdf_1_1_max_sequence_p_q_tree.html#a8c1cf0cb9bf8641f599532a19d0c2ff8">ogdf::MaxSequencePQTree&lt; edge, bool &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00101">101</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a4f30510581fac9c24be3fce6b0b4b82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f30510581fac9c24be3fce6b0b4b82d">&#9670;&nbsp;</a></span>Cleanup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::Cleanup</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the entire PQ-tree. </p>
<p>It is called by the destructor. It scans all nodes of the tree and frees the memory used by the tree. It removes the memory allocated by the following datastructures:</p><ul>
<li><a class="el" href="classogdf_1_1_p_q_tree.html#a02e0236df8adf9458353c304405a62a5" title="a pointer to the root of the $PQ$-tree.">m_root</a>,</li>
<li><a class="el" href="classogdf_1_1_p_q_tree.html#afaf037b32f2e61ee0056fb25fd91e536" title="a pointer to the virtual root of the pertinent subtree, in case that the pertinent root cannot be det...">m_pseudoRoot</a>,</li>
<li><a class="el" href="classogdf_1_1_p_q_tree.html#a0a1a39850b4f51707c6b4609dd45f106" title="Stores all nodes that have been marked PQNodeRoot::PQNodeStatus::Full or PQNodeRoot::PQNodeStatus::Pa...">m_pertinentNodes</a>. It enables the client to reuse the function <a class="el" href="classogdf_1_1_p_q_tree.html#acb0962923f0af759f5c4552a67b2927b" title="Initializes the PQ-tree with a set of elements.">Initialize()</a>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01543">1543</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="aad3622dd2eb4a98178f63f13a6d452fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3622dd2eb4a98178f63f13a6d452fb">&#9670;&nbsp;</a></span>clientDefinedEmptyNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::clientDefinedEmptyNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the user wishes to use different flags in a derived class of <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> that are not available in this implementation, he can overload this function to make a valid cleanup of the nodes. </p>
<p>It will be called per default by the function <a class="el" href="classogdf_1_1_p_q_tree.html#a88cca4fcb55736c826a9ddd5802302c8" title="Cleans up all flags that have been set in the pertinent nodes during the reduction process.">emptyAllPertinentNodes()</a>. </p>

<p>Reimplemented in <a class="el" href="classogdf_1_1_max_sequence_p_q_tree.html#afa2cb6e74dff6059954f6c6ed30b432b">ogdf::MaxSequencePQTree&lt; T, Y &gt;</a>, and <a class="el" href="classogdf_1_1_max_sequence_p_q_tree.html#afa2cb6e74dff6059954f6c6ed30b432b">ogdf::MaxSequencePQTree&lt; edge, bool &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00122">122</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a2d4692a762c6c42cac7c1f026954c348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4692a762c6c42cac7c1f026954c348">&#9670;&nbsp;</a></span>clientLeftEndmost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::clientLeftEndmost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00683">683</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a7ea906aa316225fa43a62408393ed718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea906aa316225fa43a62408393ed718">&#9670;&nbsp;</a></span>clientNextSib()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::clientNextSib </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00691">691</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a9ab9b850b03485163d66e9ead0b8e70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab9b850b03485163d66e9ead0b8e70a">&#9670;&nbsp;</a></span>clientPrintNodeCategorie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::clientPrintNodeCategorie </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the user wishes to use different flags in a derived class of <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> that are not available in this implementation, he can overload this function. </p>
<p>With the help of this function it is possible to influence the layout of the nodes by using new, different lables depicting node categories in the <em>Tree Interface</em>. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01683">1683</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a110ddd73ab4993d6fb59404126a93711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110ddd73ab4993d6fb59404126a93711">&#9670;&nbsp;</a></span>clientPrintStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::clientPrintStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the user wishes to use different status in a derived class of <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> that are not available in this implementation, he can overload this function. </p>
<p>With the help of this function it is possible to influence the information stored at nodes in the <em>Tree Interface</em> that concern the status of a node. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01690">1690</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a0e8083c97003857dabab2acd6b5fbab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8083c97003857dabab2acd6b5fbab8">&#9670;&nbsp;</a></span>clientPrintType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::clientPrintType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the user wishes to use different types in a derived class of <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> that are not available in this implementation, he can overload this function. </p>
<p>With the help of this function it is possible to influence the information stored at nodes in the <em>Tree Interface</em> that concern the type of a node. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01696">1696</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a3da1c0609a58a901350bd4c8f847ee47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da1c0609a58a901350bd4c8f847ee47">&#9670;&nbsp;</a></span>clientRightEndmost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::clientRightEndmost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00687">687</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a8a83bf0154c5bb150834ad8a60bc2719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a83bf0154c5bb150834ad8a60bc2719">&#9670;&nbsp;</a></span>clientSibLeft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::clientSibLeft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00696">696</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a0ef18d897994c45d983280421467ccef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef18d897994c45d983280421467ccef">&#9670;&nbsp;</a></span>clientSibRight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::clientSibRight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00700">700</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="af75513a32b835a71780a48b3c09f90ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75513a32b835a71780a48b3c09f90ec">&#9670;&nbsp;</a></span>copyFullChildrenToPartial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::copyFullChildrenToPartial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>partialChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all full children of <code>nodePtr</code> to a new P-node The node <code>nodePtr</code> has to be a P-node. </p>
<p>The new P-node is added to <code>partialChild</code> as an endmost child of <code>partialChild</code>. The node <code>partialChild</code> has to be a Q-node and the new P-node is added to the side of <code>partialChild</code> where the pertinent children are.</p>
<p>The new P-node is allocated by this function and referenced by the variable <code>newNode</code>.</p>
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#af75513a32b835a71780a48b3c09f90ec" title="Copies all full children of nodePtr to a new P-node The node nodePtr has to be a P-node.">copyFullChildrenToPartial()</a> is used by the functions <a class="el" href="classogdf_1_1_p_q_tree.html#a08ac709fa37043f44cbd15386d85b520" title="Template matching for a P-node with full, empty and exactly one partial children.">templateP4()</a>, <a class="el" href="classogdf_1_1_p_q_tree.html#a59dc0201fbefa391f83c3d7d28414530" title="Template matching for a P-node with full, empty children and exactly one partial child.">templateP5()</a>, and <a class="el" href="classogdf_1_1_p_q_tree.html#a21c29c90e12637a2c1a91a59f67c9c74" title="Template matching for a P-node with full, empty and exactly two partial children.">templateP6()</a>. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01714">1714</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a002a875a65df565df7e74d4e3df9aa3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002a875a65df565df7e74d4e3df9aa3f">&#9670;&nbsp;</a></span>createNodeAndCopyFullChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; * <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::createNodeAndCopyFullChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_list.html">List</a>&lt; <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; * &gt; *&#160;</td>
          <td class="paramname"><em>fullNodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the full children of a P-node that are stored in the stack <code>fullNodes</code> to a new P-node. </p>
<p>This new P-node is created by the function and stored in <em>newNode</em> if there is more than one full child. If there is just one full child, it is not necessary to construct a new P-node and the full child is stored in <em>newNode</em>. The <em>newNode</em> is the return value of the procedure.</p>
<p>This function is used by <a class="el" href="classogdf_1_1_p_q_tree.html#ac4660c9511e753585cc5f77106de61e7" title="Template matching for a P-node with full and empty children that is the root of the pertinent subtree...">templateP2()</a>, <a class="el" href="classogdf_1_1_p_q_tree.html#a9b9b472f8e7c6bd35d2741850c7bcaac" title="Template matching for a P-node with full and empty children that is not the root of the pertinent sub...">templateP3()</a> and <a class="el" href="classogdf_1_1_p_q_tree.html#af75513a32b835a71780a48b3c09f90ec" title="Copies all full children of nodePtr to a new P-node The node nodePtr has to be a P-node.">copyFullChildrenToPartial()</a>. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01754">1754</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a162069c126ebf888585fb39fa833c65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162069c126ebf888585fb39fa833c65c">&#9670;&nbsp;</a></span>destroyNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::destroyNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks a node as <a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1bac6a36c1a9004ff0b1a6033b19d2c131d">PQNodeRoot::PQNodeStatus::ToBeDeleted</a>. </p>
<p>This enables the function <a class="el" href="classogdf_1_1_p_q_tree.html#a88cca4fcb55736c826a9ddd5802302c8" title="Cleans up all flags that have been set in the pertinent nodes during the reduction process.">emptyAllPertinentNodes()</a> to remove the node and free its memory. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00576">576</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a88cca4fcb55736c826a9ddd5802302c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cca4fcb55736c826a9ddd5802302c8">&#9670;&nbsp;</a></span>emptyAllPertinentNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::emptyAllPertinentNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cleans up all flags that have been set in the pertinent nodes during the reduction process. </p>
<p>All pertinent nodes have been stored in the private member stack <a class="el" href="classogdf_1_1_p_q_tree.html#a0a1a39850b4f51707c6b4609dd45f106" title="Stores all nodes that have been marked PQNodeRoot::PQNodeStatus::Full or PQNodeRoot::PQNodeStatus::Pa...">m_pertinentNodes</a> during the <a class="el" href="classogdf_1_1_p_q_tree.html#aebe0fa141e29868c08b60250ad53788e" title="Realizes a function described in [Booth].">Bubble()</a> phase or when processing one of the templates (see <a class="el" href="classogdf_1_1_p_q_tree.html#a230967681d50f958a8f1318f15e70638" title="Template matching for leaves.">templateL1()</a> to <a class="el" href="classogdf_1_1_p_q_tree.html#aefd5607fec9aaf74d58fb53ddb9883a7">templateQ3()</a>).</p>
<p>This function has to be called after a reduction has been processed. </p>

<p>Reimplemented in <a class="el" href="classogdf_1_1booth__lueker_1_1_embed_p_q_tree.html#a7949b35949bd995510840c9878774429">ogdf::booth_lueker::EmbedPQTree</a>, <a class="el" href="classogdf_1_1booth__lueker_1_1_planar_p_q_tree.html#a89310c61505c3fc181c0ec5ae6df2f42">ogdf::booth_lueker::PlanarPQTree</a>, <a class="el" href="classogdf_1_1_max_sequence_p_q_tree.html#ab53f5e88734def785e5473ff14b0e493">ogdf::MaxSequencePQTree&lt; T, Y &gt;</a>, and <a class="el" href="classogdf_1_1_max_sequence_p_q_tree.html#ab53f5e88734def785e5473ff14b0e493">ogdf::MaxSequencePQTree&lt; edge, bool &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01838">1838</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a76af348fc7bc262e6f229f06d936cfaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76af348fc7bc262e6f229f06d936cfaf">&#9670;&nbsp;</a></span>emptyNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::emptyNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleans up all stacks, flags and pointers of a pertinent node that has been visited during the reduction process. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01875">1875</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a59cce16d012eb159eb8dc191d17e9aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59cce16d012eb159eb8dc191d17e9aa6">&#9670;&nbsp;</a></span>exchangeNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::exchangeNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>oldNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>newNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the <code>oldNode</code> by the <code>newNode</code> in the tree. </p>
<p>This is a function used very often in the template matchings, normally in combination with the construction of a new node which has to conquer the place of an existing node in the tree.</p>
<p>This function can be used in all cases, so the parent of <code>oldNode</code> is allowed to be either a Q-node or a P-node and <code>oldNode</code> may be any child of its parent.</p>
<p>The client should observe, that this function does <b>not</b> reset the pointer <a class="el" href="classogdf_1_1_p_q_tree.html#a02e0236df8adf9458353c304405a62a5" title="a pointer to the root of the $PQ$-tree.">m_root</a>. If necessary, this has to be done explicitly by the client himself. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01886">1886</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="ace84522b54600068c37a1df5d542f34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace84522b54600068c37a1df5d542f34a">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>leafKeys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the keys stored in the leaves of the front of <code>nodePtr</code>. </p>
<p>A specified node <code>nodePtr</code> of the PQ-tree is handed to the function and <a class="el" href="classogdf_1_1_p_q_tree.html#ace84522b54600068c37a1df5d542f34a" title="Returns the keys stored in the leaves of the front of nodePtr.">front()</a> detects the leaves in the front of this node returning the elements represented by the leaves. These elements are stored in an array of keys named <code>leafKeys</code>. Observe that <a class="el" href="classogdf_1_1_p_q_tree.html#ace84522b54600068c37a1df5d542f34a" title="Returns the keys stored in the leaves of the front of nodePtr.">front()</a> uses <code>leafKeys</code>[0] to store the first key. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01988">1988</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a1920edd68529b710da2775359803d54a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1920edd68529b710da2775359803d54a">&#9670;&nbsp;</a></span>fullChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_list.html">List</a>&lt;<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;*&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::fullChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00674">674</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="acb0962923f0af759f5c4552a67b2927b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0962923f0af759f5c4552a67b2927b">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>leafKeys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the PQ-tree with a set of elements. </p>
<p>These elements have to be template classes of the class template <a class="el" href="classogdf_1_1_p_q_leaf_key.html" title="The class template PQLeafKey is a derived class of class template PQBasicKey.">PQLeafKey</a> and are handed to the function in an array <code>leafKeys</code>. The function constructs the universal PQ-tree. If the <em>numberOfElements</em> &gt; 1, the universal PQ-tree consists of one P-node as root (stored in <a class="el" href="classogdf_1_1_p_q_tree.html#a02e0236df8adf9458353c304405a62a5" title="a pointer to the root of the $PQ$-tree.">m_root</a>) and all leaves gathered underneath the P-node, symbolizing all kinds of permutations. If <em>numberOfElements</em> = 1, the universal PQ-tree consists of a single <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a>, being the root of the tree.</p>
<p>Observe that the first element has to be stored in <code>leafKeys</code>[0] and the last one in <code>leafKeys</code>[<em>numberOfElements-1</em>].</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the initialization of the PQ-tree was successful. </dd></dl>

<p>Reimplemented in <a class="el" href="classogdf_1_1_planar_subgraph_p_q_tree.html#a426fb5eb3b44ec70ef7890b9a724762f">ogdf::PlanarSubgraphPQTree</a>.</p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l02033">2033</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="af746642d3e338f1fa13198dd58c68158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af746642d3e338f1fa13198dd58c68158">&#9670;&nbsp;</a></span>linkChildrenOfQnode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::linkChildrenOfQnode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>installed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>newChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Links the two endmost children of two <b>different</b> Q-nodes via their sibling pointers together. </p>
<p>The purpose of doing this is to combine the children of two Q-nodes as children of only one Q-node. This function does not reset the pointers to the endmost children of the Q-node. This has to be done by the client of the function. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l02061">2061</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a111287c97892d05b1a31f9fa4b5e2ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111287c97892d05b1a31f9fa4b5e2ec4">&#9670;&nbsp;</a></span>partialChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_list.html">List</a>&lt;<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;*&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::partialChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00679">679</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a3235c9bd712835664f1dc8373f27276f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3235c9bd712835664f1dc8373f27276f">&#9670;&nbsp;</a></span>Reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::Reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>leafKeys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the reduction of the pertinent leaves with the help of the template matchings, designed by Booth and Lueker. </p>
<p>The reader should observe that this function can only be called after every pertinent node in the pertinent subtree has gotten a valid parent pointer. If this is not the case, the programm will be interrupted by run-time errors such as seqmentation faults. The pertinent nodes can get valid parent pointers by using the function <a class="el" href="classogdf_1_1_p_q_tree.html#aebe0fa141e29868c08b60250ad53788e" title="Realizes a function described in [Booth].">Bubble()</a>. If it returns 1, then it was succesful in giving each pertinent node in the pertinent subtree a valid parent pointer. If it returns 0, then some nodes do not have a valid parent pointer and the pertinent leaves are not reducable.</p>
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a3235c9bd712835664f1dc8373f27276f" title="Performs the reduction of the pertinent leaves with the help of the template matchings,...">Reduce()</a> starts with the pertinent leaves and stores them in a queue <em>processNodes</em>. Every time a node is processed, its parent is checked whether all its pertinent children are already processed. If this is the case, the parent is allowed to be processed as well and stored in the queue.</p>
<p>Processing a node means that the function <a class="el" href="classogdf_1_1_p_q_tree.html#a3235c9bd712835664f1dc8373f27276f" title="Performs the reduction of the pertinent leaves with the help of the template matchings,...">Reduce()</a> tries to apply one of the template matchings. In case that one template matching was successful, the node was reduced and <a class="el" href="classogdf_1_1_p_q_tree.html#a3235c9bd712835664f1dc8373f27276f" title="Performs the reduction of the pertinent leaves with the help of the template matchings,...">Reduce()</a> tries to reduce the next node. In case that no template matching was successfully applied, the tree is is irreducible. This causes the reduction process to be halted returning 0. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l02288">2288</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="ac39ae8ac138b95635a4db2f57898b94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39ae8ac138b95635a4db2f57898b94d">&#9670;&nbsp;</a></span>Reduction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::Reduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>leafKeys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether permissible permutations of the elements of U exist such that the elements of a subset S of U, stored in <code>leafKeys</code>, form a consecutive sequence. </p>
<p>If there exists such a permutation, the PQ-tree is reduced and <a class="el" href="classogdf_1_1_p_q_tree.html#ac39ae8ac138b95635a4db2f57898b94d" title="Tests whether permissible permutations of the elements of U exist such that the elements of a subset ...">Reduction()</a> returns 1.</p>
<p>This function gets a list <code>leafKeys</code> of pointers to elements of type <a class="el" href="classogdf_1_1_p_q_leaf_key.html" title="The class template PQLeafKey is a derived class of class template PQBasicKey.">PQLeafKey</a>, representing all elements of S. </p>

<p>Reimplemented in <a class="el" href="classogdf_1_1_planar_subgraph_p_q_tree.html#adee3ea7e8866d6483cf72362926ad540">ogdf::PlanarSubgraphPQTree</a>.</p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l02388">2388</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a34044dcf871fafe0f85241d0398a9dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34044dcf871fafe0f85241d0398a9dcb">&#9670;&nbsp;</a></span>removeBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::removeBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRoot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Of every partial node that is found in the sequence of children of <code>nodePtr</code>, all children are removed from that partial node and included as children of <code>nodePtr</code>, occupying the place of the partial node in the sequence of children of <code>nodePtr</code>. </p>
<p>Thereby, <a class="el" href="classogdf_1_1_p_q_tree.html#a34044dcf871fafe0f85241d0398a9dcb" title="Of every partial node that is found in the sequence of children of nodePtr, all children are removed ...">removeBlock()</a> takes care, that the newly included full children of <code>nodePtr</code> form a consecutive sequence with the already existing pertinent children of <code>nodePtr</code>. The partial node itself is deleted afterwards.</p>
<p>This function is used by the functions <a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169" title="Template matching for Q-nodes with a pertinent sequence of children on one side of the Q-node.">templateQ2()</a> and <a class="el" href="classogdf_1_1_p_q_tree.html#aefd5607fec9aaf74d58fb53ddb9883a7">templateQ3()</a>.</p>
<p>The node <code>nodePtr</code> is expected to be a Q-node with no, one or at most two partial children, such that the partial and full children of <code>nodePtr</code> form a legal consecutive sequence, hence can be reduced. </p>
<p>Pointer to the first partial child</p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l02402">2402</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="ab9eb0c1fe76d998f4b2906b4af3a1c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9eb0c1fe76d998f4b2906b4af3a1c9f">&#9670;&nbsp;</a></span>removeChildFromSiblings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::removeChildFromSiblings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the node <code>nodePtr</code> from the doubly linked list of its parent. </p>
<p>In case that <code>nodePtr</code> is endmost child of an Q-node or child of a P-node equiped with a valid reference pointer <em>referenceParent</em> to its parent (see <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class.">PQNode</a>), these pointers are considered as well and the adjacent siblings of <code>nodePtr</code> have to cover <code>nodePtr's</code> task. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l02961">2961</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a9e55e4addaa7de1ffb6e6332fd087892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e55e4addaa7de1ffb6e6332fd087892">&#9670;&nbsp;</a></span>removeNodeFromTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::removeNodeFromTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The objective is to remove a node <code>child</code> from the PQ-tree. </p>
<p>To do so, the <code>parent</code> of the node <code>child</code> has to be known by the user. To indicate this, the parent has to be handed over by her.</p>
<p>This function has to be handled with great care by the user. It is not used in any of the functions of the class template <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> and can only be accessed by inheritance.</p>
<p><b>This function does not check if <code>parent</code> is the parent node of <code>child</b></code>. This has to be guaranteed by the user. The reason for this riscfull approach lies in the details of the powerful data structure PQ-tree. In order to reach linear runtime, the internal children of a Q-node normally do not have valid parent pointers. So forcing this function to search the parent would cost in worst case linear runtime for one call of the function <a class="el" href="classogdf_1_1_p_q_tree.html#a9e55e4addaa7de1ffb6e6332fd087892" title="The objective is to remove a node child from the PQ-tree.">removeNodeFromTree()</a>. Its up to the user to do better.</p>
<p>Calling <a class="el" href="classogdf_1_1_p_q_tree.html#a9e55e4addaa7de1ffb6e6332fd087892" title="The objective is to remove a node child from the PQ-tree.">removeNodeFromTree()</a> with nullptr for <code>parent</code>, will always terminate this function with an ERROR-message and returning -1 as value.</p>
<p>The return value is an integer value used to indicate how many children the <code>parent</code> after the removal of <code>child</code> still has. The client should observe that internal nodes in the PQ-tree which have just one or no children at all do not make sense. However, the function <a class="el" href="classogdf_1_1_p_q_tree.html#a9e55e4addaa7de1ffb6e6332fd087892" title="The objective is to remove a node child from the PQ-tree.">removeNodeFromTree()</a> <b>does not check if <code>parent</code> has less than two children after the removal of &lt; child</b>. So in case that <code>parent</code> has less than two children, the user has to check this by herself and remove the <code>parent</code>, probably using the function <a class="el" href="classogdf_1_1_p_q_tree.html#a70a0040240c4da107e76844e86fe5954" title="Checks if child is the only child of parent.">checkIfOnlyChild()</a>.</p>
<p>There are two reasons why the function <a class="el" href="classogdf_1_1_p_q_tree.html#a9e55e4addaa7de1ffb6e6332fd087892" title="The objective is to remove a node child from the PQ-tree.">removeNodeFromTree()</a> does not check if <code>parent</code> has less than two children after the removal of <code>child:</code> </p><ol type="1">
<li>The user might keep the node in the tree in order to add new nodes as children to it.</li>
<li>Again, the parent of <code>parent</code> might not be known to <code>parent</code>, hence removeNodeTree() would have to search, at the cost of linear time consumption, for the parent of <code>parent</code> first before removing <code>parent</code> from the tree.</li>
</ol>
<p>Observe that <a class="el" href="classogdf_1_1_p_q_tree.html#a9e55e4addaa7de1ffb6e6332fd087892" title="The objective is to remove a node child from the PQ-tree.">removeNodeFromTree()</a> does not free the allocated memory of <code>child</code>. This has to be done by the user <b>after</b> calling <a class="el" href="classogdf_1_1_p_q_tree.html#a9e55e4addaa7de1ffb6e6332fd087892" title="The objective is to remove a node child from the PQ-tree.">removeNodeFromTree()</a>. It also offers the opportunity to reuse deleted nodes. Observe that the identification number of a node <a class="el" href="classogdf_1_1_p_q_tree.html#a75ed08b07f23d14328a91a7ba8bacc7a" title="Stores the total number of nodes that have been allocated.">m_identificationNumber</a> (see <a class="el" href="classogdf_1_1_p_q_node.html" title="The class template PQBasicKey is an abstract base class.">PQNode</a>) cannot be changed. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03023">3023</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a03e347a727d31d264246a0a51e2a82af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e347a727d31d264246a0a51e2a82af">&#9670;&nbsp;</a></span>root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer of the root node of the <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a>. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00169">169</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a0185a60cfe33d6be6e59316695d39f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0185a60cfe33d6be6e59316695d39f8a">&#9670;&nbsp;</a></span>sortExceptions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::sortExceptions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Exceptions</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arraySize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the exceptions before frontExcept() scans the frontier. </p>
<p>It is only called by the function frontExcept(). </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03041">3041</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a230967681d50f958a8f1318f15e70638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230967681d50f958a8f1318f15e70638">&#9670;&nbsp;</a></span>templateL1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateL1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRoot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template matching for leaves. </p>
<p>The function requires as input any pointer to a node stored in <code>nodePtr</code>. If the node stored in <code>nodePtr</code> is a <a class="el" href="classogdf_1_1_p_q_leaf.html" title="The datastructure PQ-tree was designed to present a set of permutations on an arbitrary set of elemen...">PQLeaf</a>, <a class="el" href="classogdf_1_1_p_q_tree.html#a230967681d50f958a8f1318f15e70638" title="Template matching for leaves.">templateL1()</a> considers itself responsible for the node and will apply the template matching for pertinent leaves to <code>nodePtr</code>. If the flag <code>isRoot</code> is set to 1, it signalizes <a class="el" href="classogdf_1_1_p_q_tree.html#a230967681d50f958a8f1318f15e70638" title="Template matching for leaves.">templateL1()</a> that <code>nodePtr</code> is the root of the pertinent subtree. In any other case the flag has to be 0.</p>
<p>If <a class="el" href="classogdf_1_1_p_q_tree.html#a230967681d50f958a8f1318f15e70638" title="Template matching for leaves.">templateL1()</a> was responsible for <code>nodePtr</code> and the reduction was successful, the return value is 1. Otherwise the return value is 0.</p>
<p>The function updates the <em>fullChildren</em> stack of its parent, as long as <code>nodePtr</code> is not the root of the pertinent subtree. Observe that <code>nodePtr</code> needs a valid pointer to its parent. This can be achieved by using the function <a class="el" href="classogdf_1_1_p_q_tree.html#aebe0fa141e29868c08b60250ad53788e" title="Realizes a function described in [Booth].">Bubble()</a> or any other appropriate, user defined function. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03059">3059</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a2a1d21d208da1a620292ff92a101dcf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1d21d208da1a620292ff92a101dcf8">&#9670;&nbsp;</a></span>templateP1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateP1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRoot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template matching for P-nodes with only full children. </p>
<p>The function requires as input any pointer to a node stored in <code>nodePtr</code>. If the node stored in <code>nodePtr</code> is a P-node with only full children, <a class="el" href="classogdf_1_1_p_q_tree.html#a2a1d21d208da1a620292ff92a101dcf8" title="Template matching for P-nodes with only full children.">templateP1()</a> considers itself responsible for the node and will apply the template matching for full P-nodes to <code>nodePtr</code>. If the flag <code>isRoot</code> is set to 1, it signalizes <a class="el" href="classogdf_1_1_p_q_tree.html#a2a1d21d208da1a620292ff92a101dcf8" title="Template matching for P-nodes with only full children.">templateP1()</a> that <code>nodePtr</code> is the root of the pertinent subtree. In any other case the flag has to be 0.</p>
<p>If <a class="el" href="classogdf_1_1_p_q_tree.html#a2a1d21d208da1a620292ff92a101dcf8" title="Template matching for P-nodes with only full children.">templateP1()</a> was responsible for <code>nodePtr</code> and the reduction was successful, the return value is 1. Otherwise the return value is 0.</p>
<p>If the P-node is not the root of the pertinent subtree, the <em>fullChildren</em> stack of the parent of <code>nodePtr</code> is updated. If the P-node is the root of the pertinent subtree, nothing has to be done. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03072">3072</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="ac4660c9511e753585cc5f77106de61e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4660c9511e753585cc5f77106de61e7">&#9670;&nbsp;</a></span>templateP2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateP2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template matching for a P-node with full <b>and</b> empty children that is the root of the pertinent subtree. </p>
<p>The function requires as input any pointer to a node stored in <code>nodePtr</code>. If the node stored in <code>nodePtr</code> is a P-node with no partial children, <a class="el" href="classogdf_1_1_p_q_tree.html#ac4660c9511e753585cc5f77106de61e7" title="Template matching for a P-node with full and empty children that is the root of the pertinent subtree...">templateP2()</a> considers itself responsible for the node and will apply the template matching <b>P2</b> to <code>nodePtr</code>. Observe that the user calling this function has to make sure that <code>nodePtr</code> is partial and is the root of the pertinent subtree.</p>
<p>If <a class="el" href="classogdf_1_1_p_q_tree.html#ac4660c9511e753585cc5f77106de61e7" title="Template matching for a P-node with full and empty children that is the root of the pertinent subtree...">templateP2()</a> was responsible for <code>nodePtr</code> and the reduction was successful, the return value is 1. Otherwise the return value is 0.</p>
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#ac4660c9511e753585cc5f77106de61e7" title="Template matching for a P-node with full and empty children that is the root of the pertinent subtree...">templateP2()</a> creates a new full P-node that will be the new root of the pertinent subtree. It then copies all full children from <code>nodePtr</code> to the new root of the pertinent subtree. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03088">3088</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a9b9b472f8e7c6bd35d2741850c7bcaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9b472f8e7c6bd35d2741850c7bcaac">&#9670;&nbsp;</a></span>templateP3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateP3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template matching for a P-node with full <b>and</b> empty children that is <b>not</b> the root of the pertinent subtree. </p>
<p>The function requires as input any pointer to a node stored in <code>nodePtr</code>. If the node stored in <code>nodePtr</code> is a P-node with no partial children, <a class="el" href="classogdf_1_1_p_q_tree.html#a9b9b472f8e7c6bd35d2741850c7bcaac" title="Template matching for a P-node with full and empty children that is not the root of the pertinent sub...">templateP3()</a> considers itself responsible for the node and will apply the template matching <b>P3</b> to <code>nodePtr</code>. Observe that the user calling this function has to make sure that <code>nodePtr</code> is partial and is not the root of the pertinent subtree.</p>
<p>If <a class="el" href="classogdf_1_1_p_q_tree.html#a9b9b472f8e7c6bd35d2741850c7bcaac" title="Template matching for a P-node with full and empty children that is not the root of the pertinent sub...">templateP3()</a> was responsible for <code>nodePtr</code> and the reduction was successful, the return value is 1. Otherwise the return value is 0.</p>
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a9b9b472f8e7c6bd35d2741850c7bcaac" title="Template matching for a P-node with full and empty children that is not the root of the pertinent sub...">templateP3()</a> creates a new full P-node, stored in <em>newPnode</em> and copies the full children of <code>nodePtr</code> to <em>newPnode</em>. <code>nodePtr</code> keeps all empty children and will be labeled empty. A new partial Q-node will be created and stored in <em>newQnode</em>. <em>newQnode</em> is placed at the position of <code>nodePtr</code> in the tree and gets two children: <code>nodePtr</code> itself and the newly created <em>newPnode</em>. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03118">3118</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a08ac709fa37043f44cbd15386d85b520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ac709fa37043f44cbd15386d85b520">&#9670;&nbsp;</a></span>templateP4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateP4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template matching for a P-node with full, empty and exactly one partial children. </p>
<p>The P-node has to be the root of the pertinent subtree. The function requires as input any pointer to a node stored in <code>nodePtr</code>. If the node stored in <code>nodePtr</code> is a P-node with one partial child, <a class="el" href="classogdf_1_1_p_q_tree.html#a08ac709fa37043f44cbd15386d85b520" title="Template matching for a P-node with full, empty and exactly one partial children.">templateP4()</a> considers itself responsible for the node and will apply the template matching <b>P4</b> to <code>nodePtr</code>. Observe that the user calling this function has to make sure that <code>nodePtr</code> is the root of the pertinent subtree.</p>
<p>If <a class="el" href="classogdf_1_1_p_q_tree.html#a08ac709fa37043f44cbd15386d85b520" title="Template matching for a P-node with full, empty and exactly one partial children.">templateP4()</a> was responsible for <code>nodePtr</code> and the reduction was successful, the return value is 1. Otherwise the return value is 0.</p>
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a08ac709fa37043f44cbd15386d85b520" title="Template matching for a P-node with full, empty and exactly one partial children.">templateP4()</a> creates a new full P-node, if neccessary, and copies the full children of <code>nodePtr</code> to this P-node. The new P-node then is made endmost child of <em>partialChild</em>. The node <em>partialChild</em> is used to store the adress of the partial child of <code>nodePtr</code>. The <em>partialChild</em> itself stays child of <code>nodePtr</code>. Most of the here described action is done in the function <a class="el" href="classogdf_1_1_p_q_tree.html#af75513a32b835a71780a48b3c09f90ec" title="Copies all full children of nodePtr to a new P-node The node nodePtr has to be a P-node.">copyFullChildrenToPartial()</a>. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03185">3185</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a59dc0201fbefa391f83c3d7d28414530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59dc0201fbefa391f83c3d7d28414530">&#9670;&nbsp;</a></span>templateP5()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateP5 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template matching for a P-node with full, empty children and exactly one partial child. </p>
<p>The P-node is not allowed to be the root of the pertinent subtree. The function requires as input any pointer to a node stored in <code>nodePtr</code>. If the node stored in <code>nodePtr</code> is a P-node with one partial child, <a class="el" href="classogdf_1_1_p_q_tree.html#a59dc0201fbefa391f83c3d7d28414530" title="Template matching for a P-node with full, empty children and exactly one partial child.">templateP5()</a> considers itself responsible for the node and will apply the template matching <b>P5</b> to <code>nodePtr</code>. Observe that the user calling this function has to make sure that <code>nodePtr</code> is not the root of the pertinent subtree.</p>
<p>If <a class="el" href="classogdf_1_1_p_q_tree.html#a59dc0201fbefa391f83c3d7d28414530" title="Template matching for a P-node with full, empty children and exactly one partial child.">templateP5()</a> was responsible for <code>nodePtr</code> and the reduction was successful, the return value is 1. Otherwise the return value is 0. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03206">3206</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a21c29c90e12637a2c1a91a59f67c9c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c29c90e12637a2c1a91a59f67c9c74">&#9670;&nbsp;</a></span>templateP6()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateP6 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template matching for a P-node with full, empty and exactly two partial children. </p>
<p>The P-node must be the root of the pertinent subtree. The function requires as input any pointer to a node stored in <code>nodePtr</code>. If the node stored in <code>nodePtr</code> is a P-node with two partial children, <a class="el" href="classogdf_1_1_p_q_tree.html#a21c29c90e12637a2c1a91a59f67c9c74" title="Template matching for a P-node with full, empty and exactly two partial children.">templateP6()</a> considers itself responsible for the node and will apply the template matching <b>P6</b> to <code>nodePtr</code>. Observe that the user calling this function has to make sure that <code>nodePtr</code> is the root of the pertinent subtree.</p>
<p>If <a class="el" href="classogdf_1_1_p_q_tree.html#a21c29c90e12637a2c1a91a59f67c9c74" title="Template matching for a P-node with full, empty and exactly two partial children.">templateP6()</a> was responsible for <code>nodePtr</code> and the reduction was successful, the return value is 1. Otherwise the return value is 0.</p>
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a21c29c90e12637a2c1a91a59f67c9c74" title="Template matching for a P-node with full, empty and exactly two partial children.">templateP6()</a> creates, if neccessary, a new full P-node and copies all the full children of <code>nodePtr</code> to the new full P-node, whereas all empty children stay children of <code>nodePtr</code>. The new P-node will be copied to one of the partial children as endmost child of this partial node. The children of the second partial node are copied to the first one, such that the pertinent nodes form a consecutive sequence. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03302">3302</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a206e9453307cee62d87b915b3f33c036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206e9453307cee62d87b915b3f33c036">&#9670;&nbsp;</a></span>templateQ1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateQ1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRoot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template matching for Q-nodes with only full children. </p>
<p>The function requires as input any pointer to a node stored in <code>nodePtr</code>. If the node stored in <code>nodePtr</code> is a Q-node with only full children, <a class="el" href="classogdf_1_1_p_q_tree.html#a206e9453307cee62d87b915b3f33c036" title="Template matching for Q-nodes with only full children.">templateQ1()</a> considers itself responsible for the node and will apply the template matching for full Q-nodes to <code>nodePtr</code>. If the flag <code>isRoot</code> is set to 1, it signalizes <a class="el" href="classogdf_1_1_p_q_tree.html#a206e9453307cee62d87b915b3f33c036" title="Template matching for Q-nodes with only full children.">templateQ1()</a> that <code>nodePtr</code> is the root of the pertinent subtree. In any other case the flag has to be 0.</p>
<p>If <a class="el" href="classogdf_1_1_p_q_tree.html#a206e9453307cee62d87b915b3f33c036" title="Template matching for Q-nodes with only full children.">templateQ1()</a> was responsible for <code>nodePtr</code> and the reduction was successful, the return value is 1. Otherwise the return value is 0.</p>
<p>Different to the <a class="el" href="classogdf_1_1_p_q_tree.html#a2a1d21d208da1a620292ff92a101dcf8" title="Template matching for P-nodes with only full children.">templateP1()</a> for P-nodes, this function is not able to check if Q-node is full by comparing the number of children with the number of full children. The reason is the application of the <a class="el" href="classogdf_1_1_p_q_tree.html#afaf037b32f2e61ee0056fb25fd91e536" title="a pointer to the virtual root of the pertinent subtree, in case that the pertinent root cannot be det...">m_pseudoRoot</a> at certain steps in the matching algorithm. This <a class="el" href="classogdf_1_1_p_q_tree.html#afaf037b32f2e61ee0056fb25fd91e536" title="a pointer to the virtual root of the pertinent subtree, in case that the pertinent root cannot be det...">m_pseudoRoot</a> is used instead of the real root of the pertinent subtree in case that no parent pointer was found. But this implies that changing the number of the children of the pertinent root is not registered by the pertinent root. Hence we are not allowed to use the <em>childCount</em> of Q-nodes. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03428">3428</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a6839d25d0a5e27cd24f2f3da604b7169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6839d25d0a5e27cd24f2f3da604b7169">&#9670;&nbsp;</a></span>templateQ2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateQ2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRoot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template matching for Q-nodes with a pertinent sequence of children on one side of the Q-node. </p>
<p>The function requires as input any pointer to a node stored in <code>nodePtr</code>. If the node stored in <code>nodePtr</code> is a Q-node with a pertinent sequence of children on one side of the Q-node, <a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169" title="Template matching for Q-nodes with a pertinent sequence of children on one side of the Q-node.">templateQ2()</a> considers itself responsible for the node and will apply the template matching <b>Q2</b> to <code>nodePtr</code>. If the flag <code>isRoot</code> is set to 1, it signalizes <a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169" title="Template matching for Q-nodes with a pertinent sequence of children on one side of the Q-node.">templateQ2()</a> that <code>nodePtr</code> is the root of the pertinent subtree. In any other case the flag has to be 0.</p>
<p>If <a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169" title="Template matching for Q-nodes with a pertinent sequence of children on one side of the Q-node.">templateQ2()</a> was responsible for <code>nodePtr</code> and the reduction was successful, the return value is 1. Otherwise the return value is 0.</p>
<p>Below a short description is given of all different cases that may occure and that are handled by the function <a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169" title="Template matching for Q-nodes with a pertinent sequence of children on one side of the Q-node.">templateQ2()</a>, <b>regardless</b> whether the Q-node <code>nodePtr</code> is root of the pertinent subtree or not. The description is somewhat trunkated and should be understood as a stenographic description of the labels of the children of <code>nodePtr</code> when running through the children from one side to the other. Of course we leave the mirror-images out.</p><ul>
<li>full, empty</li>
<li>full, partial, empty</li>
<li>full, partial</li>
<li>partial, empty. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03450">3450</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="aefd5607fec9aaf74d58fb53ddb9883a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd5607fec9aaf74d58fb53ddb9883a7">&#9670;&nbsp;</a></span>templateQ3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateQ3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03558">3558</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a5b7764739dfcfc6d7c956870ccdf0230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7764739dfcfc6d7c956870ccdf0230">&#9670;&nbsp;</a></span>writeGML() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::writeGML </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a5b7764739dfcfc6d7c956870ccdf0230" title="The function writeGML() prints the PQ-tree in the GML fileformat.">writeGML()</a> prints the PQ-tree in the GML fileformat. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l02089">2089</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a98046ca03115c5b2241564f02bf2c257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98046ca03115c5b2241564f02bf2c257">&#9670;&nbsp;</a></span>writeGML() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::writeGML </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l02096">2096</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a75ed08b07f23d14328a91a7ba8bacc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ed08b07f23d14328a91a7ba8bacc7a">&#9670;&nbsp;</a></span>m_identificationNumber</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::m_identificationNumber</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the total number of nodes that have been allocated. </p>
<p>Gives every node that has been used once in the PQ-tree a unique identification number. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00194">194</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="aa1f6f339ca2536e8dd9ebc15a5af8a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f6f339ca2536e8dd9ebc15a5af8a2c">&#9670;&nbsp;</a></span>m_numberOfLeaves</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::m_numberOfLeaves</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the number of leaves. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00197">197</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a0a1a39850b4f51707c6b4609dd45f106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1a39850b4f51707c6b4609dd45f106">&#9670;&nbsp;</a></span>m_pertinentNodes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_list.html">List</a>&lt;<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;*&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::m_pertinentNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores all nodes that have been marked <a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1babbd47109890259c0127154db1af26c75">PQNodeRoot::PQNodeStatus::Full</a> or <a class="el" href="classogdf_1_1_p_q_node_root.html#a7729cc8321784a24f8a9391c11396e1ba44ffd38a6dea695cbe2b34efdcc6cf27">PQNodeRoot::PQNodeStatus::Partial</a> during a reduction. </p>
<p>After the reduction has been finished succesfully, all pertinent nodes are reinitialized and prepared for the next reduction. This list also contains pertinent nodes that have been removed during a reduction. When detected in the stack, their memory is freed. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00207">207</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a52f7382c2c6fcd97da74fa246206375b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f7382c2c6fcd97da74fa246206375b">&#9670;&nbsp;</a></span>m_pertinentRoot</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::m_pertinentRoot</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a pointer to the root of the pertinent subtree. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00184">184</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="afaf037b32f2e61ee0056fb25fd91e536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf037b32f2e61ee0056fb25fd91e536">&#9670;&nbsp;</a></span>m_pseudoRoot</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::m_pseudoRoot</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a pointer to the virtual root of the pertinent subtree, in case that the pertinent root cannot be detected. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00187">187</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a02e0236df8adf9458353c304405a62a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e0236df8adf9458353c304405a62a5">&#9670;&nbsp;</a></span>m_root</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::m_root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a pointer to the root of the $PQ$-tree. </p>

<p class="definition">Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00181">181</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/ogdf/basic/pqtree/<a class="el" href="_p_q_node_8h_source.html">PQNode.h</a></li>
<li>include/ogdf/basic/<a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
 <ul>
  <li class="navelem"><a class="el" href="namespaceogdf.html">ogdf</a></li><li class="navelem"><a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a></li>
  <li class="footer">&copy; 1999&ndash;2022 <a href="http://ogdf.net/team/">The OGDF Team</a></li>
 </ul>
</div>
</body>
</html>
