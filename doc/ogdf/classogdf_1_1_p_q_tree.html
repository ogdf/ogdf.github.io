<!-- HTML header for doxygen 1.8.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>ogdf: ogdf::PQTree&lt; T, X, Y &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="govisual.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogdf-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
  <td align="center">
   <table border="0" cellspacing="0" cellpadding="0">
    <tr>
     <td width="264"><a href="http://www.ogdf.net" title="Go to www.ogdf.net" target="blank"><img  style="border-width: 0px" src="http://www.ogdf.net/lib/images/logoA.png"/></a></td>
     <td align="left"><h1 class="ogdftitle">Open<br>Graph Drawing<br>Framework</h1></td>
        <td align="left" valign="bottom" >
      <span style="font-size:110%; color:rgb(56,95,118)">&nbsp;v.2015.05</span><br>&nbsp;
        </td>
    </tr>
   </table>
  </td>
 </tr>
 <tr>
  <td valign="bottom">
   <div class="menubox">
    <table border="0" cellpadding="0" cellspacing="0" class="menutable">
     <tr>
      <td><a class="menu" href="index.html" title="Start page with overview">Overview</a></td>
      <td><a class="menu" href="hierarchy.html" title="Inheritance hierarchies">Class&nbsp;Hierarchy</a></td>
      <td><a class="menu" href="classes.html" title="Alphabetical list of classes">Class&nbsp;Index</a></td>
      <td><a class="menu" href="annotated.html" title="Classes with brief descriptions">Class&nbsp;List</a></td>
      <td><a class="menu" href="functions.html" title="Complete list of member functions, enumerations, and variables">Members</a></td>
      <td><a class="menu" href="namespaces.html" title="Namespaces with brief descriptions">Namespaces</a></td>
      <td><a class="menu" href="files.html" title="Complete list of files with brief descriptions">Source&nbsp;Files</a></td>
          <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
     </tr>
    </table>
   </div><br>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classogdf_1_1_p_q_tree.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classogdf_1_1_p_q_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ogdf::PQTree&lt; T, X, Y &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_p_q_node_8h_source.html">ogdf/internal/planarity/PQNode.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a06a066a75771df90f15ce2e0158bc031"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a06a066a75771df90f15ce2e0158bc031">PQTree</a> ()</td></tr>
<tr class="separator:a06a066a75771df90f15ce2e0158bc031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3800a1ed72a5297db2ab308e17c825a9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a3800a1ed72a5297db2ab308e17c825a9">~PQTree</a> ()</td></tr>
<tr class="separator:a3800a1ed72a5297db2ab308e17c825a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f895506628443420de4d9d0c05ab220"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a2f895506628443420de4d9d0c05ab220">addNewLeavesToTree</a> (<a class="el" href="classogdf_1_1_p_q_internal_node.html">PQInternalNode</a>&lt; T, X, Y &gt; *father, <a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; *&gt; &amp;leafKeys)</td></tr>
<tr class="separator:a2f895506628443420de4d9d0c05ab220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52db9d9ca5b62ec0a3edbe171624d6e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#ab52db9d9ca5b62ec0a3edbe171624d6e">CleanNode</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *)</td></tr>
<tr class="separator:ab52db9d9ca5b62ec0a3edbe171624d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f30510581fac9c24be3fce6b0b4b82d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a4f30510581fac9c24be3fce6b0b4b82d">Cleanup</a> ()</td></tr>
<tr class="separator:a4f30510581fac9c24be3fce6b0b4b82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3622dd2eb4a98178f63f13a6d452fb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#aad3622dd2eb4a98178f63f13a6d452fb">clientDefinedEmptyNode</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="separator:aad3622dd2eb4a98178f63f13a6d452fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cca4fcb55736c826a9ddd5802302c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a88cca4fcb55736c826a9ddd5802302c8">emptyAllPertinentNodes</a> ()</td></tr>
<tr class="separator:a88cca4fcb55736c826a9ddd5802302c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76af348fc7bc262e6f229f06d936cfaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a76af348fc7bc262e6f229f06d936cfaf">emptyNode</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="separator:a76af348fc7bc262e6f229f06d936cfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3dfb30f8db95403c61bbec97069e0d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a0f3dfb30f8db95403c61bbec97069e0d">front</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr, <a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; *&gt; &amp;leafKeys)</td></tr>
<tr class="separator:a0f3dfb30f8db95403c61bbec97069e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e22e7b7174465082a0326f89cbeb06b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a1e22e7b7174465082a0326f89cbeb06b">Initialize</a> (<a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; *&gt; &amp;leafKeys)</td></tr>
<tr class="separator:a1e22e7b7174465082a0326f89cbeb06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789fbcb7d4db382f6620b785325e70c5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a789fbcb7d4db382f6620b785325e70c5">Reduction</a> (<a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; *&gt; &amp;leafKeys)</td></tr>
<tr class="separator:a789fbcb7d4db382f6620b785325e70c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e347a727d31d264246a0a51e2a82af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a03e347a727d31d264246a0a51e2a82af">root</a> () const</td></tr>
<tr class="separator:a03e347a727d31d264246a0a51e2a82af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7764739dfcfc6d7c956870ccdf0230"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a5b7764739dfcfc6d7c956870ccdf0230">writeGML</a> (const char *fileName)</td></tr>
<tr class="separator:a5b7764739dfcfc6d7c956870ccdf0230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37530cf5088cc5f7edb8063a45495756"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a37530cf5088cc5f7edb8063a45495756">writeGML</a> (ostream &amp;os)</td></tr>
<tr class="separator:a37530cf5088cc5f7edb8063a45495756"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a78fa49ce4ad7cb1f0d5d31919d34a4bc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a78fa49ce4ad7cb1f0d5d31919d34a4bc">addNodeToNewParent</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *parent, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *child)</td></tr>
<tr class="separator:a78fa49ce4ad7cb1f0d5d31919d34a4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bf5f7e4ecfd0d7a1a28557c0b5d328"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a46bf5f7e4ecfd0d7a1a28557c0b5d328">addNodeToNewParent</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *parent, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *child, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *leftBrother, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *rightBrother)</td></tr>
<tr class="separator:a46bf5f7e4ecfd0d7a1a28557c0b5d328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5980fd70b9dbe14b2b09de22319761"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#ace5980fd70b9dbe14b2b09de22319761">Bubble</a> (<a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; *&gt; &amp;leafKeys)</td></tr>
<tr class="separator:ace5980fd70b9dbe14b2b09de22319761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a0040240c4da107e76844e86fe5954"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a70a0040240c4da107e76844e86fe5954">checkIfOnlyChild</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *child, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *parent)</td></tr>
<tr class="separator:a70a0040240c4da107e76844e86fe5954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4692a762c6c42cac7c1f026954c348"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a2d4692a762c6c42cac7c1f026954c348">clientLeftEndmost</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr) const</td></tr>
<tr class="separator:a2d4692a762c6c42cac7c1f026954c348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea906aa316225fa43a62408393ed718"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a7ea906aa316225fa43a62408393ed718">clientNextSib</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *other) const</td></tr>
<tr class="separator:a7ea906aa316225fa43a62408393ed718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab9b850b03485163d66e9ead0b8e70a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a9ab9b850b03485163d66e9ead0b8e70a">clientPrintNodeCategorie</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="separator:a9ab9b850b03485163d66e9ead0b8e70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110ddd73ab4993d6fb59404126a93711"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a110ddd73ab4993d6fb59404126a93711">clientPrintStatus</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="separator:a110ddd73ab4993d6fb59404126a93711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8083c97003857dabab2acd6b5fbab8"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a0e8083c97003857dabab2acd6b5fbab8">clientPrintType</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="separator:a0e8083c97003857dabab2acd6b5fbab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da1c0609a58a901350bd4c8f847ee47"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a3da1c0609a58a901350bd4c8f847ee47">clientRightEndmost</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr) const</td></tr>
<tr class="separator:a3da1c0609a58a901350bd4c8f847ee47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a83bf0154c5bb150834ad8a60bc2719"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a8a83bf0154c5bb150834ad8a60bc2719">clientSibLeft</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr) const</td></tr>
<tr class="separator:a8a83bf0154c5bb150834ad8a60bc2719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef18d897994c45d983280421467ccef"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a0ef18d897994c45d983280421467ccef">clientSibRight</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr) const</td></tr>
<tr class="separator:a0ef18d897994c45d983280421467ccef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162069c126ebf888585fb39fa833c65c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a162069c126ebf888585fb39fa833c65c">destroyNode</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="separator:a162069c126ebf888585fb39fa833c65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cce16d012eb159eb8dc191d17e9aa6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a59cce16d012eb159eb8dc191d17e9aa6">exchangeNodes</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *oldNode, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *newNode)</td></tr>
<tr class="separator:a59cce16d012eb159eb8dc191d17e9aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1920edd68529b710da2775359803d54a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_list.html">List</a>&lt; <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a1920edd68529b710da2775359803d54a">fullChildren</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="separator:a1920edd68529b710da2775359803d54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af746642d3e338f1fa13198dd58c68158"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#af746642d3e338f1fa13198dd58c68158">linkChildrenOfQnode</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *installed, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *newChild)</td></tr>
<tr class="separator:af746642d3e338f1fa13198dd58c68158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111287c97892d05b1a31f9fa4b5e2ec4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_list.html">List</a>&lt; <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a111287c97892d05b1a31f9fa4b5e2ec4">partialChildren</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="separator:a111287c97892d05b1a31f9fa4b5e2ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9389a26c6e8504ae34fddc3b4c5991"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a1e9389a26c6e8504ae34fddc3b4c5991">Reduce</a> (<a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; *&gt; &amp;leafKeys)</td></tr>
<tr class="separator:a1e9389a26c6e8504ae34fddc3b4c5991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9eb0c1fe76d998f4b2906b4af3a1c9f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#ab9eb0c1fe76d998f4b2906b4af3a1c9f">removeChildFromSiblings</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="separator:ab9eb0c1fe76d998f4b2906b4af3a1c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e55e4addaa7de1ffb6e6332fd087892"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a9e55e4addaa7de1ffb6e6332fd087892">removeNodeFromTree</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *parent, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *child)</td></tr>
<tr class="separator:a9e55e4addaa7de1ffb6e6332fd087892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230967681d50f958a8f1318f15e70638"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a230967681d50f958a8f1318f15e70638">templateL1</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr, bool isRoot)</td></tr>
<tr class="separator:a230967681d50f958a8f1318f15e70638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1d21d208da1a620292ff92a101dcf8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a2a1d21d208da1a620292ff92a101dcf8">templateP1</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr, bool isRoot)</td></tr>
<tr class="separator:a2a1d21d208da1a620292ff92a101dcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4660c9511e753585cc5f77106de61e7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#ac4660c9511e753585cc5f77106de61e7">templateP2</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **nodePtr)</td></tr>
<tr class="separator:ac4660c9511e753585cc5f77106de61e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9b472f8e7c6bd35d2741850c7bcaac"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a9b9b472f8e7c6bd35d2741850c7bcaac">templateP3</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="separator:a9b9b472f8e7c6bd35d2741850c7bcaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ac709fa37043f44cbd15386d85b520"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a08ac709fa37043f44cbd15386d85b520">templateP4</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **nodePtr)</td></tr>
<tr class="separator:a08ac709fa37043f44cbd15386d85b520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dc0201fbefa391f83c3d7d28414530"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a59dc0201fbefa391f83c3d7d28414530">templateP5</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="separator:a59dc0201fbefa391f83c3d7d28414530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c29c90e12637a2c1a91a59f67c9c74"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a21c29c90e12637a2c1a91a59f67c9c74">templateP6</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **nodePtr)</td></tr>
<tr class="separator:a21c29c90e12637a2c1a91a59f67c9c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206e9453307cee62d87b915b3f33c036"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a206e9453307cee62d87b915b3f33c036">templateQ1</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr, bool isRoot)</td></tr>
<tr class="separator:a206e9453307cee62d87b915b3f33c036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6839d25d0a5e27cd24f2f3da604b7169"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169">templateQ2</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr, bool isRoot)</td></tr>
<tr class="separator:a6839d25d0a5e27cd24f2f3da604b7169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd5607fec9aaf74d58fb53ddb9883a7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#aefd5607fec9aaf74d58fb53ddb9883a7">templateQ3</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr)</td></tr>
<tr class="separator:aefd5607fec9aaf74d58fb53ddb9883a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a75ed08b07f23d14328a91a7ba8bacc7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a75ed08b07f23d14328a91a7ba8bacc7a">m_identificationNumber</a></td></tr>
<tr class="memdesc:a75ed08b07f23d14328a91a7ba8bacc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the total number of nodes that have been allocated.  <a href="#a75ed08b07f23d14328a91a7ba8bacc7a">More...</a><br /></td></tr>
<tr class="separator:a75ed08b07f23d14328a91a7ba8bacc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f6f339ca2536e8dd9ebc15a5af8a2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#aa1f6f339ca2536e8dd9ebc15a5af8a2c">m_numberOfLeaves</a></td></tr>
<tr class="memdesc:aa1f6f339ca2536e8dd9ebc15a5af8a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the number of leaves.  <a href="#aa1f6f339ca2536e8dd9ebc15a5af8a2c">More...</a><br /></td></tr>
<tr class="separator:aa1f6f339ca2536e8dd9ebc15a5af8a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1a39850b4f51707c6b4609dd45f106"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_list.html">List</a>&lt; <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a0a1a39850b4f51707c6b4609dd45f106">m_pertinentNodes</a></td></tr>
<tr class="separator:a0a1a39850b4f51707c6b4609dd45f106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f7382c2c6fcd97da74fa246206375b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a52f7382c2c6fcd97da74fa246206375b">m_pertinentRoot</a></td></tr>
<tr class="memdesc:a52f7382c2c6fcd97da74fa246206375b"><td class="mdescLeft">&#160;</td><td class="mdescRight">is a pointer to the root of the pertinent subtree.  <a href="#a52f7382c2c6fcd97da74fa246206375b">More...</a><br /></td></tr>
<tr class="separator:a52f7382c2c6fcd97da74fa246206375b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf037b32f2e61ee0056fb25fd91e536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#afaf037b32f2e61ee0056fb25fd91e536">m_pseudoRoot</a></td></tr>
<tr class="memdesc:afaf037b32f2e61ee0056fb25fd91e536"><td class="mdescLeft">&#160;</td><td class="mdescRight">is a pointer to the virtual root of the pertinent subtree, in case that the pertinent root cannot be detected.  <a href="#afaf037b32f2e61ee0056fb25fd91e536">More...</a><br /></td></tr>
<tr class="separator:afaf037b32f2e61ee0056fb25fd91e536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e0236df8adf9458353c304405a62a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a02e0236df8adf9458353c304405a62a5">m_root</a></td></tr>
<tr class="memdesc:a02e0236df8adf9458353c304405a62a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">is a pointer to the root of the $PQ$-tree.  <a href="#a02e0236df8adf9458353c304405a62a5">More...</a><br /></td></tr>
<tr class="separator:a02e0236df8adf9458353c304405a62a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a058fd295de75a48d2c0f948f6495cd55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a058fd295de75a48d2c0f948f6495cd55">checkChain</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *firstFull, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **seqStart, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **seqEnd)</td></tr>
<tr class="separator:a058fd295de75a48d2c0f948f6495cd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75513a32b835a71780a48b3c09f90ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#af75513a32b835a71780a48b3c09f90ec">copyFullChildrenToPartial</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *partialChild)</td></tr>
<tr class="separator:af75513a32b835a71780a48b3c09f90ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05f8d5dbb0b13eab4eb9e935eb30b1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#ac05f8d5dbb0b13eab4eb9e935eb30b1a">createNodeAndCopyFullChildren</a> (<a class="el" href="classogdf_1_1_list.html">List</a>&lt; <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&gt; *fullNodes)</td></tr>
<tr class="separator:ac05f8d5dbb0b13eab4eb9e935eb30b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2675188e830c2fb3ed3bf4a26c5223a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a2675188e830c2fb3ed3bf4a26c5223a0">printNode</a> (char *filename, int number, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *father, <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *son)</td></tr>
<tr class="separator:a2675188e830c2fb3ed3bf4a26c5223a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34044dcf871fafe0f85241d0398a9dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a34044dcf871fafe0f85241d0398a9dcb">removeBlock</a> (<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *nodePtr, bool isRoot)</td></tr>
<tr class="separator:a34044dcf871fafe0f85241d0398a9dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0185a60cfe33d6be6e59316695d39f8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classogdf_1_1_p_q_tree.html#a0185a60cfe33d6be6e59316695d39f8a">sortExceptions</a> (int Exceptions[], int arraySize)</td></tr>
<tr class="separator:a0185a60cfe33d6be6e59316695d39f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class X, class Y&gt;<br />
class ogdf::PQTree&lt; T, X, Y &gt;</h3>


<p>Definition at line <a class="el" href="_p_q_node_8h_source.html#l00066">66</a> of file <a class="el" href="_p_q_node_8h_source.html">PQNode.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a06a066a75771df90f15ce2e0158bc031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a066a75771df90f15ce2e0158bc031">&sect;&nbsp;</a></span>PQTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::<a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01397">1397</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a3800a1ed72a5297db2ab308e17c825a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3800a1ed72a5297db2ab308e17c825a9">&sect;&nbsp;</a></span>~PQTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::~<a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function shown here is the destructor of the class template <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a>. In order to free allocated memory, all nodes of the tree have to be deleted, hence their destructors have to be called. This is done in the function <a class="el" href="classogdf_1_1_p_q_tree.html#a4f30510581fac9c24be3fce6b0b4b82d">Cleanup()</a>. Furthermore all other initialized memory has to be freed which is done as well in the function <a class="el" href="classogdf_1_1_p_q_tree.html#a4f30510581fac9c24be3fce6b0b4b82d">Cleanup()</a>. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00086">86</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2f895506628443420de4d9d0c05ab220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f895506628443420de4d9d0c05ab220">&sect;&nbsp;</a></span>addNewLeavesToTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::addNewLeavesToTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_internal_node.html">PQInternalNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>father</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>leafKeys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a2f895506628443420de4d9d0c05ab220">addNewLeavesToTree()</a> adds a set of elements to the already existing set of elements of a PQ-tree. These elements have to be of type <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a> and are handed to the function in an array leafKeys. The father of the new elements that has to be an existing P- or Q-node, has to be specified and is not allowed to have children.</p>
<p>The above mentioned facts are checked by the function <a class="el" href="classogdf_1_1_p_q_tree.html#a78fa49ce4ad7cb1f0d5d31919d34a4bc">addNodeToNewParent()</a> and the process of adding a child to parent is interrupted with an error message returning 0 as soon none of the facts is fullfilled. The function <a class="el" href="classogdf_1_1_p_q_tree.html#a2f895506628443420de4d9d0c05ab220">addNewLeavesToTree()</a> returns 1 if it succeeded in adding the leaves to parent. </p>
<p>Enter the first element as <a class="el" href="classogdf_1_1_p_q_leaf.html">PQLeaf</a> to the [[parent]].</p>
<p>Enter all other elements as leaves to [[parent]].</p>
<p>Set the reference pointers if [[parent]] is a $P$-node.</p>
<p>Set the endmost children if [[parent is a $Q$-node. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00310">310</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a78fa49ce4ad7cb1f0d5d31919d34a4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fa49ce4ad7cb1f0d5d31919d34a4bc">&sect;&nbsp;</a></span>addNodeToNewParent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::addNodeToNewParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a78fa49ce4ad7cb1f0d5d31919d34a4bc">addNodeToNewParent()</a> adds a node <em>child</em> as a child to another node specified in <em>parent</em>. The <em>parent</em> of the new node has to be an existing P- or Q-node and is <b>not</b> allowed to have children. In the case, that <em>parent</em> has children, addNewNodeToParent() returns 0 printing an error-message. In this case, use the function addNodeToParent() while specifying the future siblings of <em>child</em>. See addNodeToNewParent2() for more details.</p>
<p>After successfully inserting <em>child</em> to <em>parent</em> the function addNewNodeToParent() returns 1. Otherwise it returns 0. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00386">386</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a46bf5f7e4ecfd0d7a1a28557c0b5d328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46bf5f7e4ecfd0d7a1a28557c0b5d328">&sect;&nbsp;</a></span>addNodeToNewParent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::addNodeToNewParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>leftBrother</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>rightBrother</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a78fa49ce4ad7cb1f0d5d31919d34a4bc">addNodeToNewParent()</a> adds a node <em>child</em> to the children of another node specified in <em>parent</em>. The <em>parent</em> of the new node has to be an existing P- or Q-node and is allowed to have children. In case that <em>parent</em> has children, the siblings of the new introduced child <b> must be specified</b>. If no siblings are specified, the function <a class="el" href="classogdf_1_1_p_q_tree.html#a78fa49ce4ad7cb1f0d5d31919d34a4bc">addNodeToNewParent(PQNode&lt;T,X,Y&gt;*,PQNode&lt;T,X,Y&gt;*)</a> is called by default. If the <em>parent</em> is not specified, the function assumes that <em>child</em> is added as interior child to a Q-node.</p>
<p>The client of this function should observe the following facts:</p><ul>
<li>If <em>parent</em> is a P-node, than only one sibling is needed in order to enter the <em>child</em>. If the client specifies two siblings in <em>leftBrother</em> and <em>rightBrother</em>, then an arbitrary one is choosen to be a sibling.</li>
<li>If <em>parent</em> is a Q-node, two siblings <b>must be specified</b> if <em>child</em> has to become an interior child of the Q-node. If just one sibling is specified, this implies that <em>child</em> is about to become a new endmost child of <em>parent</em>. So either <em>leftBrother</em> or <em>rightBrother</em> must store an existing endmost child of <em>parent</em>.</li>
<li>If <em>parent</em> is a zero pointer, addNodeToNewParents() assumes that <em>child</em> is added as interior child to a Q-node. In this case <b>both</b> siblings of <em>child</em> <b>have to be specified</b>. Observe however, that it is also legal to specify the parent in this case.</li>
</ul>
<p>The above mentioned facts are checked by the function <a class="el" href="classogdf_1_1_p_q_tree.html#a78fa49ce4ad7cb1f0d5d31919d34a4bc">addNodeToNewParent()</a> and the process of adding a child to <em>parent</em> is interrupted with an error message returning 0 as soon none of the facts is fullfilled. The function <a class="el" href="classogdf_1_1_p_q_tree.html#a78fa49ce4ad7cb1f0d5d31919d34a4bc">addNodeToNewParent()</a> returns 1 if it succeeded in adding the <em>child</em> to <em>parent</em>. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00466">466</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="ace5980fd70b9dbe14b2b09de22319761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5980fd70b9dbe14b2b09de22319761">&sect;&nbsp;</a></span>Bubble()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::Bubble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>leafKeys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#ace5980fd70b9dbe14b2b09de22319761">Bubble()</a> realizes a function described in [Booth]. It <em>bubbles</em> up from the pertinent leaves to the pertinent root in order to make sure that every pertinent node in the pertinent subtree has a valid pointer to its parent. If <a class="el" href="classogdf_1_1_p_q_tree.html#ace5980fd70b9dbe14b2b09de22319761">Bubble()</a> does not succed in doing so, then the set of elements, stored in the <em>leafKeys</em> cannot form a consecutive sequence.</p>
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#ace5980fd70b9dbe14b2b09de22319761">Bubble()</a> uses a wide variaty of variables, explained in detail below.</p><ul>
<li><em>blockcount</em> is the number of blocks of blocked nodes during the bubbling up phase.</li>
<li><em>numBlocked</em> is the number of blocked nodes during the bubbling up phase.</li>
<li><em>blockedSiblings</em> counts the number of blocked siblings that are adjacent to <em>checkNode</em>. A node has 0, 1 or 2 blocked siblings. A child of a P-node has no blocked siblings. Endmost children of Q-nodes have at most 1 blocked sibling. The interior children of a Q-Node have at most 2 blocked siblings.</li>
<li><em>checkLeaf</em> is a pointer used for finding the pertinent leaves.</li>
<li><em>checkNode</em> is a pointer to the actual node.</li>
<li><em>checkSib</em> is a pointer used to examin the siblings of [[checkNode]].</li>
<li><em>offTheTop</em> is a variable which is either 0 (that is its initial value) or 1 in case that the root of the tree has been process during the first phase.</li>
<li><em>parent</em> is a pointer to the parent of <em>checkNode</em>, if <em>checkNode</em> has a valid parent pointer.</li>
<li><em>processNodes</em> is a first-in first-out list that is used for sequencing the order in which the nodes are processed.</li>
<li><em>blockedNodes</em> is a stack storing all nodes that have been once blocked. In case that the [[m_pseudoRoot]] has to be introduced, the stack contains the blocked nodes. </li>
</ul>

<p>Reimplemented in <a class="el" href="classogdf_1_1_max_sequence_p_q_tree.html#a9805faf4fb6286e49d4dc2e0167ca415">ogdf::MaxSequencePQTree&lt; T, Y &gt;</a>, and <a class="el" href="classogdf_1_1_max_sequence_p_q_tree.html#a9805faf4fb6286e49d4dc2e0167ca415">ogdf::MaxSequencePQTree&lt; edge, bool &gt;</a>.</p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00692">692</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a058fd295de75a48d2c0f948f6495cd55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058fd295de75a48d2c0f948f6495cd55">&sect;&nbsp;</a></span>checkChain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::checkChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>firstFull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **&#160;</td>
          <td class="paramname"><em>seqStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **&#160;</td>
          <td class="paramname"><em>seqEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a058fd295de75a48d2c0f948f6495cd55">checkChain()</a> is used by the function <a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169">templateQ2()</a> and <a class="el" href="classogdf_1_1_p_q_tree.html#aefd5607fec9aaf74d58fb53ddb9883a7">templateQ3()</a>. It checks whether all full children of a Q-node <em>nodePtr</em> form a consecutive sequence. If the full nodes do so, the procedure returns 1 as a result, otherwise 0.</p>
<p>The pointer <em>firstFull</em> denotes just an arbirtary full child. Starting from this position, checkChain sweeps through the consecutive sequence, halting as soon as a nonfull child is detected. The two pointers <em>seqStart</em> and <em>seqEnd</em> are set within the function <em>checkChain</em>. They denote the first and last node of the consecutive sequence.</p>
<p>The client should observe that it is not possible to avoid the use of such a function. According to the procedure <a class="el" href="classogdf_1_1_p_q_tree.html#ace5980fd70b9dbe14b2b09de22319761">Bubble()</a> children of Q-nodes get unblocked as soon as they are adjacent to any pertinent sibling. This includes that chains of more than two partial children are regarded as unblocked as well. Such chains are of course not reducible and therefore have to be detected by the function <a class="el" href="classogdf_1_1_p_q_tree.html#a058fd295de75a48d2c0f948f6495cd55">checkChain()</a>.</p>
<p>Following we give an overview of the variables used in <a class="el" href="classogdf_1_1_p_q_tree.html#a058fd295de75a48d2c0f948f6495cd55">checkChain()</a>.</p><ul>
<li><em>fullCount</em> counts the number of children that are discovered by the function <a class="el" href="classogdf_1_1_p_q_tree.html#a058fd295de75a48d2c0f948f6495cd55">checkChain()</a>. This is necessary, since <a class="el" href="classogdf_1_1_p_q_tree.html#a058fd295de75a48d2c0f948f6495cd55">checkChain()</a> is used by two template matching functions <a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169">templateQ2()</a> and <a class="el" href="classogdf_1_1_p_q_tree.html#aefd5607fec9aaf74d58fb53ddb9883a7">templateQ3()</a> where in the latter case the pointer <em>firstFull</em> may point to any full child in the front of the Q-node <em>nodePtr</em>.</li>
<li><em>notFull</em> is set 1 when an empty child is encountered.</li>
<li><em>checkNode</em> is the actual node that is examined.</li>
<li><em>leftNext</em> is the next node that has to be examined on the left side of <em>firstFull</em>.</li>
<li><em>leftOld</em> is the node that has been examined right before <em>checkNode</em> on the left side of <em>firstFull</em>.</li>
<li><em>rightNext</em> is the next node that has to be examined on the right side of <em>firstFull</em>. Not needed when <a class="el" href="classogdf_1_1_p_q_tree.html#a058fd295de75a48d2c0f948f6495cd55">checkChain()</a> was called by <a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169">templateQ2()</a>.</li>
<li><em>rightOld</em> is the node that has been examined right before <em>checkNode</em> on the right side of <em>firstFull</em>. Not needed when <a class="el" href="classogdf_1_1_p_q_tree.html#a058fd295de75a48d2c0f948f6495cd55">checkChain()</a> was called by <a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169">templateQ2()</a>. </li>
</ul>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01010">1010</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a70a0040240c4da107e76844e86fe5954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a0040240c4da107e76844e86fe5954">&sect;&nbsp;</a></span>checkIfOnlyChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::checkIfOnlyChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a70a0040240c4da107e76844e86fe5954">checkIfOnlyChild()</a> checks if <em>child</em> is the only child of <em>parent</em>. If so, <em>child</em> is connected to its grandparent, as long as parent is not the root of the tree. In case that <em>parent</em> is the root of the tree and <em>child</em> is its only child, the node <em>child</em> becomes the new root of the tree. The parent then is completely removed from the tree and destroyd. The return value of the method <a class="el" href="classogdf_1_1_p_q_tree.html#a70a0040240c4da107e76844e86fe5954">checkIfOnlyChild()</a> is 1, if <em>child</em> was the only child of parent. Otherwise the return value is 0. Before applying the function <a class="el" href="classogdf_1_1_p_q_tree.html#a59cce16d012eb159eb8dc191d17e9aa6">exchangeNodes()</a>, the function <a class="el" href="classogdf_1_1_p_q_tree.html#ab9eb0c1fe76d998f4b2906b4af3a1c9f">removeChildFromSiblings()</a> is applied. This is usefull in case the node <em>parent</em> has some ignored children and has to be reused within some extra algorithmic context. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01144">1144</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="ab52db9d9ca5b62ec0a3edbe171624d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52db9d9ca5b62ec0a3edbe171624d6e">&sect;&nbsp;</a></span>CleanNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::CleanNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classogdf_1_1_max_sequence_p_q_tree.html#a8c1cf0cb9bf8641f599532a19d0c2ff8">ogdf::MaxSequencePQTree&lt; T, Y &gt;</a>, and <a class="el" href="classogdf_1_1_max_sequence_p_q_tree.html#a8c1cf0cb9bf8641f599532a19d0c2ff8">ogdf::MaxSequencePQTree&lt; edge, bool &gt;</a>.</p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00098">98</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a4f30510581fac9c24be3fce6b0b4b82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f30510581fac9c24be3fce6b0b4b82d">&sect;&nbsp;</a></span>Cleanup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::Cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a4f30510581fac9c24be3fce6b0b4b82d">Cleanup()</a> removes the entire PQ-tree, stored in the class template <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a>. The function <a class="el" href="classogdf_1_1_p_q_tree.html#a4f30510581fac9c24be3fce6b0b4b82d">Cleanup()</a> is called by the destructor of the class template <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a>. It scans all nodes of the tree and frees the memory used by the tree. <a class="el" href="classogdf_1_1_p_q_tree.html#a4f30510581fac9c24be3fce6b0b4b82d">Cleanup()</a> includes the removal of the memory allocated by the following datastructures:</p><ul>
<li><em>m_root</em>,</li>
<li><em>m_pseudoRoot</em>,</li>
<li><em>m_pertinentNodes</em>. The function <a class="el" href="classogdf_1_1_p_q_tree.html#a4f30510581fac9c24be3fce6b0b4b82d">Cleanup()</a> enables the client to reuse the function <a class="el" href="classogdf_1_1_p_q_tree.html#a1e22e7b7174465082a0326f89cbeb06b">Initialize()</a>.</li>
</ul>
<p>In order to free the allocated memory, all nodes of the tree have to be deleted, hence there destructors are called. In order to achieve this, we start at the root of the tree and go down the tree to the leaves for reaching every node. When a node is processed, (besides the <em>m_root</em>, this will always be the node <em>checkNode</em>) the pointers of all its children are stored in a queue <em>helpqueue</em> and then the processed node is deleted.</p>
<p>The use of a queue <em>helpqueue</em> is a must, since the nodes do not have pointers to all of their children, as the children mostly do not have a pointer to their parent.</p>
<p>It might look weird at the first glance that the function <a class="el" href="classogdf_1_1_p_q_tree.html#a4f30510581fac9c24be3fce6b0b4b82d">Cleanup()</a> calls the function <a class="el" href="classogdf_1_1_p_q_tree.html#a88cca4fcb55736c826a9ddd5802302c8">emptyAllPertinentNodes()</a>, but if some nodes were removed during a reduction, they were stored in the stack <em>m_pertinentNodes</em>. These nodes have to be deleted as well which is provided by the function <a class="el" href="classogdf_1_1_p_q_tree.html#a88cca4fcb55736c826a9ddd5802302c8">emptyAllPertinentNodes()</a>. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01207">1207</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="aad3622dd2eb4a98178f63f13a6d452fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3622dd2eb4a98178f63f13a6d452fb">&sect;&nbsp;</a></span>clientDefinedEmptyNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::clientDefinedEmptyNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the user wishes to use different flags in a derived class of <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> that are not available in this implementation, he can overload the function <a class="el" href="classogdf_1_1_p_q_tree.html#aad3622dd2eb4a98178f63f13a6d452fb">clientDefinedEmptyNode()</a> in order to make a valid cleanup of the nodes. It will be called per default by the function <a class="el" href="classogdf_1_1_p_q_tree.html#a88cca4fcb55736c826a9ddd5802302c8">emptyAllPertinentNodes()</a>. </p>

<p>Reimplemented in <a class="el" href="classogdf_1_1_max_sequence_p_q_tree.html#afa2cb6e74dff6059954f6c6ed30b432b">ogdf::MaxSequencePQTree&lt; T, Y &gt;</a>, <a class="el" href="classogdf_1_1_max_sequence_p_q_tree.html#afa2cb6e74dff6059954f6c6ed30b432b">ogdf::MaxSequencePQTree&lt; edge, bool &gt;</a>, and <a class="el" href="classogdf_1_1_embed_p_q_tree.html#a5a549047f3c5cb867047a019d9c8967a">ogdf::EmbedPQTree</a>.</p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00108">108</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a2d4692a762c6c42cac7c1f026954c348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4692a762c6c42cac7c1f026954c348">&sect;&nbsp;</a></span>clientLeftEndmost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::clientLeftEndmost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classogdf_1_1_embed_p_q_tree.html#abe4d8be599dd66701392c0639c024e9b">ogdf::EmbedPQTree</a>.</p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00235">235</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a7ea906aa316225fa43a62408393ed718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea906aa316225fa43a62408393ed718">&sect;&nbsp;</a></span>clientNextSib()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::clientNextSib </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classogdf_1_1_embed_p_q_tree.html#adbc7694e536d010dfcc4201b6e8768a3">ogdf::EmbedPQTree</a>.</p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00243">243</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a9ab9b850b03485163d66e9ead0b8e70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab9b850b03485163d66e9ead0b8e70a">&sect;&nbsp;</a></span>clientPrintNodeCategorie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::clientPrintNodeCategorie </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the user wishes to use different flags in a derived class of <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> that are not available in this implementation, he can overload the function <a class="el" href="classogdf_1_1_p_q_tree.html#a9ab9b850b03485163d66e9ead0b8e70a">clientPrintNodeCategorie()</a>. This function is called per default by the functions printOutCurrentTree() and <a class="el" href="classogdf_1_1_p_q_tree.html#a2675188e830c2fb3ed3bf4a26c5223a0">printNode()</a>. With the help of this function it is possible to influence the layout of the nodes by using new, different lables depicting node categories in the <em>Tree Interface</em>. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01343">1343</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a110ddd73ab4993d6fb59404126a93711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110ddd73ab4993d6fb59404126a93711">&sect;&nbsp;</a></span>clientPrintStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::clientPrintStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the user wishes to use different status in a derived class of <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> that are not available in this implementation, he can overload the function <a class="el" href="classogdf_1_1_p_q_tree.html#a110ddd73ab4993d6fb59404126a93711">clientPrintStatus()</a>. This function is called per default by the functions printOutCurrentTree() and <a class="el" href="classogdf_1_1_p_q_tree.html#a2675188e830c2fb3ed3bf4a26c5223a0">printNode()</a>. With the help of this function it is possible to influence the information stored at nodes in the <em>Tree Interface</em> that concern the status of a node. </p>

<p>Reimplemented in <a class="el" href="classogdf_1_1_embed_p_q_tree.html#ac6fbb6ca7bc9b467599e3befa4205455">ogdf::EmbedPQTree</a>.</p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01365">1365</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a0e8083c97003857dabab2acd6b5fbab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8083c97003857dabab2acd6b5fbab8">&sect;&nbsp;</a></span>clientPrintType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::clientPrintType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the user wishes to use different types in a derived class of <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> that are not available in this implementation, he can overload the function <a class="el" href="classogdf_1_1_p_q_tree.html#a0e8083c97003857dabab2acd6b5fbab8">clientPrintType()</a>. This function is called per default by the functions printOutCurrentTree() and <a class="el" href="classogdf_1_1_p_q_tree.html#a2675188e830c2fb3ed3bf4a26c5223a0">printNode()</a>. With the help of this function it is possible to influence the information stored at nodes in the <em>Tree Interface</em> that concern the type of a node. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01386">1386</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a3da1c0609a58a901350bd4c8f847ee47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da1c0609a58a901350bd4c8f847ee47">&sect;&nbsp;</a></span>clientRightEndmost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::clientRightEndmost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classogdf_1_1_embed_p_q_tree.html#adc506ed7aa10d34740ed003fe8fc0061">ogdf::EmbedPQTree</a>.</p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00239">239</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a8a83bf0154c5bb150834ad8a60bc2719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a83bf0154c5bb150834ad8a60bc2719">&sect;&nbsp;</a></span>clientSibLeft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::clientSibLeft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classogdf_1_1_embed_p_q_tree.html#aff96d4c6f94c751ed2a56380a71dc16b">ogdf::EmbedPQTree</a>.</p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00248">248</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a0ef18d897994c45d983280421467ccef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef18d897994c45d983280421467ccef">&sect;&nbsp;</a></span>clientSibRight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::clientSibRight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classogdf_1_1_embed_p_q_tree.html#a73e84c23b9db889b7bccb2e88353fd1b">ogdf::EmbedPQTree</a>.</p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00252">252</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="af75513a32b835a71780a48b3c09f90ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75513a32b835a71780a48b3c09f90ec">&sect;&nbsp;</a></span>copyFullChildrenToPartial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::copyFullChildrenToPartial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>partialChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#af75513a32b835a71780a48b3c09f90ec">copyFullChildrenToPartial()</a> copies all full children of <em>nodePtr</em> to a new P-node The node <em>nodePtr</em> has to be a P-node. The new P-node is added to <em>partialChild</em> as an endmost child of <em>partialChild</em>. The node <em>partialChild</em> has to be a Q-node and the new P-node is added to the side of <em>partialChild</em> where the pertinent children are.</p>
<p>The new P-node is allocated by this function and referenced by the variable <em>newNode</em>.</p>
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#af75513a32b835a71780a48b3c09f90ec">copyFullChildrenToPartial()</a> is used by the functions <a class="el" href="classogdf_1_1_p_q_tree.html#a08ac709fa37043f44cbd15386d85b520">templateP4()</a>, <a class="el" href="classogdf_1_1_p_q_tree.html#a59dc0201fbefa391f83c3d7d28414530">templateP5()</a>, and <a class="el" href="classogdf_1_1_p_q_tree.html#a21c29c90e12637a2c1a91a59f67c9c74">templateP6()</a>. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01431">1431</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="ac05f8d5dbb0b13eab4eb9e935eb30b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05f8d5dbb0b13eab4eb9e935eb30b1a">&sect;&nbsp;</a></span>createNodeAndCopyFullChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; * <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::createNodeAndCopyFullChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_list.html">List</a>&lt; <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&gt; *&#160;</td>
          <td class="paramname"><em>fullNodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#ac05f8d5dbb0b13eab4eb9e935eb30b1a">createNodeAndCopyFullChildren()</a> copies the full children of a P-node that are stored in the stack <em>fullNodes</em> to a new P-node. This new P-node is created by the function and stored in <em>newNode</em> if there is more than one full child. If there is just one full child, it is not necessary to construct a new P-node and the full child is stored in <em>newNode</em>. The <em>newNode</em> is the return value of the procedure.</p>
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#ac05f8d5dbb0b13eab4eb9e935eb30b1a">createNodeAndCopyFullChildren()</a> is used by <a class="el" href="classogdf_1_1_p_q_tree.html#ac4660c9511e753585cc5f77106de61e7">templateP2()</a> <a class="el" href="classogdf_1_1_p_q_tree.html#a9b9b472f8e7c6bd35d2741850c7bcaac">templateP3()</a> and the function <a class="el" href="classogdf_1_1_p_q_tree.html#af75513a32b835a71780a48b3c09f90ec">copyFullChildrenToPartial()</a>. The function <a class="el" href="classogdf_1_1_p_q_tree.html#ac05f8d5dbb0b13eab4eb9e935eb30b1a">createNodeAndCopyFullChildren()</a> uses the following variables.</p><ul>
<li><em>newNode</em> stores the adress of the new allocated P-node or the adress of the only full child.</li>
<li><em>oldSon</em> is a variable used for adding the full nodes as children to the new P-node.</li>
<li><em>firstSon</em> stores the adress of the first detected full child. It is needed for adding the full nodes as children to the new P-node.</li>
<li><em>checkSon</em> is a variable used for adding the full nodes as children to the new P-node.</li>
<li><em>newPQnode</em> is used for proper allocation of the new P-node. </li>
</ul>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01501">1501</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a162069c126ebf888585fb39fa833c65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162069c126ebf888585fb39fa833c65c">&sect;&nbsp;</a></span>destroyNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::destroyNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a162069c126ebf888585fb39fa833c65c">destroyNode()</a> marks a node as TO_BE_DELETED. This enables the function <a class="el" href="classogdf_1_1_p_q_tree.html#a88cca4fcb55736c826a9ddd5802302c8">emptyAllPertinentNodes()</a> to remove the node and free its memory. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00207">207</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a88cca4fcb55736c826a9ddd5802302c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cca4fcb55736c826a9ddd5802302c8">&sect;&nbsp;</a></span>emptyAllPertinentNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::emptyAllPertinentNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a88cca4fcb55736c826a9ddd5802302c8">emptyAllPertinentNodes()</a> has to be called after a reduction has been processed. In cleans up all flags that have been set in the pertinent nodes during the reduction process. All pertinent nodes have been stored in the private member stack <em>m_pertinentNodes</em> of the class template <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> during the <a class="el" href="classogdf_1_1_p_q_tree.html#ace5980fd70b9dbe14b2b09de22319761">Bubble()</a>-phase or when processing one of the templates (see <a class="el" href="classogdf_1_1_p_q_tree.html#a230967681d50f958a8f1318f15e70638">templateL1()</a> to <a class="el" href="classogdf_1_1_p_q_tree.html#aefd5607fec9aaf74d58fb53ddb9883a7">templateQ3()</a>). </p>

<p>Reimplemented in <a class="el" href="classogdf_1_1_max_sequence_p_q_tree.html#ab53f5e88734def785e5473ff14b0e493">ogdf::MaxSequencePQTree&lt; T, Y &gt;</a>, <a class="el" href="classogdf_1_1_max_sequence_p_q_tree.html#ab53f5e88734def785e5473ff14b0e493">ogdf::MaxSequencePQTree&lt; edge, bool &gt;</a>, <a class="el" href="classogdf_1_1_embed_p_q_tree.html#abb7c296335ec639e3cb515f119f8cddb">ogdf::EmbedPQTree</a>, and <a class="el" href="classogdf_1_1_planar_p_q_tree.html#aa53c267ca58e5c2a91576f44bafd3637">ogdf::PlanarPQTree</a>.</p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01587">1587</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a76af348fc7bc262e6f229f06d936cfaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76af348fc7bc262e6f229f06d936cfaf">&sect;&nbsp;</a></span>emptyNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::emptyNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The funtion <a class="el" href="classogdf_1_1_p_q_tree.html#a76af348fc7bc262e6f229f06d936cfaf">emptyNode()</a> cleans up all stacks, flags and pointers of a pertinent node that has been visited during the reduction process. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01636">1636</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a59cce16d012eb159eb8dc191d17e9aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59cce16d012eb159eb8dc191d17e9aa6">&sect;&nbsp;</a></span>exchangeNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::exchangeNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>oldNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>newNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a59cce16d012eb159eb8dc191d17e9aa6">exchangeNodes()</a> replaces the <em>oldNode</em> by the <em>newNode</em> in the tree. This is a function used very often in the template matchings, normally in combination with the construction of a new node which has to conquer the place of an existing node in the tree.</p>
<p>This function can be used in all cases, so the parent of <em>oldNode</em> is allowed to be either a Q-node or a P-node and <em>oldNode</em> may be any child of its parent.</p>
<p>The client should observe, that this function does <b>not</b> reset the pointer <em>m_root</em>. If necessary, this has to be done explicitly by the client himself. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01667">1667</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a0f3dfb30f8db95403c61bbec97069e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3dfb30f8db95403c61bbec97069e0d">&sect;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>leafKeys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a0f3dfb30f8db95403c61bbec97069e0d">front()</a> returns the keys stored in the leaves of the front of <em>nodePtr</em>. A specified node <em>nodePtr</em> of the PQ-tree is handed to the function and <a class="el" href="classogdf_1_1_p_q_tree.html#a0f3dfb30f8db95403c61bbec97069e0d">front()</a> detects the leaves in the front of this node returning the elements represented by the leaves. These elements are stored in an array of keys named <em>leafKeys</em>. The return value is the numbers of leaves that have been detected. Observe that <a class="el" href="classogdf_1_1_p_q_tree.html#a0f3dfb30f8db95403c61bbec97069e0d">front()</a> uses <em>leafKeys</em>[0] to store the first key. </p>

<p>Reimplemented in <a class="el" href="classogdf_1_1_embed_p_q_tree.html#a8bd6a76635b88a75859b7cfabca7dd5a">ogdf::EmbedPQTree</a>.</p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01788">1788</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a1920edd68529b710da2775359803d54a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1920edd68529b710da2775359803d54a">&sect;&nbsp;</a></span>fullChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_list.html">List</a>&lt;<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;*&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::fullChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00226">226</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a1e22e7b7174465082a0326f89cbeb06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e22e7b7174465082a0326f89cbeb06b">&sect;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>leafKeys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a1e22e7b7174465082a0326f89cbeb06b">Initialize()</a> initializes the PQ-tree with a set of elements. These elements have to be template classes of the class template <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a> and are handed to the function in an array <em>leafKeys</em>. The function constructs the universal PQ-tree. If the <em>numberOfElements</em> &gt; 1, the universal PQ-tree consists of one P-node as root (stored in <em>m_root</em>) and all leaves gathered underneath the P-node, symbolizing all kinds of permutations. If <em>numberOfElements</em> = 1, the universal PQ-tree consists of a single <a class="el" href="classogdf_1_1_p_q_leaf.html">PQLeaf</a>, being the root of the tree.</p>
<p>Observe that the first element has to be stored in <em>leafKeys</em>[0] and the last one in <em>leafKeys</em>[<em>numberOfElements-1</em>]. The function <a class="el" href="classogdf_1_1_p_q_tree.html#a1e22e7b7174465082a0326f89cbeb06b">Initialize()</a> returns 1, if the initialization of the PQ-tree was successful. </p>

<p>Reimplemented in <a class="el" href="classogdf_1_1_planar_subgraph_p_q_tree.html#a65ad10e725800315b3b38d1428ea5555">ogdf::PlanarSubgraphPQTree</a>, <a class="el" href="classogdf_1_1_embed_p_q_tree.html#aab30494ed0d9dd9e9d817f07e2d5e0e3">ogdf::EmbedPQTree</a>, and <a class="el" href="classogdf_1_1_planar_p_q_tree.html#ada328b835894dd2a597be1fe3d660190">ogdf::PlanarPQTree</a>.</p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01856">1856</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="af746642d3e338f1fa13198dd58c68158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af746642d3e338f1fa13198dd58c68158">&sect;&nbsp;</a></span>linkChildrenOfQnode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::linkChildrenOfQnode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>installed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>newChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#af746642d3e338f1fa13198dd58c68158">linkChildrenOfQnode()</a> links the two endmost children of two <b>different</b> Q-nodes via their sibling pointers together. The purpose of doing this is to combine the children of two Q-nodes as children of only one Q-node. This function does not reset the pointers to the endmost children of the Q-node. This has to be done by the client of the function. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01898">1898</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a111287c97892d05b1a31f9fa4b5e2ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111287c97892d05b1a31f9fa4b5e2ec4">&sect;&nbsp;</a></span>partialChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_list.html">List</a>&lt;<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;*&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::partialChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00231">231</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a2675188e830c2fb3ed3bf4a26c5223a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2675188e830c2fb3ed3bf4a26c5223a0">&sect;&nbsp;</a></span>printNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::printNode </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>father</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>son</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e9389a26c6e8504ae34fddc3b4c5991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9389a26c6e8504ae34fddc3b4c5991">&sect;&nbsp;</a></span>Reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::Reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>leafKeys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a1e9389a26c6e8504ae34fddc3b4c5991">Reduce()</a> does the reduction of the pertinent leaves with the help of the template matchings, designed by Booth and Lueker. The reader should observe that this function can only be called after every pertinent node in the pertinent subtree has gotten a valid parent pointer. If this is not the case, the programm will be interrupted by run-time errors such as seqmentation faults. The pertinent nodes can get valid parent pointers by using the function <a class="el" href="classogdf_1_1_p_q_tree.html#ace5980fd70b9dbe14b2b09de22319761">Bubble()</a>. If the function <a class="el" href="classogdf_1_1_p_q_tree.html#ace5980fd70b9dbe14b2b09de22319761">Bubble()</a> returns 1, then it was succesful in giving each pertinent node in the pertinent subtree a valid parent pointer. If the function returns 0, then some nodes do not have a valid parent pointer and the pertinent leaves are not reducable.</p>
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a1e9389a26c6e8504ae34fddc3b4c5991">Reduce()</a> starts with the pertinent leaves and stores them in a queue <em>processNodes</em>. Every time a node is processed, its parent is checked whether all its pertinent children are already processed. If this is the case, the parent is allowed to be processed as well and stored in the queue.</p>
<p>Processing a node means that the function <a class="el" href="classogdf_1_1_p_q_tree.html#a1e9389a26c6e8504ae34fddc3b4c5991">Reduce()</a> tries to apply one of the template matchings. In case that one template matching was successful, the node was reduced and <a class="el" href="classogdf_1_1_p_q_tree.html#a1e9389a26c6e8504ae34fddc3b4c5991">Reduce()</a> tries to reduce the next node. In case that no template matching was successfully applied, the tree is is irreducible. This causes the reduction process to be halted returning 0.</p>
<p>The folllowing variables are used by the function <a class="el" href="classogdf_1_1_p_q_tree.html#a1e9389a26c6e8504ae34fddc3b4c5991">Reduce()</a>.</p><ul>
<li><em>checkLeaf</em> is a pointer to a various <a class="el" href="classogdf_1_1_p_q_leaf.html">PQLeaf</a> of the set of elements that has to be reduced.</li>
<li><em>checkNode</em> is a pointer to a various node of the pertinent subtree.</li>
<li><em>pertLeafCount</em> counts the number of pertinent leaves in the PQ-tree. Since <a class="el" href="classogdf_1_1_p_q_tree.html#a1e9389a26c6e8504ae34fddc3b4c5991">Reduce()</a> takes care that every node knows the number of pertinent leaves in its frontier, the root of the pertinent subtree can be identified with the help of <em>pertLeafCount</em>.</li>
<li><em>processNodes</em> is a queue storing nodes of the pertinent subtree that are considered to be reduced next. A node may be reduced (and therefore is pushed on to <em>processNodes</em>) as soon as all its pertinent children have been reduced. </li>
</ul>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l02186">2186</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a789fbcb7d4db382f6620b785325e70c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789fbcb7d4db382f6620b785325e70c5">&sect;&nbsp;</a></span>Reduction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::Reduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_s_list_pure.html">SListPure</a>&lt; <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>&lt; T, X, Y &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>leafKeys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a789fbcb7d4db382f6620b785325e70c5">Reduction()</a> tests whether permissible permutations of the elements of U exist such that the elements of a subset S of U, stored in <em>leafKeys</em>, form a consecutive sequence. If there exists such a permutation, the PQ-tree is reduced and <a class="el" href="classogdf_1_1_p_q_tree.html#a789fbcb7d4db382f6620b785325e70c5">Reduction()</a> returns 1.</p>
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a789fbcb7d4db382f6620b785325e70c5">Reduction()</a> gets a list <em>leafKeys</em> of pointers to elements of type <a class="el" href="classogdf_1_1_p_q_leaf_key.html">PQLeafKey</a>, representing all elements of S.</p>
<p><a class="el" href="classogdf_1_1_p_q_tree.html#a789fbcb7d4db382f6620b785325e70c5">Reduction()</a> calls the procedure <a class="el" href="classogdf_1_1_p_q_tree.html#ace5980fd70b9dbe14b2b09de22319761">Bubble()</a> and if <a class="el" href="classogdf_1_1_p_q_tree.html#ace5980fd70b9dbe14b2b09de22319761">Bubble()</a> was successful, <a class="el" href="classogdf_1_1_p_q_tree.html#a789fbcb7d4db382f6620b785325e70c5">Reduction()</a> calls the function <a class="el" href="classogdf_1_1_p_q_tree.html#a1e9389a26c6e8504ae34fddc3b4c5991">Reduce()</a>. </p>

<p>Reimplemented in <a class="el" href="classogdf_1_1_planar_subgraph_p_q_tree.html#a6022a6cd9a927470f87fa051ea37ea3a">ogdf::PlanarSubgraphPQTree</a>, <a class="el" href="classogdf_1_1_embed_p_q_tree.html#a91e90b4180ee50a34a097c4235cceee3">ogdf::EmbedPQTree</a>, and <a class="el" href="classogdf_1_1_planar_p_q_tree.html#a8c6a687d43f399d833f977d6dab21626">ogdf::PlanarPQTree</a>.</p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l02291">2291</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a34044dcf871fafe0f85241d0398a9dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34044dcf871fafe0f85241d0398a9dcb">&sect;&nbsp;</a></span>removeBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::removeBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRoot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This chunk contains the procedure removeBlock. It is used by the functions <a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169">templateQ2()</a> and <a class="el" href="classogdf_1_1_p_q_tree.html#aefd5607fec9aaf74d58fb53ddb9883a7">templateQ3()</a>. The node <em>nodePtr</em> is expected to be a Q-node with no, one or at most two partial children, such that the partial and full children of <em>nodePtr</em> form a legal consecutive sequence, hence can be reduced.</p>
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a34044dcf871fafe0f85241d0398a9dcb">removeBlock()</a> does the following: Of every partial node that is found in the sequence of children of <em>nodePtr</em>, all children are removed from that partial node and included as children of <em>nodePtr</em>, occupying the place of the partial node in the sequence of children of <em>nodePtr</em>. Thereby, <a class="el" href="classogdf_1_1_p_q_tree.html#a34044dcf871fafe0f85241d0398a9dcb">removeBlock()</a> takes care, that the newly included full children of <em>nodePtr</em> form a consecutive sequence with the already existing pertinent children of <em>nodePtr</em>. The partial node itself is deleted afterwards. </p>
<p>Pointer to the first partial child </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l02325">2325</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="ab9eb0c1fe76d998f4b2906b4af3a1c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9eb0c1fe76d998f4b2906b4af3a1c9f">&sect;&nbsp;</a></span>removeChildFromSiblings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::removeChildFromSiblings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#ab9eb0c1fe76d998f4b2906b4af3a1c9f">removeChildFromSiblings()</a> removes the node <em>nodePtr</em> from the doubly linked list of its parent. In case that <em>nodePtr</em> is endmost child of an Q-node or child of a P-node equiped with a valid reference pointer <em>referenceParent</em> to its parent (see <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>), these pointers are considered as well and the adjacent siblings of <em>nodePtr</em> have to cover <em>nodePtr's</em> task. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l02905">2905</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a9e55e4addaa7de1ffb6e6332fd087892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e55e4addaa7de1ffb6e6332fd087892">&sect;&nbsp;</a></span>removeNodeFromTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::removeNodeFromTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a9e55e4addaa7de1ffb6e6332fd087892">removeNodeFromTree()</a> has to be handled with great care by the user. This function is not used in any of the functions of the class template <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a> and can only be accessed by inheritance.</p>
<p>Its objective is to remove a node <em>child</em> from the PQ-tree. To do so, the <em>parent</em> of the node <em>child</em> has to be known by the user. To indicate this, the parent has to be handed over by her.</p>
<p><b>This function does not check if <em>parent</em> is the parent node of <em>child</b></em>. This has to be guaranteed by the user. The reason for this riscfull approach lies in the details of the powerful data structure PQ-tree. In order to reach linear runtime, the internal children of a Q-node normally do not have valid parent pointers. So forcing this function to search the parent would cost in worst case linear runtime for one call of the function <a class="el" href="classogdf_1_1_p_q_tree.html#a9e55e4addaa7de1ffb6e6332fd087892">removeNodeFromTree()</a>. Its up to the user to do better.</p>
<p>Calling <a class="el" href="classogdf_1_1_p_q_tree.html#a9e55e4addaa7de1ffb6e6332fd087892">removeNodeFromTree()</a> with a 0-pointer for <em>parent</em>, will always terminate this function with an ERROR-message and returning -1 as value.</p>
<p>The return value is an integer value used to indicate how many children the <em>parent</em> after the removal of <em>child</em> still has. The client should observe that internal nodes in the PQ-tree which have just one or no children at all do not make sense. However, the function <a class="el" href="classogdf_1_1_p_q_tree.html#a9e55e4addaa7de1ffb6e6332fd087892">removeNodeFromTree()</a> <b>does not check if <em>parent</em> has less than two children after the removal of &lt; child</b>. So in case that <em>parent</em> has less than two children, the user has to check this by herself and remove the <em>parent</em>, probably using the function <a class="el" href="classogdf_1_1_p_q_tree.html#a70a0040240c4da107e76844e86fe5954">checkIfOnlyChild()</a>.</p>
<p>There are two reasons why the function <a class="el" href="classogdf_1_1_p_q_tree.html#a9e55e4addaa7de1ffb6e6332fd087892">removeNodeFromTree()</a> does not check if <em>parent</em> has less than two children after the removal of <em>child:</em> </p><ol type="1">
<li>The user might keep the node in the tree in order to add new nodes as children to it.</li>
<li>Again, the parent of <em>parent</em> might not be known to <em>parent</em>, hence removeNodeTree() would have to search, at the cost of linear time consumption, for the parent of <em>parent</em> first before removing <em>parent</em> from the tree.</li>
</ol>
<p>Observe that <a class="el" href="classogdf_1_1_p_q_tree.html#a9e55e4addaa7de1ffb6e6332fd087892">removeNodeFromTree()</a> does not free the allocated memory of <em>child</em>. This has to be done by the user <b>after</b> calling <a class="el" href="classogdf_1_1_p_q_tree.html#a9e55e4addaa7de1ffb6e6332fd087892">removeNodeFromTree()</a>. It also offers the opportunity to reuse deleted nodes. Observe that the identification number of a node <em>m_identificationNumber</em> (see <a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>) cannot be changed. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03021">3021</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a03e347a727d31d264246a0a51e2a82af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e347a727d31d264246a0a51e2a82af">&sect;&nbsp;</a></span>root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a03e347a727d31d264246a0a51e2a82af">root()</a> returns a pointer of the root node of the <a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a>. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00121">121</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a0185a60cfe33d6be6e59316695d39f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0185a60cfe33d6be6e59316695d39f8a">&sect;&nbsp;</a></span>sortExceptions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::sortExceptions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Exceptions</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arraySize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a0185a60cfe33d6be6e59316695d39f8a">sortExceptions()</a> is only called by the function frontExcept(). It sorts the exceptions before frontExcept() scans the frontier. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03050">3050</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a230967681d50f958a8f1318f15e70638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230967681d50f958a8f1318f15e70638">&sect;&nbsp;</a></span>templateL1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateL1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRoot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a230967681d50f958a8f1318f15e70638">templateL1()</a> implements the template matching for leaves. The function requires as input any pointer to a node stored in <em>nodePtr</em>. If the node stored in <em>nodePtr</em> is a <a class="el" href="classogdf_1_1_p_q_leaf.html">PQLeaf</a>, <a class="el" href="classogdf_1_1_p_q_tree.html#a230967681d50f958a8f1318f15e70638">templateL1()</a> considers itself responsible for the node and will apply the template matching for pertinent leaves to <em>nodePtr</em>. If the flag <em>isRoot</em> is set to 1, it signalizes <a class="el" href="classogdf_1_1_p_q_tree.html#a230967681d50f958a8f1318f15e70638">templateL1()</a> that <em>nodePtr</em> is the root of the pertinent subtree. In any other case the flag has to be 0.</p>
<p>If <a class="el" href="classogdf_1_1_p_q_tree.html#a230967681d50f958a8f1318f15e70638">templateL1()</a> was responsible for <em>nodePtr</em> and the reduction was successful, the return value is 1. Otherwise the return value is 0.</p>
<p>The function updates the <em>fullChildren</em> stack of its parent, as long as <em>nodePtr</em> is not the root of the pertinent subtree. Observe that <em>nodePtr</em> needs a valid pointer to its parent. This can be achieved by using the function <a class="el" href="classogdf_1_1_p_q_tree.html#ace5980fd70b9dbe14b2b09de22319761">Bubble()</a> or any other appropriate, user defined function. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03095">3095</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a2a1d21d208da1a620292ff92a101dcf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1d21d208da1a620292ff92a101dcf8">&sect;&nbsp;</a></span>templateP1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateP1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRoot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a2a1d21d208da1a620292ff92a101dcf8">templateP1()</a> implements the template matching for P-nodes with only full children. The function requires as input any pointer to a node stored in <em>nodePtr</em>. If the node stored in <em>nodePtr</em> is a P-node with only full children, <a class="el" href="classogdf_1_1_p_q_tree.html#a2a1d21d208da1a620292ff92a101dcf8">templateP1()</a> considers itself responsible for the node and will apply the template matching for full P-nodes to <em>nodePtr</em>. If the flag <em>isRoot</em> is set to 1, it signalizes <a class="el" href="classogdf_1_1_p_q_tree.html#a2a1d21d208da1a620292ff92a101dcf8">templateP1()</a> that <em>nodePtr</em> is the root of the pertinent subtree. In any other case the flag has to be 0.</p>
<p>If <a class="el" href="classogdf_1_1_p_q_tree.html#a2a1d21d208da1a620292ff92a101dcf8">templateP1()</a> was responsible for <em>nodePtr</em> and the reduction was successful, the return value is 1. Otherwise the return value is 0.</p>
<p>If the P-node is not the root of the pertinent subtree, the <em>fullChildren</em> stack of the parent of <em>nodePtr</em> is updated. If the P-node is the root of the pertinent subtree, nothing has to be done. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03135">3135</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="ac4660c9511e753585cc5f77106de61e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4660c9511e753585cc5f77106de61e7">&sect;&nbsp;</a></span>templateP2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateP2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#ac4660c9511e753585cc5f77106de61e7">templateP2()</a> implements the template matching for a P-node with full <b>and</b> empty children that is the root of the pertinent subtree. The function requires as input any pointer to a node stored in \ nodePtr. If the node stored in <em>nodePtr</em> is a P-node with no partial children, <a class="el" href="classogdf_1_1_p_q_tree.html#ac4660c9511e753585cc5f77106de61e7">templateP2()</a> considers itself responsible for the node and will apply the template matching <b>P2</b> to <em>nodePtr</em>. Observe that the user calling this function has to make sure that <em>nodePtr</em> is partial and is the root of the pertinent subtree.</p>
<p>If <a class="el" href="classogdf_1_1_p_q_tree.html#ac4660c9511e753585cc5f77106de61e7">templateP2()</a> was responsible for <em>nodePtr</em> and the reduction was successful, the return value is 1. Otherwise the return value is 0.</p>
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#ac4660c9511e753585cc5f77106de61e7">templateP2()</a> creates a new full P-node that will be the new root of the pertinent subtree. It then copies all full children from <em>nodePtr</em> to the new root of the pertinent subtree. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03177">3177</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a9b9b472f8e7c6bd35d2741850c7bcaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9b472f8e7c6bd35d2741850c7bcaac">&sect;&nbsp;</a></span>templateP3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateP3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03245">3245</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a08ac709fa37043f44cbd15386d85b520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ac709fa37043f44cbd15386d85b520">&sect;&nbsp;</a></span>templateP4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateP4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a08ac709fa37043f44cbd15386d85b520">templateP4()</a> implements the template matching for a P-node with full, empty and exactly one partial children. The P-node has to be the root of the pertinent subtree. The function requires as input any pointer to a node stored in <em>nodePtr</em>. If the node stored in <em>nodePtr</em> is a P-node with one partial child, <a class="el" href="classogdf_1_1_p_q_tree.html#a08ac709fa37043f44cbd15386d85b520">templateP4()</a> considers itself responsible for the node and will apply the template matching <b>P4</b> to <em>nodePtr</em>. Observe that the user calling this function has to make sure that <em>nodePtr</em> is the root of the pertinent subtree.</p>
<p>If <a class="el" href="classogdf_1_1_p_q_tree.html#a08ac709fa37043f44cbd15386d85b520">templateP4()</a> was responsible for <em>nodePtr</em> and the reduction was successful, the return value is 1. Otherwise the return value is 0.</p>
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a08ac709fa37043f44cbd15386d85b520">templateP4()</a> creates a new full P-node, if neccessary, and copies the full children of <em>nodePtr</em> to this P-node. The new P-node then is made endmost child of <em>partialChild</em>. The node <em>partialChild</em> is used to store the adress of the partial child of <em>nodePtr</em>. The <em>partialChild</em> itself stays child of <em>nodePtr</em>. Most of the here described action is done in the function <a class="el" href="classogdf_1_1_p_q_tree.html#af75513a32b835a71780a48b3c09f90ec">copyFullChildrenToPartial()</a>. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03335">3335</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a59dc0201fbefa391f83c3d7d28414530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59dc0201fbefa391f83c3d7d28414530">&sect;&nbsp;</a></span>templateP5()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateP5 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a59dc0201fbefa391f83c3d7d28414530">templateP5()</a> implements the template matching for a P-node with full, empty children and exactly one partial child. The P-node is not allowed to be the root of the pertinent subtree. The function requires as input any pointer to a node stored in <em>nodePtr</em>. If the node stored in <em>nodePtr</em> is a P-node with one partial child, <a class="el" href="classogdf_1_1_p_q_tree.html#a59dc0201fbefa391f83c3d7d28414530">templateP5()</a> considers itself responsible for the node and will apply the template matching <b>P5</b> to <em>nodePtr</em>. Observe that the user calling this function has to make sure that <em>nodePtr</em> is not the root of the pertinent subtree.</p>
<p>If <a class="el" href="classogdf_1_1_p_q_tree.html#a59dc0201fbefa391f83c3d7d28414530">templateP5()</a> was responsible for <em>nodePtr</em> and the reduction was successful, the return value is 1. Otherwise the return value is 0.</p>
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a59dc0201fbefa391f83c3d7d28414530">templateP5()</a> uses a few variables.</p><ul>
<li><em>partialChild</em> is a pointer to the partial child of <em>nodePtr</em>.</li>
<li><em>checkNode</em> is a pointer to the endmost empty child of <em>partialChild</em>.</li>
<li><em>emptyNode</em> is a pointer to the empty node that is copied as endmost child to <em>partialChild</em>.</li>
<li><em>emptyChildCount</em> stores the number of empty children of <em>nodePtr</em>.</li>
</ul>
<p>If neccessary, the function <a class="el" href="classogdf_1_1_p_q_tree.html#a59dc0201fbefa391f83c3d7d28414530">templateP5()</a> creates a new full P-node and copies all full children of <em>nodePtr</em> to this new full P-node. All empty children of <em>nodePtr</em> stay empty children of <em>nodePtr</em>.</p>
<p>The new full P-node and <em>nodePtr</em> will be the new endmost children of <em>partialChild</em>. The <em>partialChild</em> then occupies the position of <em>nodePtr</em> in the PQ-tree. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03396">3396</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a21c29c90e12637a2c1a91a59f67c9c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c29c90e12637a2c1a91a59f67c9c74">&sect;&nbsp;</a></span>templateP6()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateP6 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; **&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a21c29c90e12637a2c1a91a59f67c9c74">templateP6()</a> implements the template matching for a P-node with full, empty and exactly two partial children. The P-node must be the root of the pertinent subtree. The function requires as input any pointer to a node stored in <em>nodePtr</em>. If the node stored in <em>nodePtr</em> is a P-node with two partial children, <a class="el" href="classogdf_1_1_p_q_tree.html#a21c29c90e12637a2c1a91a59f67c9c74">templateP6()</a> considers itself responsible for the node and will apply the template matching <b>P6</b> to <em>nodePtr</em>. Observe that the user calling this function has to make sure that <em>nodePtr</em> is the root of the pertinent subtree.</p>
<p>If <a class="el" href="classogdf_1_1_p_q_tree.html#a21c29c90e12637a2c1a91a59f67c9c74">templateP6()</a> was responsible for <em>nodePtr</em> and the reduction was successful, the return value is 1. Otherwise the return value is 0.</p>
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a21c29c90e12637a2c1a91a59f67c9c74">templateP6()</a> creates, if neccessary, a new full P-node and copies all the full children of <em>nodePtr</em> to the new full P-node, whereas all empty children stay children of <em>nodePtr</em>. The new P-node will be copied to one of the partial children as endmost child of this partial node. The children of the second partial node are copied to the first one, such that the pertinent nodes form a consecutive sequence.</p>
<p>The following variables are used in the function <a class="el" href="classogdf_1_1_p_q_tree.html#a21c29c90e12637a2c1a91a59f67c9c74">templateP6()</a>.</p><ul>
<li><em>partial_1</em> is a pointer to the first partial child of <em>nodePtr</em>.</li>
<li><em>partial_2</em> is a pointer to the second partial child of <em>nodePtr</em>.</li>
<li><em>fullEnd_1</em> is a pointer to a full endmost child of <em>partial_1</em>.</li>
<li><em>fullEnd_2</em> is a pointer to a full endmost child of <em>partial_2</em>.</li>
<li><em>emptyEnd_2</em> is a pointer to the empty endmost child (more precisely: to the endmost child appearing on the empty side) of <em>partial_2</em>. In case that <em>ignored nodes</em> are used, this <em>emptyEnd_2</em> may store the adress of an ignored node.</li>
<li><em>realEmptyEnd_2</em> is a pointer to the first <em>non ignored</em> node with empty status on the empty side of <em>partial_2</em>. In case that no ignored nodes are used, <em>realEmpty_2</em> is identical to <em>endEmpty_2</em>. </li>
</ul>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03520">3520</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a206e9453307cee62d87b915b3f33c036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206e9453307cee62d87b915b3f33c036">&sect;&nbsp;</a></span>templateQ1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateQ1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRoot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a206e9453307cee62d87b915b3f33c036">templateQ1()</a> implements the template matching for Q-nodes with only full children. The function requires as input any pointer to a node stored in <em>nodePtr</em>. If the node stored in <em>nodePtr</em> is a Q-node with only full children, <a class="el" href="classogdf_1_1_p_q_tree.html#a206e9453307cee62d87b915b3f33c036">templateQ1()</a> considers itself responsible for the node and will apply the template matching for full Q-nodes to <em>nodePtr</em>. If the flag <em>isRoot</em> is set to 1, it signalizes <a class="el" href="classogdf_1_1_p_q_tree.html#a206e9453307cee62d87b915b3f33c036">templateQ1()</a> that <em>nodePtr</em> is the root of the pertinent subtree. In any other case the flag has to be 0.</p>
<p>If <a class="el" href="classogdf_1_1_p_q_tree.html#a206e9453307cee62d87b915b3f33c036">templateQ1()</a> was responsible for <em>nodePtr</em> and the reduction was successful, the return value is 1. Otherwise the return value is 0.</p>
<p>Different to the <a class="el" href="classogdf_1_1_p_q_tree.html#a2a1d21d208da1a620292ff92a101dcf8">templateP1()</a> for P-nodes, this function is not able to check if Q-node is full by comparing the number of children with the number of full children. The reason is the application of the <em>m_pseudoRoot</em> at certain steps in the matching algorithm. This <em>m_pseudoRoot</em> is used instead of the real root of the pertinent subtree in case that no parent pointer was found. But this implies that changing the number of the children of the pertinent root is not registered by the pertinent root. Hence we are not allowed to use the <em>childCount</em> of Q-nodes. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03661">3661</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a6839d25d0a5e27cd24f2f3da604b7169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6839d25d0a5e27cd24f2f3da604b7169">&sect;&nbsp;</a></span>templateQ2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateQ2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRoot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169">templateQ2()</a> implements the template matching for Q-nodes with a pertinent sequence of children on one side of the Q-node. The function requires as input any pointer to a node stored in <em>nodePtr</em>. If the node stored in <em>nodePtr</em> is a Q-node with a pertinent sequence of children on one side of the Q-node, <a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169">templateQ2()</a> considers itself responsible for the node and will apply the template matching <b>Q2</b> to <em>nodePtr</em>. If the flag <em>isRoot</em> is set to 1, it signalizes <a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169">templateQ2()</a> that <em>nodePtr</em> is the root of the pertinent subtree. In any other case the flag has to be 0.</p>
<p>If <a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169">templateQ2()</a> was responsible for <em>nodePtr</em> and the reduction was successful, the return value is 1. Otherwise the return value is 0.</p>
<p>Below a short description is given of all different cases that may occure and that are handled by the function <a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169">templateQ2()</a>, <b>regardless</b> whether the Q-node <em>nodePtr</em> is root of the pertinent subtree or not. The description is somewhat trunkated and should be understood as a stenographic description of the labels of the children of <em>nodePtr</em> when running through the children from one side to the other. Of course we leave the mirror-images out.</p><ul>
<li>full, empty</li>
<li>full, partial, empty</li>
<li>full, partial</li>
<li>partial, empty.</li>
</ul>
<p><a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169">templateQ2()</a> uses the following variables.</p><ul>
<li><em>fullNode</em> is a pointer to the full endmost child of <em>nodePtr</em>.</li>
<li><em>sequenceBegin</em> is a pointer to the first node of the sequence of full children. Identical to the node fullNode and mainly needed by the function <a class="el" href="classogdf_1_1_p_q_tree.html#a058fd295de75a48d2c0f948f6495cd55">checkChain()</a>.</li>
<li><em>sequenceEnd</em> is a pointer to the last node of the sequence of full children. Is set by the function <a class="el" href="classogdf_1_1_p_q_tree.html#a058fd295de75a48d2c0f948f6495cd55">checkChain()</a>.</li>
<li><em>partialChild</em> is a pointer to the partial child of <em>nodePtr</em>.</li>
<li><em>sequenceCons</em> is 1 if all full children of <em>nodePtr</em> form a consecutive sequence with one full child beeing an endmost child of <em>nodePtr</em> <b>and</b> the partial child is adjacent to the sequence.</li>
</ul>
<p><a class="el" href="classogdf_1_1_p_q_tree.html#a6839d25d0a5e27cd24f2f3da604b7169">templateQ2()</a> first checks if one of the above mentioned cases occures and then applies the necessary template matching. No special action has to be performed for the full nodes. If there exists a partial child that will be stored in <em>partialChild</em>, its children are made children of <em>nodePtr</em>. So to say, <em>partialChild</em> is lifted up to the Q-node <em>nodePtr</em> and the occurance of the children of <em>partialChild</em> is fixed within the children of <em>nodePtr</em>. (Remember that a partial child is also a Q-node). </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03742">3742</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="aefd5607fec9aaf74d58fb53ddb9883a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd5607fec9aaf74d58fb53ddb9883a7">&sect;&nbsp;</a></span>templateQ3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::templateQ3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt; T, X, Y &gt; *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l03888">3888</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a5b7764739dfcfc6d7c956870ccdf0230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7764739dfcfc6d7c956870ccdf0230">&sect;&nbsp;</a></span>writeGML() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::writeGML </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function <a class="el" href="classogdf_1_1_p_q_tree.html#a5b7764739dfcfc6d7c956870ccdf0230">writeGML()</a> prints the PQ-tree in the GML fileformat. The filename is ended by a ".gml" and can be read eg. by the <em>AGD</em>. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01938">1938</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a37530cf5088cc5f7edb8063a45495756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37530cf5088cc5f7edb8063a45495756">&sect;&nbsp;</a></span>writeGML() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::writeGML </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l01945">1945</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a75ed08b07f23d14328a91a7ba8bacc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ed08b07f23d14328a91a7ba8bacc7a">&sect;&nbsp;</a></span>m_identificationNumber</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::m_identificationNumber</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the total number of nodes that have been allocated. </p>
<p>Gives every node that has been used once in the PQ-tree a unique identification number. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00146">146</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="aa1f6f339ca2536e8dd9ebc15a5af8a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f6f339ca2536e8dd9ebc15a5af8a2c">&sect;&nbsp;</a></span>m_numberOfLeaves</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::m_numberOfLeaves</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the number of leaves. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00149">149</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a0a1a39850b4f51707c6b4609dd45f106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1a39850b4f51707c6b4609dd45f106">&sect;&nbsp;</a></span>m_pertinentNodes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_list.html">List</a>&lt;<a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;*&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::m_pertinentNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores all nodes that have been marked <b>FULL</b> or <b>PARTIAL</b> during a reduction. After the reduction has been finished succesfully, all pertinent nodes are reinitialized and prepared for the next reduction. This list also contains pertinent nodes that have been removed during a reduction. When detected in the stack, their memory is freed. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00159">159</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a52f7382c2c6fcd97da74fa246206375b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f7382c2c6fcd97da74fa246206375b">&sect;&nbsp;</a></span>m_pertinentRoot</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::m_pertinentRoot</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>is a pointer to the root of the pertinent subtree. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00136">136</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="afaf037b32f2e61ee0056fb25fd91e536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf037b32f2e61ee0056fb25fd91e536">&sect;&nbsp;</a></span>m_pseudoRoot</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::m_pseudoRoot</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>is a pointer to the virtual root of the pertinent subtree, in case that the pertinent root cannot be detected. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00139">139</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<a id="a02e0236df8adf9458353c304405a62a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e0236df8adf9458353c304405a62a5">&sect;&nbsp;</a></span>m_root</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X, class Y&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classogdf_1_1_p_q_node.html">PQNode</a>&lt;T,X,Y&gt;* <a class="el" href="classogdf_1_1_p_q_tree.html">ogdf::PQTree</a>&lt; T, X, Y &gt;::m_root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>is a pointer to the root of the $PQ$-tree. </p>

<p>Definition at line <a class="el" href="_p_q_tree_8h_source.html#l00133">133</a> of file <a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/ogdf/internal/planarity/<a class="el" href="_p_q_node_8h_source.html">PQNode.h</a></li>
<li>include/ogdf/internal/planarity/<a class="el" href="_p_q_tree_8h_source.html">PQTree.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceogdf.html">ogdf</a></li><li class="navelem"><a class="el" href="classogdf_1_1_p_q_tree.html">PQTree</a></li>
    <li class="footer">&copy; 1999-2014 by <a href="http://ls11-www.cs.uni-dortmund.de/">TU Dortmund</a>, <a href="http://www.inf.uni-osnabrueck.de/theoinf">Osnabr&uuml;ck University</a>, <a href="http://sydney.edu.au/engineering/it/">University of Cologne</a>, <a href="">University of Sydney</a></li>
  </ul>
</div>
</body>
</html>
