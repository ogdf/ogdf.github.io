<!-- HTML header for doxygen 1.8.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>ogdf: Graph Generators</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogdf-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
  <td>
   <table border="0" cellspacing="0" cellpadding="0">
    <tr>
     <td width="90"><a href="http://www.ogdf.net/" title="Go to www.ogdf.net"><img style="padding: 0 .5em; border-width: 0px" src="ogdf-logo.png"/></a></td>
     <td align="left"><h1 class="ogdftitle">Open<br>Graph Drawing<br>Framework</h1></td>
     <td align="left" valign="bottom" >
      <span style="font-size:110%; color:rgb(56,95,118)">&nbsp;v. 2022.02 (Dogwood)</span><br>&nbsp;
     </td>
    </tr>
   </table>
  </td>
 </tr>
 <tr>
  <td valign="bottom">
   <div class="menubox">
    <table border="0" cellpadding="0" cellspacing="0" class="menutable">
     <tr>
      <td><a class="menu" href="index.html" title="Start page with overview">Overview</a></td>
      <td><a class="menu" href="hierarchy.html" title="Inheritance hierarchies">Class&nbsp;Hierarchy</a></td>
      <td><a class="menu" href="classes.html" title="Alphabetical list of classes">Class&nbsp;Index</a></td>
      <td><a class="menu" href="annotated.html" title="Classes with brief descriptions">Class&nbsp;List</a></td>
      <td><a class="menu" href="functions.html" title="Complete list of member functions, enumerations, and variables">Members</a></td>
      <td><a class="menu" href="namespaces.html" title="Namespaces with brief descriptions">Namespaces</a></td>
      <td><a class="menu" href="files.html" title="Complete list of files with brief descriptions">Source&nbsp;Files</a></td>
      <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
     </tr>
    </table>
   </div><br>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__graph-generators.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Graph Generators<div class="ingroups"><a class="el" href="group__graphs.html">Graphs and Embeddings</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides various graph generator functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Deterministic graph generators</h2></td></tr>
<tr class="memitem:gad0a545afc61d9b588bb859851a024c7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gad0a545afc61d9b588bb859851a024c7b">ogdf::customGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, <a class="el" href="classogdf_1_1_list.html">List</a>&lt; std::pair&lt; int, int &gt;&gt; edges, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="group__graphs.html#gab5b3e7ed7cf2e6271b285c7ed39b87e2">node</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:gad0a545afc61d9b588bb859851a024c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a custom graph using a list of pairs to determine the graph's edges.  <a href="group__graph-generators.html#gad0a545afc61d9b588bb859851a024c7b">More...</a><br /></td></tr>
<tr class="separator:gad0a545afc61d9b588bb859851a024c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf374e75edf393767720724e794f6d41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gabf374e75edf393767720724e794f6d41">ogdf::customGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, <a class="el" href="classogdf_1_1_list.html">List</a>&lt; std::pair&lt; int, int &gt;&gt; edges)</td></tr>
<tr class="memdesc:gabf374e75edf393767720724e794f6d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a custom graph using a list of pairs to determine the graph's edges.  <a href="group__graph-generators.html#gabf374e75edf393767720724e794f6d41">More...</a><br /></td></tr>
<tr class="separator:gabf374e75edf393767720724e794f6d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga061ae4c9a5ba165e0cc57998df2c878f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga061ae4c9a5ba165e0cc57998df2c878f">ogdf::circulantGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; int &gt; jumps)</td></tr>
<tr class="memdesc:ga061ae4c9a5ba165e0cc57998df2c878f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a circulant graph.  <a href="group__graph-generators.html#ga061ae4c9a5ba165e0cc57998df2c878f">More...</a><br /></td></tr>
<tr class="separator:ga061ae4c9a5ba165e0cc57998df2c878f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c2abcc203dcfc0839f5233afeebbe5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga6c2abcc203dcfc0839f5233afeebbe5d">ogdf::regularLatticeGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, int k)</td></tr>
<tr class="memdesc:ga6c2abcc203dcfc0839f5233afeebbe5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a regular lattice graph.  <a href="group__graph-generators.html#ga6c2abcc203dcfc0839f5233afeebbe5d">More...</a><br /></td></tr>
<tr class="separator:ga6c2abcc203dcfc0839f5233afeebbe5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0cfb1b80c90a6f6cea17589bc522c29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gac0cfb1b80c90a6f6cea17589bc522c29">ogdf::regularTree</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, int children)</td></tr>
<tr class="memdesc:gac0cfb1b80c90a6f6cea17589bc522c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a regular tree.  <a href="group__graph-generators.html#gac0cfb1b80c90a6f6cea17589bc522c29">More...</a><br /></td></tr>
<tr class="separator:gac0cfb1b80c90a6f6cea17589bc522c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3f3de8e779cf75d10d3784c8da491fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gaa3f3de8e779cf75d10d3784c8da491fc">ogdf::completeGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n)</td></tr>
<tr class="memdesc:gaa3f3de8e779cf75d10d3784c8da491fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the complete graph <em>K_n</em>.  <a href="group__graph-generators.html#gaa3f3de8e779cf75d10d3784c8da491fc">More...</a><br /></td></tr>
<tr class="separator:gaa3f3de8e779cf75d10d3784c8da491fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75e3a665f927e3200e63e4b9f16e5553"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga75e3a665f927e3200e63e4b9f16e5553">ogdf::completeKPartiteGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, const <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; int &gt; &amp;signature)</td></tr>
<tr class="memdesc:ga75e3a665f927e3200e63e4b9f16e5553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the complete k-partite graph <em>K_{k1</em>,k2,...,kn}.  <a href="group__graph-generators.html#ga75e3a665f927e3200e63e4b9f16e5553">More...</a><br /></td></tr>
<tr class="separator:ga75e3a665f927e3200e63e4b9f16e5553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d8c6b9ec7744fc50a48678666bb9f76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga9d8c6b9ec7744fc50a48678666bb9f76">ogdf::completeBipartiteGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, int m)</td></tr>
<tr class="memdesc:ga9d8c6b9ec7744fc50a48678666bb9f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the complete bipartite graph <em>K_{n</em>,m}.  <a href="group__graph-generators.html#ga9d8c6b9ec7744fc50a48678666bb9f76">More...</a><br /></td></tr>
<tr class="separator:ga9d8c6b9ec7744fc50a48678666bb9f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cf4c76cee9dcb8bf4dbc3a13b401e2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga8cf4c76cee9dcb8bf4dbc3a13b401e2f">ogdf::wheelGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n)</td></tr>
<tr class="memdesc:ga8cf4c76cee9dcb8bf4dbc3a13b401e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the graph <em>W_n:</em> A wheel graph.  <a href="group__graph-generators.html#ga8cf4c76cee9dcb8bf4dbc3a13b401e2f">More...</a><br /></td></tr>
<tr class="separator:ga8cf4c76cee9dcb8bf4dbc3a13b401e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7c85da1b67c5f397be073826a532f39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gab7c85da1b67c5f397be073826a532f39">ogdf::cubeGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n)</td></tr>
<tr class="memdesc:gab7c85da1b67c5f397be073826a532f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the graph <em>Q^n</em>: A <code>n</code>-cube graph.  <a href="group__graph-generators.html#gab7c85da1b67c5f397be073826a532f39">More...</a><br /></td></tr>
<tr class="separator:gab7c85da1b67c5f397be073826a532f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b6fc792acfc6697de0ae62c01df372b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga3b6fc792acfc6697de0ae62c01df372b">ogdf::suspension</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int s)</td></tr>
<tr class="memdesc:ga3b6fc792acfc6697de0ae62c01df372b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies <code>G</code> by adding its <code>s</code>-th suspension.  <a href="group__graph-generators.html#ga3b6fc792acfc6697de0ae62c01df372b">More...</a><br /></td></tr>
<tr class="separator:ga3b6fc792acfc6697de0ae62c01df372b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5147b533c68c25f3372b3ec5c2f04b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga5e5147b533c68c25f3372b3ec5c2f04b">ogdf::gridGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, int m, bool loopN, bool loopM)</td></tr>
<tr class="memdesc:ga5e5147b533c68c25f3372b3ec5c2f04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a (toroidal) grid graph on <code>n</code> x <code>m</code> nodes.  <a href="group__graph-generators.html#ga5e5147b533c68c25f3372b3ec5c2f04b">More...</a><br /></td></tr>
<tr class="separator:ga5e5147b533c68c25f3372b3ec5c2f04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9473b8540a5bbe604f84042d30c8a47f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga9473b8540a5bbe604f84042d30c8a47f">ogdf::petersenGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n=5, int m=2)</td></tr>
<tr class="memdesc:ga9473b8540a5bbe604f84042d30c8a47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a generalized Petersen graph.  <a href="group__graph-generators.html#ga9473b8540a5bbe604f84042d30c8a47f">More...</a><br /></td></tr>
<tr class="separator:ga9473b8540a5bbe604f84042d30c8a47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44c2631acd39f73c7117a8a8c60d6071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga44c2631acd39f73c7117a8a8c60d6071">ogdf::emptyGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int nodes)</td></tr>
<tr class="memdesc:ga44c2631acd39f73c7117a8a8c60d6071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a graph with <code>nodes</code> nodes and no edges.  <a href="group__graph-generators.html#ga44c2631acd39f73c7117a8a8c60d6071">More...</a><br /></td></tr>
<tr class="separator:ga44c2631acd39f73c7117a8a8c60d6071"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Graph operations</h2></td></tr>
<tr class="memitem:ga282dbe6cafbcad0830bdc32bacf333a1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga282dbe6cafbcad0830bdc32bacf333a1">ogdf::NodeMap</a> = <a class="el" href="classogdf_1_1_node_array.html">NodeArray</a>&lt; <a class="el" href="classogdf_1_1_node_array.html">NodeArray</a>&lt; <a class="el" href="group__graphs.html#gab5b3e7ed7cf2e6271b285c7ed39b87e2">node</a> &gt; &gt;</td></tr>
<tr class="separator:ga282dbe6cafbcad0830bdc32bacf333a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad652539b8c8f02edb3b1eb770955d72f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gad652539b8c8f02edb3b1eb770955d72f">ogdf::graphUnion</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G1, const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G2)</td></tr>
<tr class="memdesc:gad652539b8c8f02edb3b1eb770955d72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the disjoint union of <code>G1</code> and <code>G2</code>.  <a href="group__graph-generators.html#gad652539b8c8f02edb3b1eb770955d72f">More...</a><br /></td></tr>
<tr class="separator:gad652539b8c8f02edb3b1eb770955d72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83238ea79ba306e4942f8639f0a263d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga83238ea79ba306e4942f8639f0a263d0">ogdf::graphUnion</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G1, const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G2, <a class="el" href="classogdf_1_1_node_array.html">NodeArray</a>&lt; <a class="el" href="group__graphs.html#gab5b3e7ed7cf2e6271b285c7ed39b87e2">node</a> &gt; &amp;map2to1, bool parallelfree=false, bool directed=false)</td></tr>
<tr class="memdesc:ga83238ea79ba306e4942f8639f0a263d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the union of <code>G1</code> and <code>G2</code> while identifying nodes from <code>G2</code> with nodes from <code>G1</code>.  <a href="group__graph-generators.html#ga83238ea79ba306e4942f8639f0a263d0">More...</a><br /></td></tr>
<tr class="separator:ga83238ea79ba306e4942f8639f0a263d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a948b303decd234d5d1d0a615fe70f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga55a948b303decd234d5d1d0a615fe70f">ogdf::graphProduct</a> (const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G1, const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G2, <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;product, <a class="el" href="group__graph-generators.html#ga282dbe6cafbcad0830bdc32bacf333a1">NodeMap</a> &amp;nodeInProduct, const std::function&lt; void(<a class="el" href="group__graphs.html#gab5b3e7ed7cf2e6271b285c7ed39b87e2">node</a>, <a class="el" href="group__graphs.html#gab5b3e7ed7cf2e6271b285c7ed39b87e2">node</a>)&gt; &amp;addEdges)</td></tr>
<tr class="memdesc:ga55a948b303decd234d5d1d0a615fe70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the graph product of <code>G1</code> and <code>G2</code>, using a given function to add edges.  <a href="group__graph-generators.html#ga55a948b303decd234d5d1d0a615fe70f">More...</a><br /></td></tr>
<tr class="separator:ga55a948b303decd234d5d1d0a615fe70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae93e3be5f8fd4b43599b4c4bc18bbece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gae93e3be5f8fd4b43599b4c4bc18bbece">ogdf::cartesianProduct</a> (const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G1, const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G2, <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;product, <a class="el" href="group__graph-generators.html#ga282dbe6cafbcad0830bdc32bacf333a1">NodeMap</a> &amp;nodeInProduct)</td></tr>
<tr class="memdesc:gae93e3be5f8fd4b43599b4c4bc18bbece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Cartesian product of <code>G1</code> and <code>G2</code> and assigns it to <code>product</code>, with \(E = \{(\langle v_1,w_1\rangle, \langle v_1,w_2\rangle) | (w_1,w_2) \in E_2\} \cup \{(\langle v_1,w_1\rangle, \langle v_2,w_1\rangle) | (v_1,v_2) \in E_1\} \).  <a href="group__graph-generators.html#gae93e3be5f8fd4b43599b4c4bc18bbece">More...</a><br /></td></tr>
<tr class="separator:gae93e3be5f8fd4b43599b4c4bc18bbece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ccd70ceb0ec85e2d48a6f14db544ade"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga5ccd70ceb0ec85e2d48a6f14db544ade">ogdf::tensorProduct</a> (const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G1, const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G2, <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;product, <a class="el" href="group__graph-generators.html#ga282dbe6cafbcad0830bdc32bacf333a1">NodeMap</a> &amp;nodeInProduct)</td></tr>
<tr class="memdesc:ga5ccd70ceb0ec85e2d48a6f14db544ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tensor product of <code>G1</code> and <code>G2</code> and assigns it to <code>product</code>, with \(E = \{(\langle v_1,w_1\rangle, \langle v_2,w_2\rangle) | (v_1,v_2) \in E_1 \land (w_1,w_2) \in E_2\} \).  <a href="group__graph-generators.html#ga5ccd70ceb0ec85e2d48a6f14db544ade">More...</a><br /></td></tr>
<tr class="separator:ga5ccd70ceb0ec85e2d48a6f14db544ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e5ff20296166cf41de0bf597932f271"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga7e5ff20296166cf41de0bf597932f271">ogdf::lexicographicalProduct</a> (const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G1, const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G2, <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;product, <a class="el" href="group__graph-generators.html#ga282dbe6cafbcad0830bdc32bacf333a1">NodeMap</a> &amp;nodeInProduct)</td></tr>
<tr class="memdesc:ga7e5ff20296166cf41de0bf597932f271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the lexicographical product of <code>G1</code> and <code>G2</code> and assigns it to <code>product</code>, with \(E = \{(\langle v_1,w_1\rangle, \langle v_2,w_2\rangle) | (v_1,v_2) \in E_1\} \cup \{(\langle v_1,w_1\rangle, \langle v_1,w_2\rangle) | (w_1,w_2) \in E_2\} \).  <a href="group__graph-generators.html#ga7e5ff20296166cf41de0bf597932f271">More...</a><br /></td></tr>
<tr class="separator:ga7e5ff20296166cf41de0bf597932f271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga817f2f7a6c23b0df0845224c43aec61a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga817f2f7a6c23b0df0845224c43aec61a">ogdf::strongProduct</a> (const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G1, const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G2, <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;product, <a class="el" href="group__graph-generators.html#ga282dbe6cafbcad0830bdc32bacf333a1">NodeMap</a> &amp;nodeInProduct)</td></tr>
<tr class="memdesc:ga817f2f7a6c23b0df0845224c43aec61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the strong product of <code>G1</code> and <code>G2</code> and assigns it to <code>product</code>, with \(E = \{(\langle v_1,w_1\rangle, \langle v_1,w_2\rangle) | (w_1,w_2) \in E_2\} \cup \{(\langle v_1,w_1\rangle, \langle v_2,w_1\rangle) | (v_1,v_2) \in E_1\} \cup \{(\langle v_1,w_1\rangle, \langle v_2,w_2\rangle) | (v_1,v_2) \in E_1 \land (w_1,w_2) \in E_2\} \).  <a href="group__graph-generators.html#ga817f2f7a6c23b0df0845224c43aec61a">More...</a><br /></td></tr>
<tr class="separator:ga817f2f7a6c23b0df0845224c43aec61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4bec92ed404b35135d40ac73bce4398"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gab4bec92ed404b35135d40ac73bce4398">ogdf::coNormalProduct</a> (const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G1, const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G2, <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;product, <a class="el" href="group__graph-generators.html#ga282dbe6cafbcad0830bdc32bacf333a1">NodeMap</a> &amp;nodeInProduct)</td></tr>
<tr class="memdesc:gab4bec92ed404b35135d40ac73bce4398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the co-normal product of <code>G1</code> and <code>G2</code> and assigns it to <code>product</code>, with \(E = \{(\langle v_1,w_1\rangle, \langle v_2,w_2\rangle) | (v_1,v_2) \in E_1 \lor (w_1,w_2) \in E_2\} \).  <a href="group__graph-generators.html#gab4bec92ed404b35135d40ac73bce4398">More...</a><br /></td></tr>
<tr class="separator:gab4bec92ed404b35135d40ac73bce4398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ba57f8ac28485c787b42de492ce03d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga2ba57f8ac28485c787b42de492ce03d3">ogdf::modularProduct</a> (const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G1, const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G2, <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;product, <a class="el" href="group__graph-generators.html#ga282dbe6cafbcad0830bdc32bacf333a1">NodeMap</a> &amp;nodeInProduct)</td></tr>
<tr class="memdesc:ga2ba57f8ac28485c787b42de492ce03d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the modular product of <code>G1</code> and <code>G2</code> and assigns it to <code>product</code>, with \(E = \{(\langle v_1,w_1\rangle, \langle v_2,w_2\rangle) | (v_1,v_2) \in E_1 \land (w_1,w_2) \in E_2\} \cup \{(\langle v_1,w_1\rangle, \langle v_2,w_2\rangle) | (v_1,v_2) \not\in E_1 \land (w_1,w_2) \not\in E_2\} \).  <a href="group__graph-generators.html#ga2ba57f8ac28485c787b42de492ce03d3">More...</a><br /></td></tr>
<tr class="separator:ga2ba57f8ac28485c787b42de492ce03d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbe43c8492ebfd2ce8e9d96153e12c90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gabbe43c8492ebfd2ce8e9d96153e12c90">ogdf::rootedProduct</a> (const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G1, const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G2, <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;product, <a class="el" href="group__graph-generators.html#ga282dbe6cafbcad0830bdc32bacf333a1">NodeMap</a> &amp;nodeInProduct, <a class="el" href="group__graphs.html#gab5b3e7ed7cf2e6271b285c7ed39b87e2">node</a> rootInG2)</td></tr>
<tr class="memdesc:gabbe43c8492ebfd2ce8e9d96153e12c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rooted product of <code>G1</code> and <code>G2</code>, rooted in <code>rootInG2</code>, and assigns it to <code>product</code>.  <a href="group__graph-generators.html#gabbe43c8492ebfd2ce8e9d96153e12c90">More...</a><br /></td></tr>
<tr class="separator:gabbe43c8492ebfd2ce8e9d96153e12c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Randomized graph generators</h2></td></tr>
<tr class="memitem:ga65f5f08f024374b5816505aa018f05d4"><td class="memTemplParams" colspan="2">template&lt;typename D &gt; </td></tr>
<tr class="memitem:ga65f5f08f024374b5816505aa018f05d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga65f5f08f024374b5816505aa018f05d4">ogdf::randomGeographicalThresholdGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; int &gt; &amp;weights, D &amp;dist, double threshold, std::function&lt; double(double)&gt; h, int dimension=2)</td></tr>
<tr class="memdesc:ga65f5f08f024374b5816505aa018f05d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random geometric graph where edges are created based on their distance and the weight of nodes.  <a href="group__graph-generators.html#ga65f5f08f024374b5816505aa018f05d4">More...</a><br /></td></tr>
<tr class="separator:ga65f5f08f024374b5816505aa018f05d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf06aebce8dcd68412cecd330c8d83b5"><td class="memTemplParams" colspan="2">template&lt;typename D &gt; </td></tr>
<tr class="memitem:gabf06aebce8dcd68412cecd330c8d83b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gabf06aebce8dcd68412cecd330c8d83b5">ogdf::randomGeographicalThresholdGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; int &gt; &amp;weights, D &amp;dist, double threshold, int alpha=2, int dimension=2)</td></tr>
<tr class="memdesc:gabf06aebce8dcd68412cecd330c8d83b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random geometric graph where edges are created based on their distance and the weight of nodes.  <a href="group__graph-generators.html#gabf06aebce8dcd68412cecd330c8d83b5">More...</a><br /></td></tr>
<tr class="separator:gabf06aebce8dcd68412cecd330c8d83b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4f8e06a35368a8ce24efcbb71bf1e36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gaa4f8e06a35368a8ce24efcbb71bf1e36">ogdf::randomHierarchy</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, int m, bool planar, bool singleSource, bool longEdges)</td></tr>
<tr class="memdesc:gaa4f8e06a35368a8ce24efcbb71bf1e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random hierarchical graph.  <a href="group__graph-generators.html#gaa4f8e06a35368a8ce24efcbb71bf1e36">More...</a><br /></td></tr>
<tr class="separator:gaa4f8e06a35368a8ce24efcbb71bf1e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e2b0644b941d5f8bb7770a27a1f6171"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga5e2b0644b941d5f8bb7770a27a1f6171">ogdf::randomRegularGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, int d)</td></tr>
<tr class="memdesc:ga5e2b0644b941d5f8bb7770a27a1f6171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random <code>d</code>-regular graph.  <a href="group__graph-generators.html#ga5e2b0644b941d5f8bb7770a27a1f6171">More...</a><br /></td></tr>
<tr class="separator:ga5e2b0644b941d5f8bb7770a27a1f6171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0feff1b510864aba8b73a1b34e5f2ca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga0feff1b510864aba8b73a1b34e5f2ca1">ogdf::randomGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, int m)</td></tr>
<tr class="memdesc:ga0feff1b510864aba8b73a1b34e5f2ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random graph.  <a href="group__graph-generators.html#ga0feff1b510864aba8b73a1b34e5f2ca1">More...</a><br /></td></tr>
<tr class="separator:ga0feff1b510864aba8b73a1b34e5f2ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6991a8ef695dc1ce1c320aeb843856d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gac6991a8ef695dc1ce1c320aeb843856d">ogdf::randomSimpleGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, int m)</td></tr>
<tr class="memdesc:gac6991a8ef695dc1ce1c320aeb843856d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random simple graph.  <a href="group__graph-generators.html#gac6991a8ef695dc1ce1c320aeb843856d">More...</a><br /></td></tr>
<tr class="separator:gac6991a8ef695dc1ce1c320aeb843856d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga066156d279149423d377f108d42b19c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga066156d279149423d377f108d42b19c1">ogdf::randomSimpleGraphByProbability</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, double pEdge)</td></tr>
<tr class="memdesc:ga066156d279149423d377f108d42b19c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random simple graph.  <a href="group__graph-generators.html#ga066156d279149423d377f108d42b19c1">More...</a><br /></td></tr>
<tr class="separator:ga066156d279149423d377f108d42b19c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga781aeb9ae0e597beb8cfd97f2dc15201"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga781aeb9ae0e597beb8cfd97f2dc15201">ogdf::randomSimpleConnectedGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, int m)</td></tr>
<tr class="memdesc:ga781aeb9ae0e597beb8cfd97f2dc15201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random simple and connected graph.  <a href="group__graph-generators.html#ga781aeb9ae0e597beb8cfd97f2dc15201">More...</a><br /></td></tr>
<tr class="separator:ga781aeb9ae0e597beb8cfd97f2dc15201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae84cb709f5fcb098528bc0474d1a55b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gae84cb709f5fcb098528bc0474d1a55b2">ogdf::randomBiconnectedGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, int m)</td></tr>
<tr class="memdesc:gae84cb709f5fcb098528bc0474d1a55b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random biconnected graph.  <a href="group__graph-generators.html#gae84cb709f5fcb098528bc0474d1a55b2">More...</a><br /></td></tr>
<tr class="separator:gae84cb709f5fcb098528bc0474d1a55b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9de58fd22ae2533f0d81d450d4bf985"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gae9de58fd22ae2533f0d81d450d4bf985">ogdf::randomPlanarConnectedGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, int m)</td></tr>
<tr class="memdesc:gae9de58fd22ae2533f0d81d450d4bf985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random connected (simple) planar (embedded) graph.  <a href="group__graph-generators.html#gae9de58fd22ae2533f0d81d450d4bf985">More...</a><br /></td></tr>
<tr class="separator:gae9de58fd22ae2533f0d81d450d4bf985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0e3ab667c0cda3afe62c22f780b162c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gad0e3ab667c0cda3afe62c22f780b162c">ogdf::randomPlanarBiconnectedGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, int m, bool multiEdges=false)</td></tr>
<tr class="memdesc:gad0e3ab667c0cda3afe62c22f780b162c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random planar biconnected (embedded) graph.  <a href="group__graph-generators.html#gad0e3ab667c0cda3afe62c22f780b162c">More...</a><br /></td></tr>
<tr class="separator:gad0e3ab667c0cda3afe62c22f780b162c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a0d0e584ba5cdfe1e0cd4049b793ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga27a0d0e584ba5cdfe1e0cd4049b793ca">ogdf::randomPlanarBiconnectedDigraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, int m, double p=0, bool multiEdges=false)</td></tr>
<tr class="memdesc:ga27a0d0e584ba5cdfe1e0cd4049b793ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random planar biconnected acyclic (embedded) digraph.  <a href="group__graph-generators.html#ga27a0d0e584ba5cdfe1e0cd4049b793ca">More...</a><br /></td></tr>
<tr class="separator:ga27a0d0e584ba5cdfe1e0cd4049b793ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b40a1075eb63d5a28b0655d701dec67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga1b40a1075eb63d5a28b0655d701dec67">ogdf::randomUpwardPlanarBiconnectedDigraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, int m)</td></tr>
<tr class="memdesc:ga1b40a1075eb63d5a28b0655d701dec67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random upward planar biconnected (embedded) digraph.  <a href="group__graph-generators.html#ga1b40a1075eb63d5a28b0655d701dec67">More...</a><br /></td></tr>
<tr class="separator:ga1b40a1075eb63d5a28b0655d701dec67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4da58b786a2bb0c8eff99fa9b205e58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gae4da58b786a2bb0c8eff99fa9b205e58">ogdf::randomPlanarCNBGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, int m, int b)</td></tr>
<tr class="memdesc:gae4da58b786a2bb0c8eff99fa9b205e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random planar graph, that is connected, but not biconnected.  <a href="group__graph-generators.html#gae4da58b786a2bb0c8eff99fa9b205e58">More...</a><br /></td></tr>
<tr class="separator:gae4da58b786a2bb0c8eff99fa9b205e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadad6b837cade23898f3dc0ae68239274"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gadad6b837cade23898f3dc0ae68239274">ogdf::randomTriconnectedGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, double p1, double p2)</td></tr>
<tr class="memdesc:gadad6b837cade23898f3dc0ae68239274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random triconnected (and simple) graph.  <a href="group__graph-generators.html#gadad6b837cade23898f3dc0ae68239274">More...</a><br /></td></tr>
<tr class="separator:gadad6b837cade23898f3dc0ae68239274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6602d5f7709f793dcc53e83e1875b1a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga6602d5f7709f793dcc53e83e1875b1a6">ogdf::randomPlanarTriconnectedGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, int m)</td></tr>
<tr class="memdesc:ga6602d5f7709f793dcc53e83e1875b1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random planar triconnected (and simple) graph.  <a href="group__graph-generators.html#ga6602d5f7709f793dcc53e83e1875b1a6">More...</a><br /></td></tr>
<tr class="separator:ga6602d5f7709f793dcc53e83e1875b1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38b77440e49db5110960a11be8195a30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga38b77440e49db5110960a11be8195a30">ogdf::randomPlanarTriconnectedGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, double p1, double p2)</td></tr>
<tr class="memdesc:ga38b77440e49db5110960a11be8195a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random planar triconnected (and simple) graph.  <a href="group__graph-generators.html#ga38b77440e49db5110960a11be8195a30">More...</a><br /></td></tr>
<tr class="separator:ga38b77440e49db5110960a11be8195a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95ff41c015fe92cc550088127e43d09c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga95ff41c015fe92cc550088127e43d09c">ogdf::randomTree</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n)</td></tr>
<tr class="memdesc:ga95ff41c015fe92cc550088127e43d09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random tree (simpler version.  <a href="group__graph-generators.html#ga95ff41c015fe92cc550088127e43d09c">More...</a><br /></td></tr>
<tr class="separator:ga95ff41c015fe92cc550088127e43d09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad83c1576fee773abf95334f842f6849b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gad83c1576fee773abf95334f842f6849b">ogdf::randomTree</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, int maxDeg, int maxWidth)</td></tr>
<tr class="memdesc:gad83c1576fee773abf95334f842f6849b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random tree.  <a href="group__graph-generators.html#gad83c1576fee773abf95334f842f6849b">More...</a><br /></td></tr>
<tr class="separator:gad83c1576fee773abf95334f842f6849b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85a79853e408557d003de19d0034614e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga85a79853e408557d003de19d0034614e">ogdf::randomClusterPlanarGraph</a> (<a class="el" href="classogdf_1_1_cluster_graph.html">ClusterGraph</a> &amp;C, <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int cNum)</td></tr>
<tr class="memdesc:ga85a79853e408557d003de19d0034614e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns random clusters to a given graph <code>G</code>.  <a href="group__graph-generators.html#ga85a79853e408557d003de19d0034614e">More...</a><br /></td></tr>
<tr class="separator:ga85a79853e408557d003de19d0034614e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga519fee82a5b4ee56b07e74f32e1ff7d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga519fee82a5b4ee56b07e74f32e1ff7d9">ogdf::randomClusterGraph</a> (<a class="el" href="classogdf_1_1_cluster_graph.html">ClusterGraph</a> &amp;C, <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int cNum)</td></tr>
<tr class="memdesc:ga519fee82a5b4ee56b07e74f32e1ff7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns random clusters to a given graph <code>G</code>.  <a href="group__graph-generators.html#ga519fee82a5b4ee56b07e74f32e1ff7d9">More...</a><br /></td></tr>
<tr class="separator:ga519fee82a5b4ee56b07e74f32e1ff7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c51749db17a3cb4362789e28b3efd9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga1c51749db17a3cb4362789e28b3efd9f">ogdf::randomClusterGraph</a> (<a class="el" href="classogdf_1_1_cluster_graph.html">ClusterGraph</a> &amp;C, const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, const <a class="el" href="group__graphs.html#gab5b3e7ed7cf2e6271b285c7ed39b87e2">node</a> root, int moreInLeaves)</td></tr>
<tr class="memdesc:ga1c51749db17a3cb4362789e28b3efd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a specified cluster structure to a given graph <code>G</code>, and assigns vertices to clusters.  <a href="group__graph-generators.html#ga1c51749db17a3cb4362789e28b3efd9f">More...</a><br /></td></tr>
<tr class="separator:ga1c51749db17a3cb4362789e28b3efd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfc90d445bff2e543aeae557af7da45b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gabfc90d445bff2e543aeae557af7da45b">ogdf::randomDigraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, double p)</td></tr>
<tr class="memdesc:gabfc90d445bff2e543aeae557af7da45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random (simple) directed graph.  <a href="group__graph-generators.html#gabfc90d445bff2e543aeae557af7da45b">More...</a><br /></td></tr>
<tr class="separator:gabfc90d445bff2e543aeae557af7da45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7bf735577889df8926599b1152957f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gab7bf735577889df8926599b1152957f5">ogdf::randomSeriesParallelDAG</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int edges, double p=0.5, double flt=0.0)</td></tr>
<tr class="memdesc:gab7bf735577889df8926599b1152957f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random (simple, biconnected) series parallel DAG.  <a href="group__graph-generators.html#gab7bf735577889df8926599b1152957f5">More...</a><br /></td></tr>
<tr class="separator:gab7bf735577889df8926599b1152957f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa22bfe93fe65faf3f59f3c966a71471b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gaa22bfe93fe65faf3f59f3c966a71471b">ogdf::randomGeometricCubeGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int nodes, double threshold, int dimension=2)</td></tr>
<tr class="memdesc:gaa22bfe93fe65faf3f59f3c966a71471b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random geometric graph by laying out nodes in a unit n-cube. Nodes with a distance &lt; threshold are connected, 0 &lt;= threshold &lt;= sqrt(dimension). The graph is simple.  <a href="group__graph-generators.html#gaa22bfe93fe65faf3f59f3c966a71471b">More...</a><br /></td></tr>
<tr class="separator:gaa22bfe93fe65faf3f59f3c966a71471b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28d983e7ad7f1dc8b4e91cb4326e68ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga28d983e7ad7f1dc8b4e91cb4326e68ec">ogdf::randomWaxmanGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int nodes, double alpha, double beta, double width=1.0, double height=1.0)</td></tr>
<tr class="memdesc:ga28d983e7ad7f1dc8b4e91cb4326e68ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a Waxman graph where nodes are uniformly randomly placed in a grid, then edges are inserted based on nodes' euclidean distances.  <a href="group__graph-generators.html#ga28d983e7ad7f1dc8b4e91cb4326e68ec">More...</a><br /></td></tr>
<tr class="separator:ga28d983e7ad7f1dc8b4e91cb4326e68ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70be73bda36b4aeb89122bcd3154af7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga70be73bda36b4aeb89122bcd3154af7c">ogdf::preferentialAttachmentGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int nodes, int minDegree)</td></tr>
<tr class="memdesc:ga70be73bda36b4aeb89122bcd3154af7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a graph where new nodes are more likely to connect to nodes with high degree.  <a href="group__graph-generators.html#ga70be73bda36b4aeb89122bcd3154af7c">More...</a><br /></td></tr>
<tr class="separator:ga70be73bda36b4aeb89122bcd3154af7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba4c92aaba97ed6ec8c4e250268f5c5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gaba4c92aaba97ed6ec8c4e250268f5c5a">ogdf::randomWattsStrogatzGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, int n, int k, double probability)</td></tr>
<tr class="memdesc:gaba4c92aaba97ed6ec8c4e250268f5c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a "small world" graph as described by Watts &amp; Strogatz.  <a href="group__graph-generators.html#gaba4c92aaba97ed6ec8c4e250268f5c5a">More...</a><br /></td></tr>
<tr class="separator:gaba4c92aaba97ed6ec8c4e250268f5c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5163ba3842a6d1cec25c758b2ac12899"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#ga5163ba3842a6d1cec25c758b2ac12899">ogdf::randomChungLuGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; int &gt; expectedDegreeDistribution)</td></tr>
<tr class="memdesc:ga5163ba3842a6d1cec25c758b2ac12899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a graph where edges are inserted based on given weights.  <a href="group__graph-generators.html#ga5163ba3842a6d1cec25c758b2ac12899">More...</a><br /></td></tr>
<tr class="separator:ga5163ba3842a6d1cec25c758b2ac12899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac378d37324b0feb49b6bbf7430970308"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graph-generators.html#gac378d37324b0feb49b6bbf7430970308">ogdf::randomEdgesGraph</a> (<a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;G, std::function&lt; double(<a class="el" href="group__graphs.html#gab5b3e7ed7cf2e6271b285c7ed39b87e2">node</a>, <a class="el" href="group__graphs.html#gab5b3e7ed7cf2e6271b285c7ed39b87e2">node</a>)&gt; probability)</td></tr>
<tr class="memdesc:gac378d37324b0feb49b6bbf7430970308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts edges into the given graph based on probabilities given by a callback function.  <a href="group__graph-generators.html#gac378d37324b0feb49b6bbf7430970308">More...</a><br /></td></tr>
<tr class="separator:gac378d37324b0feb49b6bbf7430970308"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Provides various graph generator functions. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga282dbe6cafbcad0830bdc32bacf333a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga282dbe6cafbcad0830bdc32bacf333a1">&#9670;&nbsp;</a></span>NodeMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__graph-generators.html#ga282dbe6cafbcad0830bdc32bacf333a1">ogdf::NodeMap</a> = typedef <a class="el" href="classogdf_1_1_node_array.html">NodeArray</a>&lt;<a class="el" href="classogdf_1_1_node_array.html">NodeArray</a>&lt;<a class="el" href="group__graphs.html#gab5b3e7ed7cf2e6271b285c7ed39b87e2">node</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="operations_8h_source.html#l00072">72</a> of file <a class="el" href="operations_8h_source.html">operations.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae93e3be5f8fd4b43599b4c4bc18bbece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae93e3be5f8fd4b43599b4c4bc18bbece">&#9670;&nbsp;</a></span>cartesianProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::cartesianProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__graph-generators.html#ga282dbe6cafbcad0830bdc32bacf333a1">NodeMap</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeInProduct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Cartesian product of <code>G1</code> and <code>G2</code> and assigns it to <code>product</code>, with \(E = \{(\langle v_1,w_1\rangle, \langle v_1,w_2\rangle) | (w_1,w_2) \in E_2\} \cup \{(\langle v_1,w_1\rangle, \langle v_2,w_1\rangle) | (v_1,v_2) \in E_1\} \). </p>
<p>Multi-edges are kept and incorporated into the graph product.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G1</td><td>is the first input graph. </td></tr>
    <tr><td class="paramname">G2</td><td>is the second input graph. </td></tr>
    <tr><td class="paramname">product</td><td>is assigned the graph product. </td></tr>
    <tr><td class="paramname">nodeInProduct</td><td>is assigned a mapping from nodes of (<code>G1</code>, <code>G2</code>) to <code>product</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga061ae4c9a5ba165e0cc57998df2c878f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga061ae4c9a5ba165e0cc57998df2c878f">&#9670;&nbsp;</a></span>circulantGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::circulantGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>jumps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a circulant graph. </p>
<p>Generates a simple, undirected graph on \(n\) nodes \(V := v_0,v_1,\ldots,v_{n-1}\) that contains exactly the edges \( \{v_iv_{i+d}\colon v_i \in V, d \in \text{jumps}\} \) where node indices are to be understood modulo \(n\). The order of nodes induced by <code>G</code> is the sequence \(V\) given above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the generated graph. </td></tr>
    <tr><td class="paramname">jumps</td><td>is the array of distances for edges to be created. <div class="fragment"><div class="line"><a class="code" href="classogdf_1_1_graph.html">ogdf::Graph</a> <a class="code" href="namespaceogdf_1_1graphml.html#a8ec1f3d5a98f27193764249aa99275abadfcf28d0734569a6a693bc8194de62bf">G</a>;</div>
<div class="line"><a class="code" href="group__graph-generators.html#ga061ae4c9a5ba165e0cc57998df2c878f">ogdf::circulantGraph</a>(G, 11, <a class="code" href="classogdf_1_1_array.html">ogdf::Array&lt;int&gt;</a>({1,2,4}));</div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d8c6b9ec7744fc50a48678666bb9f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d8c6b9ec7744fc50a48678666bb9f76">&#9670;&nbsp;</a></span>completeBipartiteGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::completeBipartiteGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the complete bipartite graph <em>K_{n</em>,m}. </p>
<p>The returned graph is directed acyclic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the first partition set. </td></tr>
    <tr><td class="paramname">m</td><td>is the number of nodes of the second partition set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa3f3de8e779cf75d10d3784c8da491fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3f3de8e779cf75d10d3784c8da491fc">&#9670;&nbsp;</a></span>completeGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::completeGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the complete graph <em>K_n</em>. </p>
<p>The returned graph is directed acyclic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the generated graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga75e3a665f927e3200e63e4b9f16e5553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75e3a665f927e3200e63e4b9f16e5553">&#9670;&nbsp;</a></span>completeKPartiteGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::completeKPartiteGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_array.html">Array</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the complete k-partite graph <em>K_{k1</em>,k2,...,kn}. </p>
<p>The returned graph is directed acyclic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">signature</td><td>contains the positive values k1, k2, ..., kn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab4bec92ed404b35135d40ac73bce4398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4bec92ed404b35135d40ac73bce4398">&#9670;&nbsp;</a></span>coNormalProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::coNormalProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__graph-generators.html#ga282dbe6cafbcad0830bdc32bacf333a1">NodeMap</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeInProduct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the co-normal product of <code>G1</code> and <code>G2</code> and assigns it to <code>product</code>, with \(E = \{(\langle v_1,w_1\rangle, \langle v_2,w_2\rangle) | (v_1,v_2) \in E_1 \lor (w_1,w_2) \in E_2\} \). </p>
<p>Multi-edges are kept and incorporated into the graph product.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G1</td><td>is the first input graph. </td></tr>
    <tr><td class="paramname">G2</td><td>is the second input graph. </td></tr>
    <tr><td class="paramname">product</td><td>is assigned the graph product. </td></tr>
    <tr><td class="paramname">nodeInProduct</td><td>is assigned a mapping from nodes of (<code>G1</code>, <code>G2</code>) to <code>product</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab7c85da1b67c5f397be073826a532f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7c85da1b67c5f397be073826a532f39">&#9670;&nbsp;</a></span>cubeGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::cubeGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the graph <em>Q^n</em>: A <code>n</code>-cube graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of the cube's dimensions (n&gt;=0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabf374e75edf393767720724e794f6d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf374e75edf393767720724e794f6d41">&#9670;&nbsp;</a></span>customGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::customGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_list.html">List</a>&lt; std::pair&lt; int, int &gt;&gt;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a custom graph using a list of pairs to determine the graph's edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the generated graph. </td></tr>
    <tr><td class="paramname">edges</td><td>is a list of pairs, each one representing two nodes that should be connected by an edge in the generated graph. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="deterministic_8h_source.html#l00059">59</a> of file <a class="el" href="deterministic_8h_source.html">deterministic.h</a>.</p>

</div>
</div>
<a id="gad0a545afc61d9b588bb859851a024c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0a545afc61d9b588bb859851a024c7b">&#9670;&nbsp;</a></span>customGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::customGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_list.html">List</a>&lt; std::pair&lt; int, int &gt;&gt;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; <a class="el" href="group__graphs.html#gab5b3e7ed7cf2e6271b285c7ed39b87e2">node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a custom graph using a list of pairs to determine the graph's edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the generated graph. </td></tr>
    <tr><td class="paramname">edges</td><td>is a list of pairs, each one representing two nodes that should be connected by an edge in the generated graph. </td></tr>
    <tr><td class="paramname">nodes</td><td>resulting array mapping node index to the actual node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga44c2631acd39f73c7117a8a8c60d6071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44c2631acd39f73c7117a8a8c60d6071">&#9670;&nbsp;</a></span>emptyGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::emptyGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a graph with <code>nodes</code> nodes and no edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">nodes</td><td>is the number of nodes of the generated graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga55a948b303decd234d5d1d0a615fe70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55a948b303decd234d5d1d0a615fe70f">&#9670;&nbsp;</a></span>graphProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::graphProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__graph-generators.html#ga282dbe6cafbcad0830bdc32bacf333a1">NodeMap</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeInProduct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="group__graphs.html#gab5b3e7ed7cf2e6271b285c7ed39b87e2">node</a>, <a class="el" href="group__graphs.html#gab5b3e7ed7cf2e6271b285c7ed39b87e2">node</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>addEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the graph product of <code>G1</code> and <code>G2</code>, using a given function to add edges. </p>
<p>First, <code>product</code> is cleared. \(|V(G1)|\cdot|V(G2)|\) nodes are added to it and <code>addEdges</code> is called for each pair of nodes in \(V(G1) \times V(G2)\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G1</td><td>is the first input graph. </td></tr>
    <tr><td class="paramname">G2</td><td>is the second input graph. </td></tr>
    <tr><td class="paramname">product</td><td>is assigned the graph product. </td></tr>
    <tr><td class="paramname">nodeInProduct</td><td>is assigned a mapping from nodes of (<code>G1</code>, <code>G2</code>) to <code>product</code>. </td></tr>
    <tr><td class="paramname">addEdges</td><td>A function that adds edges to the graph product for each pair of nodes in \(V(G1) \times V(G2)\). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad652539b8c8f02edb3b1eb770955d72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad652539b8c8f02edb3b1eb770955d72f">&#9670;&nbsp;</a></span>graphUnion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::graphUnion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forms the disjoint union of <code>G1</code> and <code>G2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G1</td><td>is the first graph and assigned the graph union. </td></tr>
    <tr><td class="paramname">G2</td><td>is the second graph. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="operations_8h_source.html#l00052">52</a> of file <a class="el" href="operations_8h_source.html">operations.h</a>.</p>

</div>
</div>
<a id="ga83238ea79ba306e4942f8639f0a263d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83238ea79ba306e4942f8639f0a263d0">&#9670;&nbsp;</a></span>graphUnion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::graphUnion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_node_array.html">NodeArray</a>&lt; <a class="el" href="group__graphs.html#gab5b3e7ed7cf2e6271b285c7ed39b87e2">node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map2to1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallelfree</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the union of <code>G1</code> and <code>G2</code> while identifying nodes from <code>G2</code> with nodes from <code>G1</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G1</td><td>is the first graph and assigned the graph union. </td></tr>
    <tr><td class="paramname">G2</td><td>is the second graph. </td></tr>
    <tr><td class="paramname">map2to1</td><td>identifies nodes from <code>G2</code> with nodes from <code>G1</code>. Empty entries in <code>map2to1</code> have to be <code>nullptr</code>. It is assigned a mapping from nodes in <code>G2</code> to the union <code>G1</code>. </td></tr>
    <tr><td class="paramname">parallelfree</td><td>sets whether the resulting graph union should not contain multi-edges. </td></tr>
    <tr><td class="paramname">directed</td><td>sets whether the graph union is treated as directed or undirected when detecting multi-edges. It only has an effect if <code>parallelfree</code> is set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e5147b533c68c25f3372b3ec5c2f04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e5147b533c68c25f3372b3ec5c2f04b">&#9670;&nbsp;</a></span>gridGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::gridGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loopN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loopM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a (toroidal) grid graph on <code>n</code> x <code>m</code> nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes on first axis. </td></tr>
    <tr><td class="paramname">m</td><td>is the number of nodes on second axis. </td></tr>
    <tr><td class="paramname">loopN</td><td>if the grid is cyclic on first axis </td></tr>
    <tr><td class="paramname">loopM</td><td>if the grid is cyclic on second axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7e5ff20296166cf41de0bf597932f271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e5ff20296166cf41de0bf597932f271">&#9670;&nbsp;</a></span>lexicographicalProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::lexicographicalProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__graph-generators.html#ga282dbe6cafbcad0830bdc32bacf333a1">NodeMap</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeInProduct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the lexicographical product of <code>G1</code> and <code>G2</code> and assigns it to <code>product</code>, with \(E = \{(\langle v_1,w_1\rangle, \langle v_2,w_2\rangle) | (v_1,v_2) \in E_1\} \cup \{(\langle v_1,w_1\rangle, \langle v_1,w_2\rangle) | (w_1,w_2) \in E_2\} \). </p>
<dl class="section warning"><dt>Warning</dt><dd>The lexicographical product is not commutative! Multi-edges are kept and incorporated into the graph product.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G1</td><td>is the first input graph. </td></tr>
    <tr><td class="paramname">G2</td><td>is the second input graph. </td></tr>
    <tr><td class="paramname">product</td><td>is assigned the graph product. </td></tr>
    <tr><td class="paramname">nodeInProduct</td><td>is assigned a mapping from nodes of (<code>G1</code>, <code>G2</code>) to <code>product</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2ba57f8ac28485c787b42de492ce03d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ba57f8ac28485c787b42de492ce03d3">&#9670;&nbsp;</a></span>modularProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::modularProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__graph-generators.html#ga282dbe6cafbcad0830bdc32bacf333a1">NodeMap</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeInProduct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the modular product of <code>G1</code> and <code>G2</code> and assigns it to <code>product</code>, with \(E = \{(\langle v_1,w_1\rangle, \langle v_2,w_2\rangle) | (v_1,v_2) \in E_1 \land (w_1,w_2) \in E_2\} \cup \{(\langle v_1,w_1\rangle, \langle v_2,w_2\rangle) | (v_1,v_2) \not\in E_1 \land (w_1,w_2) \not\in E_2\} \). </p>
<p>Multi-edges are kept and incorporated into the graph product.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G1</td><td>is the first input graph. </td></tr>
    <tr><td class="paramname">G2</td><td>is the second input graph. </td></tr>
    <tr><td class="paramname">product</td><td>is assigned the graph product. </td></tr>
    <tr><td class="paramname">nodeInProduct</td><td>is assigned a mapping from nodes of (<code>G1</code>, <code>G2</code>) to <code>product</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9473b8540a5bbe604f84042d30c8a47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9473b8540a5bbe604f84042d30c8a47f">&#9670;&nbsp;</a></span>petersenGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::petersenGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a generalized Petersen graph. </p>
<p>Creates an outer cycle of nodes <em>1</em>, ..., <code>n</code>, each of which has a direct neighbor (a corresponding inner node). For two outer nodes <em>i</em>, <em>j</em>, there is an edge between their corresponding inner nodes if the absolute difference of <em>i</em> and <em>j</em> equals the jump length <code>m</code>.</p>
<p>If no values for <code>n</code> or <code>m</code> are given, assume the standard Petersen graph of <code>5</code> nodes and a jump length of <code>2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes on the outer cycle. </td></tr>
    <tr><td class="paramname">m</td><td>is the length of jumps for the inner part. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga70be73bda36b4aeb89122bcd3154af7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70be73bda36b4aeb89122bcd3154af7c">&#9670;&nbsp;</a></span>preferentialAttachmentGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::preferentialAttachmentGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minDegree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a graph where new nodes are more likely to connect to nodes with high degree. </p>
<p>Implements the Preferential Attachment algorithm as described in: Emergence of Scaling in Random Networks Albert-Laszlo Barabasi and Reka Albert <a href="https://arxiv.org/abs/cond-mat/9910332v1">https://arxiv.org/abs/cond-mat/9910332v1</a> This algorithm creates edges based on the degree of nodes, so it is most useful to apply this to a pre-built graph. If no graph is supplied, a complete graph of <code>minDegree</code> nodes is generated and the algorithm adds <code>nodes</code> - <code>minDegree</code> nodes. If a graph is supplied, it must contain at least <code>minDegree</code> nodes of degree 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is the input graph (see above) and is assigned the expanded graph. </td></tr>
    <tr><td class="paramname">nodes</td><td>is the number of nodes to be added to graph. </td></tr>
    <tr><td class="paramname">minDegree</td><td>is the minimum degree of new nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae84cb709f5fcb098528bc0474d1a55b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae84cb709f5fcb098528bc0474d1a55b2">&#9670;&nbsp;</a></span>randomBiconnectedGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomBiconnectedGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random biconnected graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the generated graph. </td></tr>
    <tr><td class="paramname">m</td><td>is the number of edges of the generated graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>n</code> has a lower bound of 3, and <code>m</code> a lower bound of <code>n</code>. If the parameters are smaller than that, they get increased prior to the algorithm. </dd></dl>

</div>
</div>
<a id="ga5163ba3842a6d1cec25c758b2ac12899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5163ba3842a6d1cec25c758b2ac12899">&#9670;&nbsp;</a></span>randomChungLuGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomChungLuGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>expectedDegreeDistribution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a graph where edges are inserted based on given weights. </p>
<p>Implements the algorithm described in: The average distance in a random graph with given expected degrees Fang Chung and Linyuan Lu <a href="http://www.math.ucsd.edu/~fan/wp/aveflong.pdf">http://www.math.ucsd.edu/~fan/wp/aveflong.pdf</a></p>
<p>Given an expected degree distribution of length <em>n:</em> \(w:=(w_1, ..., w_n)\) with \(0 &lt; w_k &lt; n\).</p>
<p>Let \(S:=\sum_{k=1}^{n}w_k\) be the sum over all expected degrees. Consider each edge independently and insert it with probability \(p_{ij} := \frac{w_i \, w_j}{S}\). Therefore, to get percentages in \((0,1)\) we assert that \(\max\limits_k(w_k)^2 &lt; S\).</p>
<dl class="section pre"><dt>Precondition</dt><dd>Each degree must be strictly between <em>0</em> and <em>n</em>, and the square of the maximal expected degree must be lower than the sum of all expected degrees.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">expectedDegreeDistribution</td><td>is a list of expected degrees, or weights, for the individual nodes. Its length defines the number of nodes <em>n</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1c51749db17a3cb4362789e28b3efd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c51749db17a3cb4362789e28b3efd9f">&#9670;&nbsp;</a></span>randomClusterGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomClusterGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_cluster_graph.html">ClusterGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__graphs.html#gab5b3e7ed7cf2e6271b285c7ed39b87e2">node</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>moreInLeaves</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a specified cluster structure to a given graph <code>G</code>, and assigns vertices to clusters. </p>
<p>This function is called with a graph <code>G</code> and the root of a second graph, resembling a tree, that gives the cluster structure. Then, the vertices of G are randomly assigned to the clusters, where we can guarantee that any leaf-cluster has (on average) <em>moreInLeaves</em>-times more vertices than a non-leaf cluster. (E.g. if <code>moreInLeaves</code> = 5, any leaf will contain roughly 5 times more vertices than an inner cluster) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>is a cluster graph for <code>G</code>, to be assigned the solution. </td></tr>
    <tr><td class="paramname">G</td><td>is the input graph. </td></tr>
    <tr><td class="paramname">root</td><td>is a node in some other graph (say <em>T</em>). <em>T</em> is a tree that we will consider rooted at <code>root</code>. <em>T</em> is the pattern for the cluster hierarchy. </td></tr>
    <tr><td class="paramname">moreInLeaves</td><td>is a factor such that leaf-clusters have on average <em>moreInLeaves</em>-times more vertices than inner clusters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>G</code> contains at least twice as many nodes as <em>T</em> has leaves. </dd></dl>

</div>
</div>
<a id="ga519fee82a5b4ee56b07e74f32e1ff7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga519fee82a5b4ee56b07e74f32e1ff7d9">&#9670;&nbsp;</a></span>randomClusterGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomClusterGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_cluster_graph.html">ClusterGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns random clusters to a given graph <code>G</code>. </p>
<p>This function is called with a graph <code>G</code> and creates randomly clusters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is the input graph. </td></tr>
    <tr><td class="paramname">C</td><td>is a cluster graph for <code>G</code>. </td></tr>
    <tr><td class="paramname">cNum</td><td>is the maximal number of clusters introduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>G</code> is connected and not empty and <code>C</code> is initialized with <code>G</code>. </dd></dl>

</div>
</div>
<a id="ga85a79853e408557d003de19d0034614e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85a79853e408557d003de19d0034614e">&#9670;&nbsp;</a></span>randomClusterPlanarGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomClusterPlanarGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_cluster_graph.html">ClusterGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns random clusters to a given graph <code>G</code>. </p>
<p>This function is called with a graph <code>G</code> and creates randomly clusters. The resulting cluster graph is always c-connected and, if G is planar, also c-planar. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is the input graph. </td></tr>
    <tr><td class="paramname">C</td><td>is a cluster graph for <code>G</code>. </td></tr>
    <tr><td class="paramname">cNum</td><td>is the maximal number of Clusters introduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>G</code> is connected and not empty and <em>C</em> is initialized with <em>G</em>. </dd></dl>

</div>
</div>
<a id="gabfc90d445bff2e543aeae557af7da45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfc90d445bff2e543aeae557af7da45b">&#9670;&nbsp;</a></span>randomDigraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomDigraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random (simple) directed graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes in the generated graph. </td></tr>
    <tr><td class="paramname">p</td><td>is the probability that an edge is created (for each node pair) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac378d37324b0feb49b6bbf7430970308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac378d37324b0feb49b6bbf7430970308">&#9670;&nbsp;</a></span>randomEdgesGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomEdgesGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(<a class="el" href="group__graphs.html#gab5b3e7ed7cf2e6271b285c7ed39b87e2">node</a>, <a class="el" href="group__graphs.html#gab5b3e7ed7cf2e6271b285c7ed39b87e2">node</a>)&gt;&#160;</td>
          <td class="paramname"><em>probability</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts edges into the given graph based on probabilities given by a callback function. </p>
<p>Iterates through each distinct pair of nodes and inserts an edge with the probability returned by the provided callback function.</p>
<p>The resulting graph is guaranteed to be simple if:</p><ul>
<li>the input graph had no edges, or</li>
<li>the input graph was simple and the callback function returns 0 for each pair of nodes that was connected before.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is a graph that should have at least two nodes (so edges can be generated) </td></tr>
    <tr><td class="paramname">probability</td><td>is a callback function that, for any given pair of nodes, returns a probability between 0 and 1 for the two nodes to be connected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabf06aebce8dcd68412cecd330c8d83b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf06aebce8dcd68412cecd330c8d83b5">&#9670;&nbsp;</a></span>randomGeographicalThresholdGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomGeographicalThresholdGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D &amp;&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random geometric graph where edges are created based on their distance and the weight of nodes. </p>
<p>This generator uses \(r^{-\alpha}\) for the given <code>alpha</code> as heuristic function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__graph-generators.html#ga65f5f08f024374b5816505aa018f05d4" title="Creates a random geometric graph where edges are created based on their distance and the weight of no...">randomGeographicalThresholdGraph(Graph &amp;G, Array&lt;int&gt; &amp;weights, D &amp;dist, double threshold, std::function&lt;double(double)&gt; h, int dimension)</a> for detailed description.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">D</td><td>the random distribution to use (see <code>dist</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">weights</td><td>has the weights for all nodes in the graph. </td></tr>
    <tr><td class="paramname">dist</td><td>is a random number distribution, e.g. <code>std::uniform_int_distribution&lt;&gt;</code>. It should likely generate values in roughly the same order of magnitude as <code>1/<code>threshold</code>.</code> </td></tr>
    <tr><td class="paramname">threshold</td><td>is the threshold for edge insertion. </td></tr>
    <tr><td class="paramname">alpha</td><td>is the constant in the heuristic function. </td></tr>
    <tr><td class="paramname">dimension</td><td>is the dimension the nodes are laid out in. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="random_geographical_threshold_graph_8h_source.html#l00120">120</a> of file <a class="el" href="random_geographical_threshold_graph_8h_source.html">randomGeographicalThresholdGraph.h</a>.</p>

</div>
</div>
<a id="ga65f5f08f024374b5816505aa018f05d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65f5f08f024374b5816505aa018f05d4">&#9670;&nbsp;</a></span>randomGeographicalThresholdGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomGeographicalThresholdGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_array.html">Array</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D &amp;&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(double)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random geometric graph where edges are created based on their distance and the weight of nodes. </p>
<p>Geographical threshold graphs with small-world and scale-free properties Naoki Masuda, Hiroyoshi Miwa, Norio Konno <a href="https://arxiv.org/abs/cond-mat/0409378">https://arxiv.org/abs/cond-mat/0409378</a></p>
<p>Distribute vertices using an exponential distribution in a d-dimensional Euclidean space. Then a pair of vertices with weights <em>w</em>,<em>w'</em> and Euclidean distance \(r:=||w-w&#39;||\) are connected iff for the heuristic function <code>h</code> holds: \((w+w&#39;)*h(r) &lt; \mathrm{threshold}\).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">D</td><td>the random distribution to use (see <code>dist</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">weights</td><td>has the weights for all nodes in the graph. </td></tr>
    <tr><td class="paramname">dist</td><td>is a random number distribution, e.g. <code>std::uniform_int_distribution&lt;&gt;</code>. It should likely generate values in roughly the same order of magnitude as <code>h</code>(<code>threshold</code>). </td></tr>
    <tr><td class="paramname">threshold</td><td>is the threshold for edge insertion. </td></tr>
    <tr><td class="paramname">h</td><td>is a function that should be decreasing in the distance supplied to it. </td></tr>
    <tr><td class="paramname">dimension</td><td>is the dimension the nodes are laid out in. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="random_geographical_threshold_graph_8h_source.html#l00067">67</a> of file <a class="el" href="random_geographical_threshold_graph_8h_source.html">randomGeographicalThresholdGraph.h</a>.</p>

</div>
</div>
<a id="gaa22bfe93fe65faf3f59f3c966a71471b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa22bfe93fe65faf3f59f3c966a71471b">&#9670;&nbsp;</a></span>randomGeometricCubeGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomGeometricCubeGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random geometric graph by laying out nodes in a unit n-cube. Nodes with a distance &lt; threshold are connected, 0 &lt;= threshold &lt;= sqrt(dimension). The graph is simple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">nodes</td><td>is the number of nodes of the generated graph. </td></tr>
    <tr><td class="paramname">threshold</td><td>is threshold radius of nodes which will be connected. </td></tr>
    <tr><td class="paramname">dimension</td><td>is the dimension of the cube. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0feff1b510864aba8b73a1b34e5f2ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0feff1b510864aba8b73a1b34e5f2ca1">&#9670;&nbsp;</a></span>randomGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the generated graph. </td></tr>
    <tr><td class="paramname">m</td><td>is the number of edges of the generated graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa4f8e06a35368a8ce24efcbb71bf1e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4f8e06a35368a8ce24efcbb71bf1e36">&#9670;&nbsp;</a></span>randomHierarchy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomHierarchy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>planar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>singleSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>longEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random hierarchical graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes. </td></tr>
    <tr><td class="paramname">m</td><td>is the number of edges. </td></tr>
    <tr><td class="paramname">planar</td><td>determines if the resulting graph is (level-)planar. </td></tr>
    <tr><td class="paramname">singleSource</td><td>determines if the graph is a single-source graph. </td></tr>
    <tr><td class="paramname">longEdges</td><td>determines if the graph has long edges (spanning 2 layers or more); otherwise the graph is proper. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga27a0d0e584ba5cdfe1e0cd4049b793ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27a0d0e584ba5cdfe1e0cd4049b793ca">&#9670;&nbsp;</a></span>randomPlanarBiconnectedDigraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomPlanarBiconnectedDigraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multiEdges</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random planar biconnected acyclic (embedded) digraph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the generated graph. </td></tr>
    <tr><td class="paramname">m</td><td>is the number of edges of the generated graph. </td></tr>
    <tr><td class="paramname">p</td><td>up to <code>m</code> * <code>p</code> edges will be reversed preversing acyclicity; default = 0.0. </td></tr>
    <tr><td class="paramname">multiEdges</td><td>determines if the generated graph may contain multi-edges; default = false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>d</code> is between 0.0 and 1.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>n</code> has a lower bound of 3, and <code>m</code> has a lower bound of <code>n</code> and an upper bound of \(3n-6\). The supplied values are adjusted if they are out of these bounds. </dd></dl>

</div>
</div>
<a id="gad0e3ab667c0cda3afe62c22f780b162c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0e3ab667c0cda3afe62c22f780b162c">&#9670;&nbsp;</a></span>randomPlanarBiconnectedGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomPlanarBiconnectedGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multiEdges</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random planar biconnected (embedded) graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the generated graph. </td></tr>
    <tr><td class="paramname">m</td><td>is the number of edges of the generated graph. </td></tr>
    <tr><td class="paramname">multiEdges</td><td>determines if the generated graph may contain multi-edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>n</code> has a lower bound of 3, and <code>m</code> has a lower bound of <code>n</code> and an upper bound of \(3n-6\). The supplied values are adjusted if they are out of these bounds. </dd></dl>

</div>
</div>
<a id="gae4da58b786a2bb0c8eff99fa9b205e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4da58b786a2bb0c8eff99fa9b205e58">&#9670;&nbsp;</a></span>randomPlanarCNBGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomPlanarCNBGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random planar graph, that is connected, but not biconnected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the max. number of nodes in each biconnected component </td></tr>
    <tr><td class="paramname">m</td><td>is the max. number of edges in each biconnected component </td></tr>
    <tr><td class="paramname">b</td><td>is the number of biconnected components</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>It holds that n &gt; 1, m &gt;= n (unless n = 2, m = 1) and b &gt; 1. </dd></dl>

</div>
</div>
<a id="gae9de58fd22ae2533f0d81d450d4bf985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9de58fd22ae2533f0d81d450d4bf985">&#9670;&nbsp;</a></span>randomPlanarConnectedGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomPlanarConnectedGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random connected (simple) planar (embedded) graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the generated graph. </td></tr>
    <tr><td class="paramname">m</td><td>is the number of edges of the generated graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>n</code> has a lower bound of 1, and <code>m</code> has a lower bound of <code>n</code> and an upper bound of \(3n-6\). The supplied values are adjusted if they are out of these bounds. </dd></dl>

</div>
</div>
<a id="ga38b77440e49db5110960a11be8195a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38b77440e49db5110960a11be8195a30">&#9670;&nbsp;</a></span>randomPlanarTriconnectedGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomPlanarTriconnectedGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random planar triconnected (and simple) graph. </p>
<p>This graph generator creates a planar triconnected graph by successive node splitting. It starts with the <em>K_4</em> and performs <code>n</code> -4 node splits. Each such split operation distributes a node's neighbors to the two nodes resulting from the split. Aftewards, two further edges can be added; the probability for adding these edges is given by <code>p1</code> and <code>p2</code>. The higher these probabilities, the denser the resulting graph. Note that a simple planar triconnected graph has between 1.5<code>n</code> and 3<code>n</code> -6 edges.</p>
<dl class="section pre"><dt>Precondition</dt><dd>0.0 &lt;= <code>p1</code>, <code>p2</code> &lt;= 1.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes in the generated graph. </td></tr>
    <tr><td class="paramname">p1</td><td>is the probability for the first additional edge to be added. </td></tr>
    <tr><td class="paramname">p2</td><td>is the probability for the second additional edge to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>n</code> has a lower bound of 4 and will get increased to this if smaller. </dd></dl>

</div>
</div>
<a id="ga6602d5f7709f793dcc53e83e1875b1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6602d5f7709f793dcc53e83e1875b1a6">&#9670;&nbsp;</a></span>randomPlanarTriconnectedGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomPlanarTriconnectedGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random planar triconnected (and simple) graph. </p>
<p>This graph generator works in two steps.</p><ol type="1">
<li>A planar triconnected 3-regular graph is constructed using successive splitting of pairs of nodes. The constructed graph has <code>n</code> nodes and 1.5<code>n</code> edges.</li>
<li>The remaining edges are inserted by successive splitting of faces with degree four or greater. The resulting graph also represents a combinatorial embedding.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes in the generated graph. </td></tr>
    <tr><td class="paramname">m</td><td>is the number of edges in the generated graph.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li><code>n</code> &gt;= 4 and <code>n</code> must be even; otherwise, <code>n</code> is adjusted to the next feasible integer.</li>
<li>1.5<code>n</code> &lt;= <code>m</code> &lt;= 3<code>n</code> -6; otherwise, <code>m</code> is adjusted to a feasible value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5e2b0644b941d5f8bb7770a27a1f6171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e2b0644b941d5f8bb7770a27a1f6171">&#9670;&nbsp;</a></span>randomRegularGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomRegularGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random <code>d</code>-regular graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the generated graph. </td></tr>
    <tr><td class="paramname">d</td><td>is the degree of each vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>n</code> * <code>d</code> must be even </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is not guaranteed to terminate! </dd></dl>

</div>
</div>
<a id="gab7bf735577889df8926599b1152957f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7bf735577889df8926599b1152957f5">&#9670;&nbsp;</a></span>randomSeriesParallelDAG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomSeriesParallelDAG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>flt</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random (simple, biconnected) series parallel DAG. </p>
<p>This function creates a random series parallel biconnected DAG. Note, that the resulting graph is trivially upward planar! To use this generator for experiments, e.g. concerning upward planarity, you can fit the graph by reversing some edges with the parameter 0 &lt; flt &lt; 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">edges</td><td>is the number of edges in the generated graph. </td></tr>
    <tr><td class="paramname">p</td><td>= probability of a series composition; default = 0.5 </td></tr>
    <tr><td class="paramname">flt</td><td>= up to edges*flt edges will be reversed preversing acyclicity; default = 0.0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>p</code> is in \([0.0, 1.0]\), and <code>flt</code> is in \([0.0, 1.0)\). </dd></dl>

</div>
</div>
<a id="ga781aeb9ae0e597beb8cfd97f2dc15201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga781aeb9ae0e597beb8cfd97f2dc15201">&#9670;&nbsp;</a></span>randomSimpleConnectedGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ogdf::randomSimpleConnectedGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random simple and connected graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the generated graph. </td></tr>
    <tr><td class="paramname">m</td><td>is the number of edges of the generated graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6991a8ef695dc1ce1c320aeb843856d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6991a8ef695dc1ce1c320aeb843856d">&#9670;&nbsp;</a></span>randomSimpleGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ogdf::randomSimpleGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random simple graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the generated graph. </td></tr>
    <tr><td class="paramname">m</td><td>is the number of edges of the generated graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga066156d279149423d377f108d42b19c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga066156d279149423d377f108d42b19c1">&#9670;&nbsp;</a></span>randomSimpleGraphByProbability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ogdf::randomSimpleGraphByProbability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random simple graph. </p>
<p>Algorithm based on PreZER/LogZER from: Sadegh Nobari, Xuesong Lu, Panagiotis Karras, and Stphane Bressan. 2011. Fast random graph generation. In Proceedings of the 14th International Conference on Extending Database Technology (EDBT/ICDT '11), ACM, New York, NY, USA, 331-342. DOI=<a href="http://dx.doi.org/10.1145/1951365.1951406">http://dx.doi.org/10.1145/1951365.1951406</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the generated graph. </td></tr>
    <tr><td class="paramname">pEdge</td><td>is the probability for each edge to be added into the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>/p pEdge is in [0, 1] </dd></dl>

</div>
</div>
<a id="ga95ff41c015fe92cc550088127e43d09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95ff41c015fe92cc550088127e43d09c">&#9670;&nbsp;</a></span>randomTree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random tree (simpler version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the tree. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad83c1576fee773abf95334f842f6849b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad83c1576fee773abf95334f842f6849b">&#9670;&nbsp;</a></span>randomTree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxDeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the tree. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the tree. </td></tr>
    <tr><td class="paramname">maxDeg</td><td>is the maximal allowed node degree; 0 means no restriction. </td></tr>
    <tr><td class="paramname">maxWidth</td><td>is the maximal allowed width of a level; 0 means no restriction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>if <code>maxDeg</code> or <code>maxWidth</code> are 0 (or negative), they are set to <code>n</code> </dd></dl>

</div>
</div>
<a id="gadad6b837cade23898f3dc0ae68239274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadad6b837cade23898f3dc0ae68239274">&#9670;&nbsp;</a></span>randomTriconnectedGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomTriconnectedGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random triconnected (and simple) graph. </p>
<p>The graph generator proceeds as follows. It starts with a <em>K_4</em> and performs then <code>n</code> -4 split node operations on randomly selected nodes of the graph constructed so far. Each such operation splits a node <em>v</em> into two nodes <em>x</em> and <em>y</em> and distributes <em>v's</em> neighbors to the two nodes such that each node gets at least two neighbors. Additionally, the edge (<em>x</em>,<em>y</em>) is inserted.</p>
<p>The neighbors are distributed such that a neighbor of <em>v</em> becomes</p><ul>
<li>only a neighbor of <em>x</em> with probability <code>p1</code>;</li>
<li>only a neighbor of <em>y</em> with probability <code>p1</code>;</li>
<li>a neighbor of both <em>x</em> and <em>y</em> with probability 1.0 - <code>p1</code> - <code>p2</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes in the generated graph. </td></tr>
    <tr><td class="paramname">p1</td><td>is the probability that an edge is moved only to the left node after splitting a node. </td></tr>
    <tr><td class="paramname">p2</td><td>is the probability that an edge is moved only to the right node after splitting a node.</td></tr>
  </table>
  </dd>
</dl>
<p>The probability for a neighbor to be moved to both split nodes is 1.0 - <code>p1</code> - <code>p2</code>. The higher this probability, the higher the density of the resulting graph.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The probabilities <em>p1</em> and <em>p2</em> must lie between 0.0 and 1.0, and <code>p1</code> + <code>p2</code> &lt;= 1.0. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>n</code> has a lower bound of 4 and will get increased to this if smaller. </dd></dl>

</div>
</div>
<a id="ga1b40a1075eb63d5a28b0655d701dec67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b40a1075eb63d5a28b0655d701dec67">&#9670;&nbsp;</a></span>randomUpwardPlanarBiconnectedDigraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomUpwardPlanarBiconnectedDigraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a random upward planar biconnected (embedded) digraph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the generated graph. </td></tr>
    <tr><td class="paramname">m</td><td>is the number of edges of the generated graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>n</code> has a lower bound of 3, and <code>m</code> has a lower bound of <code>n</code> and an upper bound of \(3n-6\). The supplied values are adjusted if they are out of these bounds. </dd></dl>

</div>
</div>
<a id="gaba4c92aaba97ed6ec8c4e250268f5c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba4c92aaba97ed6ec8c4e250268f5c5a">&#9670;&nbsp;</a></span>randomWattsStrogatzGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomWattsStrogatzGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>probability</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a "small world" graph as described by Watts &amp; Strogatz. </p>
<p>Takes a regular lattice graph and, with given probability, rewires each edge to a random other non-neighbor.</p>
<p>Collective dynamics of small-world networks <a href="https://www.nature.com/articles/30918.pdf">https://www.nature.com/articles/30918.pdf</a></p>
<dl class="section warning"><dt>Warning</dt><dd>This implementation does not perform very well if <code>k</code> is close to half of <code>n</code> for large graphs.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the generated graph. </td></tr>
    <tr><td class="paramname">k</td><td>is the initial degree of each node and must be even and smaller than half of <code>n</code>. </td></tr>
    <tr><td class="paramname">probability</td><td>determines how likely each edge is rewired. A probability of 0 will not modify the graph, while one of 1 will cause full randomness. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga28d983e7ad7f1dc8b4e91cb4326e68ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28d983e7ad7f1dc8b4e91cb4326e68ec">&#9670;&nbsp;</a></span>randomWaxmanGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::randomWaxmanGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>height</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a Waxman graph where nodes are uniformly randomly placed in a grid, then edges are inserted based on nodes' euclidean distances. </p>
<pre class="fragment">Routing of Multipoint Connections
Bernard M. Waxman (1988)
</pre><p>After generating the nodes, edges are inserted between each pair of nodes <em>v</em>, <em>w</em> with probability based on their euclidean distance \(\beta \exp{\frac{-||v-w||}{m \, \alpha}}\) where \(m:=\max\limits_{u,v}||u-v||\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">nodes</td><td>is the number of nodes of the generated graph. </td></tr>
    <tr><td class="paramname">alpha</td><td>is a parameter for the probability in the range (0,1]. Small values increase the density of short edges relative to longer ones. </td></tr>
    <tr><td class="paramname">beta</td><td>is a parameter for the probability in the range (0,1]. Large values result in a graph with higher edge density. </td></tr>
    <tr><td class="paramname">width</td><td>is the width of the area the nodes are distributed in. </td></tr>
    <tr><td class="paramname">height</td><td>is the height of the area the nodes are distributed in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6c2abcc203dcfc0839f5233afeebbe5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c2abcc203dcfc0839f5233afeebbe5d">&#9670;&nbsp;</a></span>regularLatticeGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::regularLatticeGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a regular lattice graph. </p>
<p>Generates a cycle on <code>n</code> sequential nodes, where any two nodes whose distance is at most <code>k</code> / 2 are connected by an additional edge. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__graph-generators.html#ga061ae4c9a5ba165e0cc57998df2c878f" title="Creates a circulant graph.">circulantGraph(Graph&amp;, int, Array&lt;int&gt;)</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes in the graph. </td></tr>
    <tr><td class="paramname">k</td><td>is the degree of each node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>n</code> must be at least 4, <code>k</code> must be an even number between 0 and <code>n-2</code>. </dd></dl>

</div>
</div>
<a id="gac0cfb1b80c90a6f6cea17589bc522c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0cfb1b80c90a6f6cea17589bc522c29">&#9670;&nbsp;</a></span>regularTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::regularTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a regular tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the tree. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes of the tree. </td></tr>
    <tr><td class="paramname">children</td><td>is the number of children per node. root has index 0, the next level has indizes 1...children, the children of node 1 have indizes children+1...2*children, etc. if number of nodes does not allow a regular node, the "last" node will have fewer children. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabbe43c8492ebfd2ce8e9d96153e12c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbe43c8492ebfd2ce8e9d96153e12c90">&#9670;&nbsp;</a></span>rootedProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::rootedProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__graph-generators.html#ga282dbe6cafbcad0830bdc32bacf333a1">NodeMap</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeInProduct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__graphs.html#gab5b3e7ed7cf2e6271b285c7ed39b87e2">node</a>&#160;</td>
          <td class="paramname"><em>rootInG2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the rooted product of <code>G1</code> and <code>G2</code>, rooted in <code>rootInG2</code>, and assigns it to <code>product</code>. </p>
<p>Multi-edges are kept and incorporated into the graph product.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G1</td><td>is the first input graph. </td></tr>
    <tr><td class="paramname">G2</td><td>is the second input graph. </td></tr>
    <tr><td class="paramname">product</td><td>is assigned the graph product. </td></tr>
    <tr><td class="paramname">nodeInProduct</td><td>is assigned a mapping from nodes of (<code>G1</code>, <code>G2</code>) to <code>product</code>. </td></tr>
    <tr><td class="paramname">rootInG2</td><td>is the node of <code>G2</code> that is identified with every node of <code>G1</code> once in order to create the rooted product. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga817f2f7a6c23b0df0845224c43aec61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga817f2f7a6c23b0df0845224c43aec61a">&#9670;&nbsp;</a></span>strongProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::strongProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__graph-generators.html#ga282dbe6cafbcad0830bdc32bacf333a1">NodeMap</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeInProduct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the strong product of <code>G1</code> and <code>G2</code> and assigns it to <code>product</code>, with \(E = \{(\langle v_1,w_1\rangle, \langle v_1,w_2\rangle) | (w_1,w_2) \in E_2\} \cup \{(\langle v_1,w_1\rangle, \langle v_2,w_1\rangle) | (v_1,v_2) \in E_1\} \cup \{(\langle v_1,w_1\rangle, \langle v_2,w_2\rangle) | (v_1,v_2) \in E_1 \land (w_1,w_2) \in E_2\} \). </p>
<p>Multi-edges are kept and incorporated into the graph product.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G1</td><td>is the first input graph. </td></tr>
    <tr><td class="paramname">G2</td><td>is the second input graph. </td></tr>
    <tr><td class="paramname">product</td><td>is assigned the graph product. </td></tr>
    <tr><td class="paramname">nodeInProduct</td><td>is assigned a mapping from nodes of (<code>G1</code>, <code>G2</code>) to <code>product</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b6fc792acfc6697de0ae62c01df372b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b6fc792acfc6697de0ae62c01df372b">&#9670;&nbsp;</a></span>suspension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::suspension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies <code>G</code> by adding its <code>s</code>-th suspension. </p>
<p>A suspension node is a node that is connected to all other nodes in the graph. This function adds <code>s</code> such suspension nodes that will not be directly connected to each other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is the graph to extend. </td></tr>
    <tr><td class="paramname">s</td><td>is the amount of suspension nodes to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5ccd70ceb0ec85e2d48a6f14db544ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ccd70ceb0ec85e2d48a6f14db544ade">&#9670;&nbsp;</a></span>tensorProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::tensorProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__graph-generators.html#ga282dbe6cafbcad0830bdc32bacf333a1">NodeMap</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeInProduct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the tensor product of <code>G1</code> and <code>G2</code> and assigns it to <code>product</code>, with \(E = \{(\langle v_1,w_1\rangle, \langle v_2,w_2\rangle) | (v_1,v_2) \in E_1 \land (w_1,w_2) \in E_2\} \). </p>
<p>Multi-edges are kept and incorporated into the graph product.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G1</td><td>is the first input graph. </td></tr>
    <tr><td class="paramname">G2</td><td>is the second input graph. </td></tr>
    <tr><td class="paramname">product</td><td>is assigned the graph product. </td></tr>
    <tr><td class="paramname">nodeInProduct</td><td>is assigned a mapping from nodes of (<code>G1</code>, <code>G2</code>) to <code>product</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8cf4c76cee9dcb8bf4dbc3a13b401e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cf4c76cee9dcb8bf4dbc3a13b401e2f">&#9670;&nbsp;</a></span>wheelGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ogdf::wheelGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classogdf_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the graph <em>W_n:</em> A wheel graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>is assigned the generated graph. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of nodes on the rim of the wheel (W_n). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>n</code> must be at least 2. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__graph-generators_html_ga061ae4c9a5ba165e0cc57998df2c878f"><div class="ttname"><a href="group__graph-generators.html#ga061ae4c9a5ba165e0cc57998df2c878f">ogdf::circulantGraph</a></div><div class="ttdeci">void circulantGraph(Graph &amp;G, int n, Array&lt; int &gt; jumps)</div><div class="ttdoc">Creates a circulant graph.</div></div>
<div class="ttc" id="aclassogdf_1_1_array_html"><div class="ttname"><a href="classogdf_1_1_array.html">ogdf::Array&lt; int &gt;</a></div></div>
<div class="ttc" id="aclassogdf_1_1_graph_html"><div class="ttname"><a href="classogdf_1_1_graph.html">ogdf::Graph</a></div><div class="ttdoc">Data type for general directed graphs (adjacency list representation).</div><div class="ttdef"><b>Definition:</b> <a href="_graph__d_8h_source.html#l00495">Graph_d.h:495</a></div></div>
<div class="ttc" id="anamespaceogdf_1_1graphml_html_a8ec1f3d5a98f27193764249aa99275abadfcf28d0734569a6a693bc8194de62bf"><div class="ttname"><a href="namespaceogdf_1_1graphml.html#a8ec1f3d5a98f27193764249aa99275abadfcf28d0734569a6a693bc8194de62bf">ogdf::graphml::Attribute::G</a></div><div class="ttdeci">@ G</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
 <ul>
  <li class="footer">&copy; 1999&ndash;2022 <a href="http://ogdf.net/team/">The OGDF Team</a></li>
 </ul>
</div>
</body>
</html>
